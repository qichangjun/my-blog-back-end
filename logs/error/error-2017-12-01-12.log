[2017-12-01 12:06:35.867] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/users/login
request client ip:  ::1
request body: 
{"userName":"admin","password":"2017Dctm@1234"}
response time: 8
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"success\",\n  \"data\": {\n    \"token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxMTk1LCJleHAiOjE1MTIxNDQzOTV9.26_kwPBFVAxJoh5IgfjzaIeml79YcIzG7AdocJv8SRE\",\n    \"userName\": \"admin\",\n    \"role\": \"normal\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:06:36.321] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/users/getUserInfo?userName=admin
request client ip:  ::1
request query:  {"userName":"admin"}
response time: 2
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"回复成功\",\n  \"data\": {\n    \"userName\": \"admin\",\n    \"registerTime\": \"2017-11-23T07:36:51.931Z\",\n    \"message\": []\n  }\n}"
*************** response log end ***************

[2017-12-01 12:06:36.335] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/art/getArticleLists
request client ip:  ::1
request body: 
{"currentPage":1,"pageSize":10,"sortField":"lastReplyTime","totalElement":1,"labels":[],"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxMTk1LCJleHAiOjE1MTIxNDQzOTV9.26_kwPBFVAxJoh5IgfjzaIeml79YcIzG7AdocJv8SRE"}
response time: 10
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"data\": [\n      {\n        \"_id\": \"5a0e8b7949b148371be1f96e\",\n        \"title\": \"fvf\",\n        \"content\": \"fvfv\",\n        \"author\": \"qichangjun\",\n        \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n        \"__v\": 0,\n        \"replyList\": [\n          {\n            \"userName\": \"admin\",\n            \"content\": \"hohoho\",\n            \"_id\": \"5a16847e98682e4e67834b7e\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"hohoho\",\n            \"_id\": \"5a16848198682e4e67834b80\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"hohoho\",\n            \"_id\": \"5a16848398682e4e67834b82\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"1111\",\n            \"_id\": \"5a179235954bda0eb0fb667e\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n          }\n        ],\n        \"label\": [],\n        \"replyNum\": 4,\n        \"viewed\": 21,\n        \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n      },\n      {\n        \"_id\": \"5a1785b3bbb11c04f3f739ea\",\n        \"title\": \"asd\",\n        \"content\": \"sadsads\",\n        \"author\": \"admin\",\n        \"lastReplyTime\": \"2017-11-24T02:36:35.619Z\",\n        \"__v\": 0,\n        \"replyList\": [],\n        \"label\": [\n          \"111\",\n          \"222\"\n        ],\n        \"replyNum\": 0,\n        \"viewed\": 1,\n        \"creatDate\": \"2017-11-24T02:36:35.619Z\"\n      },\n      {\n        \"_id\": \"5a0e8b7f49b148371be1f96f\",\n        \"title\": \"vedvde\",\n        \"content\": \"vdve\",\n        \"author\": \"qichangjun\",\n        \"lastReplyTime\": \"2017-11-23T08:18:03.507Z\",\n        \"__v\": 0,\n        \"replyList\": [\n          {\n            \"userName\": \"qichangjun\",\n            \"content\": \"dd\",\n            \"_id\": \"5a0e8cd449b148371be1f971\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-17T07:16:36.427Z\"\n          },\n          {\n            \"userName\": \"qichangjun\",\n            \"content\": \"ddcc\",\n            \"_id\": \"5a0e8cd849b148371be1f972\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-17T07:16:40.748Z\"\n          },\n          {\n            \"userName\": \"qichangjun\",\n            \"content\": \"ddccxxsa\",\n            \"_id\": \"5a0e8cdb49b148371be1f973\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-17T07:16:43.954Z\"\n          },\n          {\n            \"userName\": \"qichangjun\",\n            \"content\": \"![32f8b3d82fc63.jpg](http://7xpyje.com1.z0.glb.clouddn.com/32f8b3d82fc63.jpg)\",\n            \"_id\": \"5a0e956027648c3bc64a8f77\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-17T07:53:04.705Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"![1edca434719e2.png](http://7xpyje.com1.z0.glb.clouddn.com/1edca434719e2.png?imageView2/1/w/400/h/400/q/75|watermark/2/text/5bCP5LiD5Y2a5a6i/font/5a6L5L2T/fontsize/400/fill/I0RBQ0RDRA==/dissolve/48/gravity/SouthEast/dx/10/dy/10|imageslim)\",\n            \"_id\": \"5a1230b76b9523050f9cff65\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-20T01:32:39.609Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"hahaha\",\n            \"_id\": \"5a16843b98682e4e67834b7c\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-23T08:18:03.507Z\"\n          }\n        ],\n        \"label\": [],\n        \"replyNum\": 6,\n        \"viewed\": 31,\n        \"creatDate\": \"2017-11-17T07:10:55.336Z\"\n      },\n      {\n        \"_id\": \"5a14ddccfcab6103ee8315f8\",\n        \"title\": \"aaaa\",\n        \"content\": \"![0c88904a90297.png](http://7xpyje.com1.z0.glb.clouddn.com/0c88904a90297.png?imageView2/1/w/400/h/400/q/75|watermark/2/text/5bCP5LiD5Y2a5a6i/font/5a6L5L2T/fontsize/400/fill/I0RBQ0RDRA==/dissolve/48/gravity/SouthEast/dx/10/dy/10|imageslim)\",\n        \"author\": \"admin\",\n        \"lastReplyTime\": \"2017-11-23T08:17:45.908Z\",\n        \"__v\": 0,\n        \"replyList\": [\n          {\n            \"userName\": \"admin\",\n            \"content\": \" \\n[aaaa](http://baidu.com)\",\n            \"_id\": \"5a14ef1afcab6103ee8315fb\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-22T03:29:30.148Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"abc\",\n            \"_id\": \"5a1679e2fc7df847971b2c10\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-23T07:33:54.750Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"bdcd\",\n            \"_id\": \"5a167a45b5e32e47bd287713\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-23T07:35:33.273Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"bdea\",\n            \"_id\": \"5a167ac7149269481c27a09d\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-23T07:37:43.576Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"bdba\",\n            \"_id\": \"5a16842998682e4e67834b7b\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-23T08:17:45.908Z\"\n          }\n        ],\n        \"label\": [],\n        \"replyNum\": 5,\n        \"viewed\": 112,\n        \"creatDate\": \"2017-11-22T02:15:40.492Z\"\n      },\n      {\n        \"_id\": \"5a13dd0b2874a8757e13e9ed\",\n        \"title\": \"ghhhh\",\n        \"content\": \"gggerge\",\n        \"author\": \"admin\",\n        \"lastReplyTime\": \"2017-11-21T08:00:11.544Z\",\n        \"__v\": 0,\n        \"replyList\": [],\n        \"label\": [\n          \"angular\"\n        ],\n        \"replyNum\": 0,\n        \"viewed\": 49,\n        \"creatDate\": \"2017-11-21T08:00:11.544Z\"\n      },\n      {\n        \"_id\": \"5a13dcea314c147535a700b7\",\n        \"title\": \"ghhhh\",\n        \"content\": \"gggerge\",\n        \"author\": \"admin\",\n        \"lastReplyTime\": \"2017-11-21T07:59:38.425Z\",\n        \"__v\": 0,\n        \"replyList\": [],\n        \"label\": [\n          \"angular\"\n        ],\n        \"replyNum\": 0,\n        \"viewed\": 1,\n        \"creatDate\": \"2017-11-21T07:59:38.425Z\"\n      },\n      {\n        \"_id\": \"5a13dcca314c147535a700b4\",\n        \"title\": \"测试标签\",\n        \"content\": \"测试标签\",\n        \"author\": \"admin\",\n        \"lastReplyTime\": \"2017-11-21T07:59:06.772Z\",\n        \"__v\": 0,\n        \"replyList\": [],\n        \"label\": [\n          \"angular\",\n          \"javascript\"\n        ],\n        \"replyNum\": 0,\n        \"viewed\": 1,\n        \"creatDate\": \"2017-11-21T07:59:06.772Z\"\n      },\n      {\n        \"_id\": \"5a13dbfb49a16c75252cc059\",\n        \"title\": \"cd\",\n        \"content\": \"cdcd\",\n        \"author\": \"admin\",\n        \"lastReplyTime\": \"2017-11-21T07:55:39.191Z\",\n        \"__v\": 0,\n        \"replyList\": [],\n        \"label\": [\n          \"111\",\n          \"222\"\n        ],\n        \"replyNum\": 0,\n        \"viewed\": 0,\n        \"creatDate\": \"2017-11-21T07:55:39.191Z\"\n      },\n      {\n        \"_id\": \"5a13daee318f07746f106f06\",\n        \"title\": \"测试测试标签\",\n        \"content\": \"sss\",\n        \"author\": \"admin\",\n        \"lastReplyTime\": \"2017-11-21T07:51:10.817Z\",\n        \"__v\": 0,\n        \"replyList\": [],\n        \"label\": [\n          \"angular\",\n          \"javascript\"\n        ],\n        \"replyNum\": 0,\n        \"viewed\": 0,\n        \"creatDate\": \"2017-11-21T07:51:10.817Z\"\n      },\n      {\n        \"_id\": \"5a13da0771bb24738eaa2364\",\n        \"title\": \"hhh\",\n        \"content\": \"hhhh\",\n        \"author\": \"admin\",\n        \"lastReplyTime\": \"2017-11-21T07:47:19.202Z\",\n        \"__v\": 0,\n        \"replyList\": [],\n        \"label\": [\n          \"angular\",\n          \"javascript\"\n        ],\n        \"replyNum\": 0,\n        \"viewed\": 0,\n        \"creatDate\": \"2017-11-21T07:47:19.202Z\"\n      }\n    ],\n    \"totalElement\": 27\n  }\n}"
*************** response log end ***************

[2017-12-01 12:06:36.339] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/label/getLabelLists
request client ip:  ::1
request body: 
{"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxMTk1LCJleHAiOjE1MTIxNDQzOTV9.26_kwPBFVAxJoh5IgfjzaIeml79YcIzG7AdocJv8SRE","keyword":""}
response time: 10
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": [\n    {\n      \"_id\": \"5a13dcca314c147535a700b5\",\n      \"name\": \"angular\",\n      \"__v\": 0,\n      \"number\": 2\n    },\n    {\n      \"_id\": \"5a13dcca314c147535a700b6\",\n      \"name\": \"javascript\",\n      \"__v\": 0,\n      \"number\": 1\n    },\n    {\n      \"_id\": \"5a1785b3bbb11c04f3f739eb\",\n      \"name\": \"111\",\n      \"__v\": 0,\n      \"number\": 1\n    },\n    {\n      \"_id\": \"5a1785b3bbb11c04f3f739ec\",\n      \"name\": \"222\",\n      \"__v\": 0,\n      \"number\": 1\n    }\n  ]\n}"
*************** response log end ***************

[2017-12-01 12:06:37.545] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/art/updateCheckTimes
request client ip:  ::1
request body: 
{"id":"5a0e8b7949b148371be1f96e","token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxMTk1LCJleHAiOjE1MTIxNDQzOTV9.26_kwPBFVAxJoh5IgfjzaIeml79YcIzG7AdocJv8SRE"}
response time: 7
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 22,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:06:37.547] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/art/getArticleDetail?id=5a0e8b7949b148371be1f96e
request client ip:  ::1
request query:  {"id":"5a0e8b7949b148371be1f96e"}
response time: 7
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 22,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:07:36.085] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/users/getUserInfo?userName=admin
request client ip:  ::1
request query:  {"userName":"admin"}
response time: 1
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"回复成功\",\n  \"data\": {\n    \"userName\": \"admin\",\n    \"registerTime\": \"2017-11-23T07:36:51.931Z\",\n    \"message\": []\n  }\n}"
*************** response log end ***************

[2017-12-01 12:07:36.102] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/art/updateCheckTimes
request client ip:  ::1
request body: 
{"id":"5a0e8b7949b148371be1f96e","token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxMTk1LCJleHAiOjE1MTIxNDQzOTV9.26_kwPBFVAxJoh5IgfjzaIeml79YcIzG7AdocJv8SRE"}
response time: 10
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 23,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:07:36.108] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/art/getArticleDetail?id=5a0e8b7949b148371be1f96e
request client ip:  ::1
request query:  {"id":"5a0e8b7949b148371be1f96e"}
response time: 2
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 23,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:07:50.227] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/users/login
request client ip:  ::1
request body: 
{"userName":"admin","password":"2017Dctm@1234"}
response time: 2
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"success\",\n  \"data\": {\n    \"token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxMjcwLCJleHAiOjE1MTIxNDQ0NzB9.g8RAWdNEVse3OnDIg2QekRqUQkHL4ksPVA48PIm2D48\",\n    \"userName\": \"admin\",\n    \"role\": \"normal\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:07:50.277] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/users/getUserInfo?userName=admin
request client ip:  ::1
request query:  {"userName":"admin"}
response time: 4
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"回复成功\",\n  \"data\": {\n    \"userName\": \"admin\",\n    \"registerTime\": \"2017-11-23T07:36:51.931Z\",\n    \"message\": []\n  }\n}"
*************** response log end ***************

[2017-12-01 12:07:50.289] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/art/getArticleLists
request client ip:  ::1
request body: 
{"currentPage":1,"pageSize":10,"sortField":"lastReplyTime","totalElement":1,"labels":[],"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxMjcwLCJleHAiOjE1MTIxNDQ0NzB9.g8RAWdNEVse3OnDIg2QekRqUQkHL4ksPVA48PIm2D48"}
response time: 9
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"data\": [\n      {\n        \"_id\": \"5a0e8b7949b148371be1f96e\",\n        \"title\": \"fvf\",\n        \"content\": \"fvfv\",\n        \"author\": \"qichangjun\",\n        \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n        \"__v\": 0,\n        \"replyList\": [\n          {\n            \"userName\": \"admin\",\n            \"content\": \"hohoho\",\n            \"_id\": \"5a16847e98682e4e67834b7e\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"hohoho\",\n            \"_id\": \"5a16848198682e4e67834b80\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"hohoho\",\n            \"_id\": \"5a16848398682e4e67834b82\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"1111\",\n            \"_id\": \"5a179235954bda0eb0fb667e\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n          }\n        ],\n        \"label\": [],\n        \"replyNum\": 4,\n        \"viewed\": 23,\n        \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n      },\n      {\n        \"_id\": \"5a1785b3bbb11c04f3f739ea\",\n        \"title\": \"asd\",\n        \"content\": \"sadsads\",\n        \"author\": \"admin\",\n        \"lastReplyTime\": \"2017-11-24T02:36:35.619Z\",\n        \"__v\": 0,\n        \"replyList\": [],\n        \"label\": [\n          \"111\",\n          \"222\"\n        ],\n        \"replyNum\": 0,\n        \"viewed\": 1,\n        \"creatDate\": \"2017-11-24T02:36:35.619Z\"\n      },\n      {\n        \"_id\": \"5a0e8b7f49b148371be1f96f\",\n        \"title\": \"vedvde\",\n        \"content\": \"vdve\",\n        \"author\": \"qichangjun\",\n        \"lastReplyTime\": \"2017-11-23T08:18:03.507Z\",\n        \"__v\": 0,\n        \"replyList\": [\n          {\n            \"userName\": \"qichangjun\",\n            \"content\": \"dd\",\n            \"_id\": \"5a0e8cd449b148371be1f971\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-17T07:16:36.427Z\"\n          },\n          {\n            \"userName\": \"qichangjun\",\n            \"content\": \"ddcc\",\n            \"_id\": \"5a0e8cd849b148371be1f972\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-17T07:16:40.748Z\"\n          },\n          {\n            \"userName\": \"qichangjun\",\n            \"content\": \"ddccxxsa\",\n            \"_id\": \"5a0e8cdb49b148371be1f973\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-17T07:16:43.954Z\"\n          },\n          {\n            \"userName\": \"qichangjun\",\n            \"content\": \"![32f8b3d82fc63.jpg](http://7xpyje.com1.z0.glb.clouddn.com/32f8b3d82fc63.jpg)\",\n            \"_id\": \"5a0e956027648c3bc64a8f77\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-17T07:53:04.705Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"![1edca434719e2.png](http://7xpyje.com1.z0.glb.clouddn.com/1edca434719e2.png?imageView2/1/w/400/h/400/q/75|watermark/2/text/5bCP5LiD5Y2a5a6i/font/5a6L5L2T/fontsize/400/fill/I0RBQ0RDRA==/dissolve/48/gravity/SouthEast/dx/10/dy/10|imageslim)\",\n            \"_id\": \"5a1230b76b9523050f9cff65\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-20T01:32:39.609Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"hahaha\",\n            \"_id\": \"5a16843b98682e4e67834b7c\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-23T08:18:03.507Z\"\n          }\n        ],\n        \"label\": [],\n        \"replyNum\": 6,\n        \"viewed\": 31,\n        \"creatDate\": \"2017-11-17T07:10:55.336Z\"\n      },\n      {\n        \"_id\": \"5a14ddccfcab6103ee8315f8\",\n        \"title\": \"aaaa\",\n        \"content\": \"![0c88904a90297.png](http://7xpyje.com1.z0.glb.clouddn.com/0c88904a90297.png?imageView2/1/w/400/h/400/q/75|watermark/2/text/5bCP5LiD5Y2a5a6i/font/5a6L5L2T/fontsize/400/fill/I0RBQ0RDRA==/dissolve/48/gravity/SouthEast/dx/10/dy/10|imageslim)\",\n        \"author\": \"admin\",\n        \"lastReplyTime\": \"2017-11-23T08:17:45.908Z\",\n        \"__v\": 0,\n        \"replyList\": [\n          {\n            \"userName\": \"admin\",\n            \"content\": \" \\n[aaaa](http://baidu.com)\",\n            \"_id\": \"5a14ef1afcab6103ee8315fb\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-22T03:29:30.148Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"abc\",\n            \"_id\": \"5a1679e2fc7df847971b2c10\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-23T07:33:54.750Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"bdcd\",\n            \"_id\": \"5a167a45b5e32e47bd287713\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-23T07:35:33.273Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"bdea\",\n            \"_id\": \"5a167ac7149269481c27a09d\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-23T07:37:43.576Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"bdba\",\n            \"_id\": \"5a16842998682e4e67834b7b\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-23T08:17:45.908Z\"\n          }\n        ],\n        \"label\": [],\n        \"replyNum\": 5,\n        \"viewed\": 112,\n        \"creatDate\": \"2017-11-22T02:15:40.492Z\"\n      },\n      {\n        \"_id\": \"5a13dd0b2874a8757e13e9ed\",\n        \"title\": \"ghhhh\",\n        \"content\": \"gggerge\",\n        \"author\": \"admin\",\n        \"lastReplyTime\": \"2017-11-21T08:00:11.544Z\",\n        \"__v\": 0,\n        \"replyList\": [],\n        \"label\": [\n          \"angular\"\n        ],\n        \"replyNum\": 0,\n        \"viewed\": 49,\n        \"creatDate\": \"2017-11-21T08:00:11.544Z\"\n      },\n      {\n        \"_id\": \"5a13dcea314c147535a700b7\",\n        \"title\": \"ghhhh\",\n        \"content\": \"gggerge\",\n        \"author\": \"admin\",\n        \"lastReplyTime\": \"2017-11-21T07:59:38.425Z\",\n        \"__v\": 0,\n        \"replyList\": [],\n        \"label\": [\n          \"angular\"\n        ],\n        \"replyNum\": 0,\n        \"viewed\": 1,\n        \"creatDate\": \"2017-11-21T07:59:38.425Z\"\n      },\n      {\n        \"_id\": \"5a13dcca314c147535a700b4\",\n        \"title\": \"测试标签\",\n        \"content\": \"测试标签\",\n        \"author\": \"admin\",\n        \"lastReplyTime\": \"2017-11-21T07:59:06.772Z\",\n        \"__v\": 0,\n        \"replyList\": [],\n        \"label\": [\n          \"angular\",\n          \"javascript\"\n        ],\n        \"replyNum\": 0,\n        \"viewed\": 1,\n        \"creatDate\": \"2017-11-21T07:59:06.772Z\"\n      },\n      {\n        \"_id\": \"5a13dbfb49a16c75252cc059\",\n        \"title\": \"cd\",\n        \"content\": \"cdcd\",\n        \"author\": \"admin\",\n        \"lastReplyTime\": \"2017-11-21T07:55:39.191Z\",\n        \"__v\": 0,\n        \"replyList\": [],\n        \"label\": [\n          \"111\",\n          \"222\"\n        ],\n        \"replyNum\": 0,\n        \"viewed\": 0,\n        \"creatDate\": \"2017-11-21T07:55:39.191Z\"\n      },\n      {\n        \"_id\": \"5a13daee318f07746f106f06\",\n        \"title\": \"测试测试标签\",\n        \"content\": \"sss\",\n        \"author\": \"admin\",\n        \"lastReplyTime\": \"2017-11-21T07:51:10.817Z\",\n        \"__v\": 0,\n        \"replyList\": [],\n        \"label\": [\n          \"angular\",\n          \"javascript\"\n        ],\n        \"replyNum\": 0,\n        \"viewed\": 0,\n        \"creatDate\": \"2017-11-21T07:51:10.817Z\"\n      },\n      {\n        \"_id\": \"5a13da0771bb24738eaa2364\",\n        \"title\": \"hhh\",\n        \"content\": \"hhhh\",\n        \"author\": \"admin\",\n        \"lastReplyTime\": \"2017-11-21T07:47:19.202Z\",\n        \"__v\": 0,\n        \"replyList\": [],\n        \"label\": [\n          \"angular\",\n          \"javascript\"\n        ],\n        \"replyNum\": 0,\n        \"viewed\": 0,\n        \"creatDate\": \"2017-11-21T07:47:19.202Z\"\n      }\n    ],\n    \"totalElement\": 27\n  }\n}"
*************** response log end ***************

[2017-12-01 12:07:50.292] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/label/getLabelLists
request client ip:  ::1
request body: 
{"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxMjcwLCJleHAiOjE1MTIxNDQ0NzB9.g8RAWdNEVse3OnDIg2QekRqUQkHL4ksPVA48PIm2D48","keyword":""}
response time: 9
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": [\n    {\n      \"_id\": \"5a13dcca314c147535a700b5\",\n      \"name\": \"angular\",\n      \"__v\": 0,\n      \"number\": 2\n    },\n    {\n      \"_id\": \"5a13dcca314c147535a700b6\",\n      \"name\": \"javascript\",\n      \"__v\": 0,\n      \"number\": 1\n    },\n    {\n      \"_id\": \"5a1785b3bbb11c04f3f739eb\",\n      \"name\": \"111\",\n      \"__v\": 0,\n      \"number\": 1\n    },\n    {\n      \"_id\": \"5a1785b3bbb11c04f3f739ec\",\n      \"name\": \"222\",\n      \"__v\": 0,\n      \"number\": 1\n    }\n  ]\n}"
*************** response log end ***************

[2017-12-01 12:07:51.676] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/art/updateCheckTimes
request client ip:  ::1
request body: 
{"id":"5a0e8b7949b148371be1f96e","token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxMjcwLCJleHAiOjE1MTIxNDQ0NzB9.g8RAWdNEVse3OnDIg2QekRqUQkHL4ksPVA48PIm2D48"}
response time: 5
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 24,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:07:51.679] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/art/getArticleDetail?id=5a0e8b7949b148371be1f96e
request client ip:  ::1
request query:  {"id":"5a0e8b7949b148371be1f96e"}
response time: 3
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 24,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:08:07.041] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/users/getUserInfo?userName=admin
request client ip:  ::1
request query:  {"userName":"admin"}
response time: 1
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"回复成功\",\n  \"data\": {\n    \"userName\": \"admin\",\n    \"registerTime\": \"2017-11-23T07:36:51.931Z\",\n    \"message\": []\n  }\n}"
*************** response log end ***************

[2017-12-01 12:08:07.052] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/art/updateCheckTimes
request client ip:  ::1
request body: 
{"id":"5a0e8b7949b148371be1f96e","token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxMjcwLCJleHAiOjE1MTIxNDQ0NzB9.g8RAWdNEVse3OnDIg2QekRqUQkHL4ksPVA48PIm2D48"}
response time: 4
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 25,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:08:07.055] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/art/getArticleDetail?id=5a0e8b7949b148371be1f96e
request client ip:  ::1
request query:  {"id":"5a0e8b7949b148371be1f96e"}
response time: 4
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 25,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:08:46.802] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/upload/getMdFileContent
request client ip:  ::1
request body: 
{}
response time: 361
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"解析成功\",\n  \"data\": \"# Asynchronous Control Flow Patterns with Callbacks\\n`Node.js`这类语言习惯于同步的编程风格，其`CPS`风格和异步特性的`API`是其标准，对于新手来说可能难以理解。编写异步代码可能是一种不同的体验，尤其是对异步控制流而言。异步代码可能让我们难以预测在`Node.js`中执行语句的顺序。例如读取一组文件，执行一串任务，或者等待一组操作完成，都需要开发人员采用新的方法和技术，以避免最终编写出效率低下和不可维护的代码。一个常见的错误是回调地狱，代码量急剧上升又不可读，使得简单的程序也难以阅读和维护。在本章中，我们将看到如何通过使用一些规则和一些模式来避免回调，并编写干净、可管理的异步代码。我们将看到控制流库，如`async`，可以极大地简化我们的问题，提升我们的代码可读性，更易于维护。\\n\\n## 异步编程的困难\\n`JavaScript`中异步代码的顺序错乱无疑是很容易的。闭包和对匿名函数的定义可以使开发人员有更好的编程体验，而并不需要开发人员手动对异步操作进行管理和跳转。这是符合`KISS`原则的。简单且能保持异步代码控制流，让它在更短的时间内工作。但不幸的是，回调嵌套是以牺牲诸如模块性、可重用性和可维护性，增大整个函数的大小，导致糟糕的代码结构为代价的。大多数情况下，创建闭包在功能上是不需要的，但这更多是一种约束，而不是与异步编程相关的问题。认识到回调嵌套会使得我们的代码变得笨拙，然后根据最适合的解决方案采取相应的方法解决回调地狱，这是新手与专家的区别。\\n\\n### 创建一个简单的Web爬虫\\n为了解释上述问题，我们创建了一个简单的Web爬虫，一个命令行应用，其接受一个`URL`为输入，然后可以把其内容下载到一个文件中。在下列代码中，我们会依赖以下两个`npm`库。\\n\\n此外，我们还将引用一个叫做`./utilities`的本地模块。\\n\\n我们的应用程序的核心功能包含在一个名为`spider.js`的模块中。如下所示，首先加载我们所需要的依赖包：\\n\\n```javascript\\nconst request = require('request');\\nconst fs = require('fs');\\nconst mkdirp = require('mkdirp');\\nconst path = require('path');\\nconst utilities = require('./utilities');\\n```\\n\\n接下来，我们将创建一个名为`spider()`的新函数，该函数接受`URL`为参数，并在下载过程完成时调用一个回调函数。\\n\\n```javascript\\nfunction spider(url, callback) {\\n  const filename = utilities.urlToFilename(url);\\n  fs.exists(filename, exists => {\\n    if (!exists) {\\n      console.log(`Downloading ${url}`);\\n      request(url, (err, response, body) => {\\n        if (err) {\\n          callback(err);\\n        } else {\\n          mkdirp(path.dirname(filename), err => {\\n            if (err) {\\n              callback(err);\\n            } else {\\n              fs.writeFile(filename, body, err => {\\n                if (err) {\\n                  callback(err);\\n                } else {\\n                  callback(null, filename, true);\\n                }\\n              });\\n            }\\n          });\\n        }\\n      });\\n    } else {\\n      callback(null, filename, false);\\n    }\\n  });\\n}\\n```\\n\\n上述函数执行以下任务：\\n\\n* 检查该`URL`的文件是否已经下载过，即验证相应文件是否已经被创建：\\n\\n`fs.exists(filename, exists => ...`\\n\\n* 如果文件还没有被下载，则执行下列代码进行下载操作：\\n\\n`request(url, (err, response, body) => ...`\\n\\n* 然后，我们需要确定目录下是否已经包含了该文件：\\n\\n`mkdirp(path.dirname(filename), err => ...`\\n\\n* 最后，我们把`HTTP`请求返回的报文主体写入文件系统：\\n\\n`mkdirp(path.dirname(filename), err => ...`\\n\\n要完成我们的`Web爬虫`应用程序，只需提供一个`URL`作为输入(在我们的例子中，我们从命令行参数中读取它)，我们只需调用`spider()`函数即可。\\n\\n```javascript\\nspider(process.argv[2], (err, filename, downloaded) => {\\n  if (err) {\\n    console.log(err);\\n  } else if (downloaded) {\\n    console.log(`Completed the download of \\\"${filename}\\\"`);\\n  } else {\\n    console.log(`\\\"${filename}\\\" was already downloaded`);\\n  }\\n});\\n```\\n\\n现在，我们开始尝试运行`Web爬虫`应用程序，但是首先，确保已有`utilities.js`模块和`package.json`中的所有依赖包已经安装到你的项目中：\\n\\n```bash\\nnpm install\\n```\\n\\n之后，我们执行我们这个爬虫模块来下载一个网页，使用以下命令：\\n\\n```bash\\nnode spider http://www.example.com\\n```\\n\\n我们的`Web爬虫`应用程序要求在我们提供的`URL`中总是包含协议类型(例如，`http://`)。另外，不要期望`HTML`链接被重新编写，也不要期望下载像图片这样的资源，因为这只是一个简单的例子来演示异步编程是如何工作的。\\n\\n![](http://oczira72b.bkt.clouddn.com/17-10-11/6194673.jpg)\\n\\n### 回调地狱\\n看看我们的`spider()`函数，我们可以发现，尽管我们实现的算法非常简单，但是生成的代码有几个级别的缩进，而且很难读懂。使用阻塞式的同步`API`实现类似的功能是很简单的，而且很少有机会让它看起来如此错误。然而，使用异步`CPS`是另一回事，使用闭包可能会导致出现难以阅读的代码。\\n\\n大量闭包和回调将代码转换成不可读的、难以管理的情况称为回调地狱。它是`Node.js`中最受认可和最严重的反模式之一。一般来说，对于`JavaScript`而言。受此问题影响的代码的典型结构如下:\\n\\n```javascript\\nasyncFoo(err => {\\n  asyncBar(err => {\\n    asyncFooBar(err => {\\n      //...\\n    });\\n  });\\n});\\n```\\n\\n我们可以看到，用这种方式编写的代码是如何形成金字塔形状的，由于深嵌的原因导致的难以阅读，称为“末日金字塔”。\\n\\n像前面的代码片段这样的代码最明显的问题是可读性差。由于嵌套太深，几乎不可能跟踪回调函数的结束位置和另一个回调函数开始的位置。\\n\\n另一个问题是由每个作用域中使用的变量名的重叠引起的。通常，我们必须使用类似甚至相同的名称来描述变量的内容。最好的例子是每个回调接收到的错误参数。有些人经常尝试使用相同名称的变体来区分每个范围内的对象，例如，`error`、`err`、`err1`、`err2`等等。另一些人则倾向于隐藏在范围中定义的变量，总是使用相同的名称。例如，`err`。这两种选择都远非完美，而且会造成混淆，并增加导致`bug`的可能性。\\n\\n此外，我们必须记住，虽然闭包在性能和内存消耗方面的代价很小。此外，它们还可以创建不易识别的内存泄漏，因为我们不应该忘记，由闭包引用的任何上下文变量都不会被垃圾收集所保留。\\n\\n关于对于`V8`的闭包工作原理，可以参考[Vyacheslav Egorov的博客文章](http://mrale.ph/blog/2012/09/23/grokking-v8-closures-for-fun.html)。\\n\\n如果我们看一下我们的`spider()`函数，我们会清楚地注意到它便是一个典型的回调地狱的场景，并且在这个函数中有我们刚才描述的所有问题。这正是我们将在本章中学习的模式和技巧所要解决的问题。\\n\\n## 使用简单的JavaScript\\n既然我们已经遇到了第一个回调地狱的例子，我们知道我们应该避免什么。然而，在编写异步代码时，这并不是惟一的关注点。事实上，有几种情况下，控制一组异步任务的流需要使用特定的模式和技术，特别是如果我们只使用普通的`JavaScript`而没有任何外部库的帮助的情况下。例如，通过按顺序应用异步操作来遍历集合并不像在数组中调用`forEach()`那样简单，但实际上它需要一种类似于递归的技术。\\n\\n在本节中，我们将学习如何避免回调地狱，以及如何使用简单的`JavaScript`实现一些最常见的控制流模式。\\n\\n### 回调函数的准则\\n在编写异步代码时，要记住的第一个规则是在定义回调时不要滥用闭包。滥用闭包一时很爽，因为它不需要对诸如模块化和可重用性这样的问题进行额外的思考。但是，我们已经看到，这种做法弊大于利。大多数情况下，修复回调地狱问题并不需要任何库、花哨的技术或范式的改变，只是一些常识。\\n\\n以下是一些基本原则，可以帮助我们更少的嵌套，并改进我们的代码的组织：\\n\\n* 尽可能退出外层函数。根据上下文，使用`return`、`continue`或`break`，以便立即退出当前代码块，而不是使用`if...else`代码块。其他语句。这将有助于优化我们的代码结构。\\n* 为回调创建命名函数，避免使用闭包，并将中间结果作为参数传递。命名函数也会使它们在堆栈跟踪中更优雅。\\n* 代码尽可能模块化。并尽可能将代码分成更小的、可重用的函数。\\n\\n### 回调调用的准则\\n为了展示上述原则，我们通过重构`Web爬虫`应用程序来说明。\\n\\n对于第一步，我们可以通过删除`else`语句来重构我们的错误检查方式。这是在我们收到错误后立即从函数中返回。因此，看以下代码：\\n\\n```javascript\\nif (err) {\\n  callback(err);\\n} else {\\n  // 如果没有错误，执行该代码块\\n}\\n```\\n\\n我们可以通过编写下面的代码来改进我们的代码结构：\\n\\n```javascript\\nif (err) {\\n  return callback(err);\\n}\\n// 如果没有错误，执行该代码块\\n```\\n\\n有了这个简单的技巧，我们立即减少了函数的嵌套级别，它很简单，不需要任何复杂的重构。\\n\\n在执行我们刚才描述的优化时，一个常见的错误是在调用回调函数之后忘记终止函数，即`return`。对于错误处理场景，以下代码是`bug`的典型来源：\\n\\n```javascript\\nif (err) {\\n  callback(err);\\n}\\n// 如果没有错误，执行该代码块\\n```\\n\\n在这个例子中，即使在调用回调之后，函数的执行也会继续。那么避免这种情况的出现，`return`语句是十分必要的。还要注意，函数返回的输出是什么并不重要，实际结果(或错误)是异步生成的，并传递给回调。异步函数的返回值通常被忽略。该属性允许我们编写如下的代码：\\n\\n```javascript\\nreturn callback(...);\\n```\\n\\n否则我们必须拆成两条语句来写：\\n\\n```javascript\\ncallback(...);\\nreturn;\\n```\\n\\n接下来我们继续重构我们的`spider()`函数，我们可以尝试识别可复用的代码片段。例如，将给定字符串写入文件的功能可以很容易地分解为一个单独的函数：\\n\\n```javascript\\nfunction saveFile(filename, contents, callback) {\\n  mkdirp(path.dirname(filename), err => {\\n    if (err) {\\n      return callback(err);\\n    }\\n    fs.writeFile(filename, contents, callback);\\n  });\\n}\\n```\\n\\n遵循同样的原则，我们可以创建一个名为`download()`的通用函数，它将`URL`和`文件名`作为输入，并将`URL`的内容下载到给定的文件中。在内部，我们可以使用前面创建的`saveFile()`函数。\\n\\n```javascript\\nfunction download(url, filename, callback) {\\n  console.log(`Downloading ${url}`);\\n  request(url, (err, response, body) => {\\n    if (err) {\\n      return callback(err);\\n    }\\n    saveFile(filename, body, err => {\\n      if (err) {\\n        return callback(err);\\n      }\\n      console.log(`Downloaded and saved: ${url}`);\\n      callback(null, body);\\n    });\\n  });\\n}\\n```\\n\\n最后，修改我们的`spider()`函数：\\n\\n```javascript\\nfunction spider(url, callback) {\\n  const filename = utilities.urlToFilename(url);\\n  fs.exists(filename, exists => {\\n    if (exists) {\\n      return callback(null, filename, false);\\n    }\\n    download(url, filename, err => {\\n      if (err) {\\n        return callback(err);\\n      }\\n      callback(null, filename, true);\\n    })\\n  });\\n}\\n```\\n\\n`spider()`函数的功能和接口仍然是完全相同的，改变的仅仅是代码的组织方式。通过应用上述基本原则，我们能够极大地减少代码的嵌套，同时增加了它的可重用性和可测试性。实际上，我们可以考虑导出`saveFile()`和`download()`，这样我们就可以在其他模块中重用它们。这也使我们能够更容易地测试他们的功能。\\n\\n我们在这一节中进行的重构清楚地表明，大多数时候，我们所需要的只是一些规则，并确保我们不滥用闭包和匿名函数。它的工作非常出色，只需最少的工作量，并且只使用原始的`JavaScript`。\\n\\n### 顺序执行\\n现在开始探寻异步控制流的执行顺序，我们会通过开始分析一串异步代码来探寻其控制流。\\n\\n按顺序执行一组任务意味着一次一个接一个地运行它们。执行顺序很重要，必须保证其正确性，因为列表中一个任务的结果可能会影响下一个任务的执行。下图说明了这个概念：\\n\\n![](http://oczira72b.bkt.clouddn.com/17-10-14/39602217.jpg)\\n\\n上述异步控制流有一些不同的变化：\\n\\n* 按顺序执行一组已知任务，无需链接或传递执行结果\\n* 使用任务的输出作为下一个输入（也称为`chain`，`pipeline`，或者`waterfall`）\\n* 在每个元素上运行异步任务时迭代一个集合，一个元素接一个元素\\n\\n对于顺序执行而言，尽管在使用直接样式阻塞`API`实现很简单，但通常情况下使用`异步CPS`时会导致回调地狱问题。\\n\\n#### 按顺序执行一组已知的任务\\n在上一节中实现`spider()`函数时，我们已经遇到了顺序执行的问题。通过研究如下方式，我们可以更好地控制异步代码。以该代码为准则，我们可以用以下模式来解决上述问题：\\n\\n```javascript\\nfunction task1(callback) {\\n  asyncOperation(() => {\\n    task2(callback);\\n  });\\n}\\n\\nfunction task2(callback) {\\n  asyncOperation(result() => {\\n    task3(callback);\\n  });\\n}\\n\\nfunction task3(callback) {\\n  asyncOperation(() => {\\n    callback(); //finally executes the callback\\n  });\\n}\\n\\ntask1(() => {\\n  //executed when task1, task2 and task3 are completed\\n  console.log('tasks 1, 2 and 3 executed');\\n});\\n```\\n\\n上述模式显示了在完成一个异步操作后，再调用下一个异步操作。该模式强调任务的模块化，并且避免在处理异步代码使用闭包。\\n\\n#### 顺序迭代\\n我们前面描述的模式如果我们预先知道要执行什么和有多少个任务，这些模式是完美的。这使我们能够对序列中下一个任务的调用进行硬编码，但是如果要对集合中的每个项目执行异步操作，会发生什么？在这种情况下，我们不能对任务序列进行硬编码。相反的是，我们必须动态构建它。\\n\\n##### Web爬虫版本2\\n为了显示顺序迭代的例子，让我们为`Web爬虫`应用程序引入一个新功能。我们现在想要递归地下载网页中的所有链接。要做到这一点，我们将从页面中提取所有链接，然后按顺序逐个地触发我们的`Web爬虫`应用程序。\\n\\n第一步是修改我们的`spider()`函数，以便通过调用一个名为`spiderLinks()`的函数触发页面所有链接的递归下载。\\n\\n此外，我们现在尝试读取文件，而不是检查文件是否已经存在，并开始爬取其链接。这样，我们就可以恢复中断的下载。最后还有一个变化是，我们确保我们传递的参数是最新的，还要限制递归深度。结果代码如下：\\n\\n```javascript\\nfunction spider(url, nesting, callback) {\\n  const filename = utilities.urlToFilename(url);\\n  fs.readFile(filename, 'utf8', (err, body) => {\\n    if (err) {\\n      if (err.code! == 'ENOENT') {\\n        return callback(err);\\n      }\\n      return download(url, filename, (err, body) => {\\n        if (err) {\\n          return callback(err);\\n        }\\n        spiderLinks(url, body, nesting, callback);\\n      });\\n    }\\n    spiderLinks(url, body, nesting, callback);\\n  });\\n}\\n```\\n\\n##### 爬取链接\\n现在我们可以创建这个新版本的`Web爬虫`应用程序的核心，即`spiderLinks()`函数，它使用顺序异步迭代算法下载`HTML`页面的所有链接。注意我们在下面的代码块中定义的方式：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting, callback) {\\n  if(nesting === 0) {\\n    return process.nextTick(callback);\\n  }\\n\\n  let links = utilities.getPageLinks(currentUrl, body); //[1]\\n  function iterate(index) { //[2]\\n    if(index === links.length) {\\n      return callback();\\n    }\\n\\n    spider(links[index], nesting - 1, function(err) { //[3]\\n      if(err) {\\n        return callback(err);\\n      }\\n      iterate(index + 1);\\n    });\\n  }\\n  iterate(0); //[4]\\n}\\n```\\n\\n从这个新功能中的重要步骤如下：\\n\\n1. 我们使用`utilities.getPageLinks()`函数获取页面中包含的所有链接的列表。此函数仅返回指向相同主机名的链接。\\n2. 我们使用一个称为`iterate()`的本地函数来遍历链接，该函数需要下一个链接的索引进行分析。在这个函数中，我们首先要检查索引是否等于链接数组的长度，如果等于则是迭代完成，在这种情况下我们立即调用`callback()`函数，因为这意味着我们处理了所有的项目。\\n3. 这时，处理链接已准备就绪。我们通过递归调用`spider()`函数。\\n4. 作为`spiderLinks()`函数的最后一步也是最重要的一步，我们通过调用`iterate(0)`来开始迭代。\\n\\n\\n我们刚刚提出的算法允许我们通过顺序执行异步操作来迭代数组，在我们的例子中是`spider()`函数。\\n\\n我们现在可以尝试这个新版本的`Web爬虫`应用程序，并观看它一个接一个地递归地下载网页的所有链接。要中断这个过程，如果有很多链接可能需要一段时间，请记住我们可以随时使用`Ctrl + C`。如果我们决定恢复它，我们可以通过启动`Web爬虫`应用程序并提供与上次结束时相同的`URL`来恢复执行。\\n\\n现在我们的网络`Web爬虫`应用程序可能会触发整个网站的下载，请仔细考虑使用它。例如，不要设置高嵌套级别或离开爬虫运行超过几秒钟。用数千个请求重载服务器是不道德的。在某些情况下，这也被认为是非法的。需要考虑后果！\\n\\n##### 迭代模式\\n我们之前展示的`spiderLinks()`函数的代码是一个清楚的例子，说明了如何在应用异步操作时迭代集合。我们还可以注意到，这是一种可以适应任何其他情况的模式，我们需要在集合的元素或通常的任务列表上按顺序异步迭代。该模式可以推广如下：\\n\\n```javascript\\nfunction iterate(index) {\\n  if (index === tasks.length) {\\n    return finish();\\n  }\\n  const task = tasks[index];\\n  task(function() {\\n    iterate(index + 1);\\n  });\\n}\\n\\nfunction finish() {\\n  // 迭代完成的操作\\n}\\n\\niterate(0);\\n```\\n\\n注意到，如果`task()`是同步操作，这些类型的算法变得真正递归。在这种情况下，可能造成调用栈的溢出。\\n\\n我们刚刚提出的模式是非常强大的，因为它可以适应几种情况。例如，我们可以映射数组的值，或者我们可以将迭代的结果传递给迭代中的下一个，以实现一个reduce算法，如果满足特定的条件，我们可以提前退出循环，或者甚至可以迭代无限数量的元素。\\n\\n我们还可以选择将解决方案进一步推广：\\n\\n```javascript\\niterateSeries(collection, iteratorCallback, finalCallback);\\n```\\n\\n通过创建一个名为`iterator`的函数来执行任务列表，该函数调用集合中的下一个可执行的任务，并确保在当前任务完成时调用迭代器结束的回调函数。\\n\\n### 并行\\n在某些情况下，一组异步任务的执行顺序并不重要，我们只需要在所有这些运行的任务完成时通知我们。使用并行执行流更好地处理这种情况，如下图所示：\\n\\n![](http://oczira72b.bkt.clouddn.com/17-10-14/18606236.jpg)\\n\\n如果我们认为`Node.js`是单线程的话，这可能听起来很奇怪，但是如果我们记住我们在第一章中讨论过的内容，我们意识到即使我们只有一个线程，我们仍然可以实现并发，由于`Node.js`的非阻塞性质。实际上，在这种情况下，并行字不正确地使用，因为这并不意味着任务同时运行，而是它们的执行由底层的非阻塞`API`执行，并由事件循环进行交织。\\n\\n我们知道，当一个任务允许事件循环执行另一个任务时，或者是说一个任务允许控制回到事件循环。这种工作流的名称为并发，但为了简单起见，我们仍然会使用并行。\\n\\n下图显示了两个异步任务可以在`Node.js`程序中并行运行：\\n\\n![](http://oczira72b.bkt.clouddn.com/17-10-14/11401894.jpg)\\n\\n通过上图，我们有一个`Main`函数执行两个异步任务：\\n\\n1. `Main`函数触发`Task 1`和`Task 2`的执行。由于这些触发异步操作，这两个函数会立即返回，并将控制权返还给主函数，之后等到事件循环完成再通知主线程。\\n2. 当`Task 1`的异步操作完成时，事件循环给与其线程控制权。当`Task 1`同步操作完成时，它通知`Main`函数。\\n3. 当`Task 2`的异步操作完成时，事件循环给与其线程控制权。当`Task 2`同步操作完成时，它再次通知`Main`函数。在这一点上，`Main`函数知晓`Task 1`和`Task 2`都已经执行完毕，所以它可以继续执行其后操作或将操作的结果返回给另一个回调函数。\\n\\n简而言之，这意味着在`Node.js`中，我们只能执行并行异步操作，因为它们的并发性由非阻塞`API`在内部处理。在`Node.js`中，同步阻塞操作不能同时运行，除非它们的执行与异步操作交错，或者通过`setTimeout()`或`setImmediate()`延迟。我们将在第九章中更详细地看到这一点。\\n\\n### Web爬虫版本3\\n\\n上边的`Web爬虫`在并行异步操作上似乎也算表现得很完美。到目前为止，应用程序正在递归地执行链接页面的下载。但性能不是最佳的，想要提升这个应用的性能很容易。\\n\\n要做到这一点，我们只需要修改`spiderLinks()`函数，确保`spider()`任务只执行一次，当所有任务都执行完毕后，调用最后的回调，所以我们对`spiderLinks()`做如下修改：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting, callback) {\\n  if (nesting === 0) {\\n    return process.nextTick(callback);\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  if (links.length === 0) {\\n    return process.nextTick(callback);\\n  }\\n  let completed = 0,\\n    hasErrors = false;\\n\\n  function done(err) {\\n    if (err) {\\n      hasErrors = true;\\n      return callback(err);\\n    }\\n    if (++completed === links.length && !hasErrors) {\\n      return callback();\\n    }\\n  }\\n  links.forEach(link => {\\n    spider(link, nesting - 1, done);\\n  });\\n}\\n```\\n\\n上述代码有何变化？，现在`spider()`函数的任务全部同步启动。可以通过简单地遍历链接数组和启动每个任务，我们不必等待前一个任务完成再进行下一个任务：\\n\\n```javascript\\nlinks.forEach(link => {\\n  spider(link, nesting - 1, done);\\n});\\n```\\n\\n然后，使我们的应用程序知晓所有任务完成的方法是为`spider()`函数提供一个特殊的回调函数，我们称之为`done()`。当爬虫任务完成时，`done()`函数设定一个计数器。当完成的下载次数达到链接数组的大小时，调用最终回调：\\n\\n```javascript\\nfunction done(err) {\\n  if (err) {\\n    hasErrors = true;\\n    return callback(err);\\n  }\\n  if (++completed === links.length && !hasErrors) {\\n    callback();\\n  }\\n}\\n```\\n\\n通过上述变化，如果我们现在试图对网页运行我们的爬虫，我们将注意到整个过程的速度有很大的改进，因为每次下载都是并行执行的，而不必等待之前的链接被处理。\\n\\n### 模式\\n此外，对于并行执行流程，我们可以提取我们方案，以便适应于不同的情况提高代码的可复用性。我们可以使用以下代码来表示模式的通用版本：\\n\\n```javascript\\nconst tasks = [ /* ... */ ];\\nlet completed = 0;\\ntasks.forEach(task => {\\n  task(() => {\\n    if (++completed === tasks.length) {\\n      finish();\\n    }\\n  });\\n});\\n\\nfunction finish() {\\n  // 所有任务执行完成后调用\\n}\\n```\\n\\n通过小的修改，我们可以调整模式，将每个任务的结果累积到一个`list`中，以便过滤或映射数组的元素，或者一旦完成了一个或一定数量的任务即可调用`finish()`回调。\\n\\n> 注意：如果是没有限制的情况下，并行执行的一组异步任务，然后等待所有异步任务完成后执行回调这种方式，其方法是计算它们的执行完成的数目。\\n\\n## 用并发任务修复竞争条件\\n当使用`阻塞I/O`与多线程组合的方式时，并行运行一组任务可能会导致一些问题。但是，我们刚刚看到，在`Node.js`中却不一样，并行运行多个异步任务实际上在资源方面消耗较低。这是`Node.js`最重要的优点之一，因此在`Node.js`中并行化成为一种常见的做法，而且这并是多么复杂的技术。\\n\\n`Node.js`的并发模型的另一个重要特征是我们处理任务同步和竞争条件的方式。在多线程编程中，这通常使用诸如锁，互斥条件，信号量和观察器之类的构造来实现，这些是多线程语言并行化的最复杂的方面之一，对性能也有很大的影响。在`Node.js`中，我们通常不需要一个花哨的同步机制，因为所有运行在单个线程上！但是，这并不意味着我们没有竞争条件。相反，他们可以相当普遍。问题的根源在于异步操作的调用与其结果通知之间的延迟。举一个具体的例子，我们可以再次参考我们的`Web爬虫`应用程序，特别是我们创建的最后一个版本，其实际上包含一个竞争条件。\\n\\n问题在于在开始下载相应的`URL`的文档之前，检查文件是否已经存在的`spider()`函数：\\n\\n```javascript\\nfunction spider(url, nesting, callback) {\\n  if(spidering.has(url)) {\\n    return process.nextTick(callback);\\n  }\\n  spidering.set(url, true);\\n\\n  const filename = utilities.urlToFilename(url);\\n  fs.readFile(filename, 'utf8', function(err, body) {\\n    if(err) {\\n      if(err.code !== 'ENOENT') {\\n        return callback(err);\\n      }\\n\\n      return download(url, filename, function(err, body) {\\n        if(err) {\\n          return callback(err);\\n        }\\n        spiderLinks(url, body, nesting, callback);\\n      });\\n    }\\n\\n    spiderLinks(url, body, nesting, callback);\\n  });\\n}\\n```\\n\\n现在的问题是，在同一个`URL`上操作的两个爬虫任务可能会在两个任务之一完成下载并创建一个文件，导致第二个任务开始下载之前，在同一个文件上调用`fs.readFile()`的结果不对，致使下载两次。这种情况如下图所示：\\n\\n![](http://oczira72b.bkt.clouddn.com/17-10-23/40668372.jpg)\\n\\n上图显示了`Task 1`和`Task 2`如何在`Node.js`的单个线程中交错执行，以及异步操作如何实际引入竞争条件。在我们的情况下，两个爬虫任务最终会下载相同的文件。\\n我们如何解决这个问题？答案比我们想象的要简单得多。实际上，我们所需要的只是一个变量（互斥变量），可以相互排除运行在同一个`URL`上的多个`spider()`任务。这可以通过以下代码来实现：\\n\\n```javascript\\nconst spidering = new Map();\\n\\nfunction spider(url, nesting, callback) {\\n  if (spidering.has(url)) {\\n    return process.nextTick(callback);\\n  }\\n  spidering.set(url, true);\\n  // ...\\n}\\n```\\n\\n## 并行执行频率限制\\n通常，如果不控制并行任务频率，并行任务就会导致过载。想象一下，有数千个文件要读取，访问的`URL`或数据库查询并行运行。在这种情况下，常见的问题是系统资源不足，例如，当尝试一次打开太多文件时，利用可用于应用程序的所有文件描述符。在`Web应用程序`中，它还可能会创建一个利用拒绝服务（`DoS`）攻击的漏洞。在所有这种情况下，最好限制同时运行的任务数量。这样，我们可以为服务器的负载增加一些可预测性，并确保我们的应用程序不会耗尽资源。下图描述了一个情况，我们将五个任务并行运行并发限制为两段：\\n\\n![](http://oczira72b.bkt.clouddn.com/17-10-23/74453602.jpg)\\n\\n从上图可以清楚我们的算法如何工作：\\n\\n1. 我们可以执行尽可能多的任务，而不超过并发限制。\\n2. 每当任务完成时，我们再执行一个或多个任务，同时确保任务数量达不到限制。\\n\\n### 并发限制\\n我们现在提出一种模式，以有限的并发性并行执行一组给定的任务：\\n\\n```javascript\\nconst tasks = ...\\nlet concurrency = 2, running = 0, completed = 0, index = 0;\\n\\nfunction next() {\\n  while (running < concurrency && index < tasks.length) {\\n    task = tasks[index++];\\n    task(() => {\\n      if (completed === tasks.length) {\\n        return finish();\\n      }\\n      completed++, running--;\\n      next();\\n    });\\n    running++;\\n  }\\n}\\nnext();\\n\\nfunction finish() {\\n  // 所有任务执行完成\\n}\\n```\\n\\n该算法可以被认为是顺序执行和并行执行之间的混合。事实上，我们可能会注意到我们之前介绍的两种模式的相似之处：\\n\\n1. 我们有一个迭代器函数，我们称之为`next()`，有一个内部循环，并行执行尽可能多的任务，同时保持并发限制。\\n2. 我们传递给每个任务的回调检查是否完成了列表中的所有任务。如果还有任务要运行，它会调用`next()`来执行下一个任务。\\n\\n### 全局并发限制\\n我们的`Web爬虫`应用程序非常适合应用我们所学到的限制一组任务的并发性。事实上，为了避免同时爬上数千个链接的情况，我们可以通过在并发下载数量上增加一些措施来限制并发量。\\n\\n> 0.11之前的Node.js版本已经将每个主机的并发HTTP连接数限制为5.然而，这可以改变以适应我们的需要。请查看官方文档http://nodejs.org/docs/v0.10.0/api/http.html#http_agent_m axsockets中的更多内容。从Node.js 0.11开始，并发连接数没有默认限制。\\n\\n我们可以将我们刚刚学到的模式应用到我们的`spiderLinks()`函数，但是我们将获得的只是限制一个页面中的一组链接的并发性。如果我们选择了并发量为2，我们最多可以为每个页面并行下载两个链接。然而，由于我们可以一次下载多个链接，因此每个页面都会产生另外两个下载，这样递归下去，其实也没有完全做到并发量的限制。\\n\\n#### 使用队列\\n我们真正想要的是限制我们可以并行运行的全局下载操作数量。我们可以略微修改之前展示的模式，但是我们宁愿把它作为一个练习，因为我们想借此机会引入另一个机制，它利用队列来限制多个任务的并发性。让我们看看这是如何工作的。\\n\\n我们现在要实现一个名为`TaskQueue`类，它将队列与我们之前提到的算法相结合。我们创建一个名为`taskQueue.js`的新模块：\\n\\n```javascript\\nclass TaskQueue {\\n  constructor(concurrency) {\\n    this.concurrency = concurrency;\\n    this.running = 0;\\n    this.queue = [];\\n  }\\n  pushTask(task) {\\n    this.queue.push(task);\\n    this.next();\\n  }\\n  next() {\\n    while (this.running < this.concurrency && this.queue.length) {\\n      const task = this.queue.shift();\\n      task(() => {\\n        this.running--;\\n        this.next();\\n      });\\n      this.running++;\\n    }\\n  }\\n};\\n```\\n\\n上述类的构造函数只作为输入的并发限制，但除此之外，它初始化运行和队列的变量。前一个变量是用于跟踪所有正在运行的任务的计数器，而后者是将用作队列以存储待处理任务的数组。\\n\\n`pushTask()`方法简单地将新任务添加到队列中，然后通过调用`this.next()`来引导任务的执行。\\n\\n`next()`方法从队列中生成一组任务，确保它不超过并发限制。\\n\\n我们可能会注意到，这种方法与限制我们前面提到的并发性的模式有一些相似之处。它基本上从队列开始尽可能多的任务，而不超过并发限制。当每个任务完成时，它会更新运行任务的计数，然后再次调用`next()`来启动另一轮任务。 `TaskQueue`类的有趣属性是它允许我们动态地将新的项目添加到队列中。另一个优点是，现在我们有一个中央实体负责限制我们任务的并发性，这可以在函数执行的所有实例中共享。在我们的例子中，它是`spider()`函数，我们将在稍后看到。\\n\\n#### Web爬虫版本4\\n现在我们有一个通用的队列来执行有限的并行流程中的任务，我们可以在我们的`Web爬虫`应用程序中直接使用它。我们首先加载新的依赖关系并通过将并发限制设置为2来创建`TaskQueue`类的新实例：\\n\\n```javascript\\nconst TaskQueue = require('./taskQueue');\\nconst downloadQueue = new TaskQueue(2);\\n```\\n\\n接下来，我们使用新创建的`downloadQueue`更新`spiderLinks()`函数：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting, callback) {\\n  if (nesting === 0) {\\n    return process.nextTick(callback);\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  if (links.length === 0) {\\n    return process.nextTick(callback);\\n  }\\n  let completed = 0,\\n    hasErrors = false;\\n  links.forEach(link => {\\n    downloadQueue.pushTask(done => {\\n      spider(link, nesting - 1, err => {\\n        if (err) {\\n          hasErrors = true;\\n          return callback(err);\\n        }\\n        if (++completed === links.length && !hasErrors) {\\n          callback();\\n        }\\n        done();\\n      });\\n    });\\n  });\\n}\\n```\\n\\n这个函数的这种新的实现是非常容易的，它与这本章前面提到的无限并行执行的算法非常相似。这是因为我们将并发控制委托给`TaskQueue`对象，我们唯一要做的就是检查所有任务是否完成。看上述代码中如何定义我们的任务：\\n\\n* 我们通过提供自定义回调来运行`spider()`函数。\\n* 在回调中，我们检查与`spiderLinks()`函数执行相关的所有任务是否完成。当这个条件为真时，我们调用spiderLinks（）函数的最后回调。\\n* 在我们的任务结束时，我们调用了`done()`回调，以便队列可以继续执行。\\n\\n在我们进行这些小的变化之后，我们现在可以尝试再次运行`Web爬虫`应用程序。这一次，我们应该注意到，同时不会有两个以上的下载。\\n\\n## async库\\n如果我们到目前为止我们分析的每一个控制流程模式看一下，我们可以看到它们可以用作构建可重用和更通用的解决方案的基础。例如，我们可以将无限制的并行执行算法包装到一个接受任务列表的函数中，并行运行它们，并且当它们都完成时调用给定的回调函数。将控制流算法转化为可重用功能的这种方式可以导致更具声明性和表达性的方式来定义异步控制流，这正是[async](https://npmjs.org/package/async)所做的。`async`库是一个非常流行的解决方案，在`Node.js`和`JavaScript`中来说，用于处理异步代码。它提供了一组功能，可以大大简化不同配置中一组任务的执行，并为异步处理集合提供了有用的帮助。即使有其他几个具有相似目标的库，由于它的受欢迎程度，因此`async`是`Node.js`中的一个事实上的标准。\\n\\n### 顺序执行\\n`async`库可以在实现复杂的异步控制流程时大大帮助我们，但是一个难题就是选择正确的库来解决问题。例如，对于顺序执行，有大约20个不同的函数可供选择，包括`eachSeries()`, `mapSeries()`, `filterSeries()`, `rejectSeries()`, `reduce()`, `reduceRight()`, `detectSeries()`, `concatSeries()`, `series()`, `whilst()`, `doWhilst()`, `until()`, `doUntil()`, `forever()`, `waterfall()`, `compose()`, `seq()`, `applyEachSeries()`, `iterator()`, 和`timesSeries()`\\n。\\n\\n选择正确的函数是编写更稳固和可读的代码的重要一步，但这也需要一些经验和实践。在我们的例子中，我们将仅介绍其中的一些情况，但它们仍将为理解和有效地使用库的其余部分提供坚实的基础。\\n\\n下面，通过例子说明`async`库如何工作，我们将用于我们的`Web爬虫`应用程序。我们直接从版本2开始，按顺序递归地下载所有的链接。\\n\\n但是，首先我们确保将`async`库安装到我们当前的项目中：\\n\\n```bash\\nnpm install async\\n```\\n\\n然后我们需要从`spider.js`模块加载新的依赖项：\\n\\n```javascript\\nconst async = require('async');\\n```\\n\\n### 已知一组任务的顺序执行\\n我们先修改`download()`函数。如下所示，它依次做了以下三件事：\\n\\n1. 下载`URL`的内容。\\n2. 创建一个新目录（如果尚不存在）。 \\n3. 将`URL`的内容保存到文件中。\\n\\n`async.series()`可以实现顺序执行一组任务：\\n\\n```javascript\\nasync.series(tasks, [callback])\\n```\\n\\n`async.series()`接受一个任务列表和一个在所有任务完成后调用的回调函数作为参数。每个任务只是一个接受回调函数的函数，当任务完成执行时，这个回调函数被调用：\\n\\n```javascript\\nfunction task(callback) {}\\n```\\n\\n`async`的优势是它使用与`Node.js`相同的回调约定，它会自动处理错误传播。所以，如果任何一个任务调用它的回调并且产生了一个错误，`async`将跳过列表中剩余的任务，直接跳转到最后的回调。\\n\\n考虑到这一点，让我们看看如何通过使用`async`来修改上述的`download()`函数：\\n\\n```javascript\\nfunction download(url, filename, callback) {\\n  console.log(`Downloading ${url}`);\\n  let body;\\n  async.series([\\n    callback => {\\n      request(url, (err, response, resBody) => {\\n        if (err) {\\n          return callback(err);\\n        }\\n        body = resBody;\\n        callback();\\n      });\\n    },\\n    mkdirp.bind(null, path.dirname(filename)),\\n    callback => {\\n      fs.writeFile(filename, body, callback);\\n    }\\n  ], err => {\\n    if (err) {\\n      return callback(err);\\n    }\\n    console.log(`Downloaded and saved: ${url}`);\\n    callback(null, body);\\n  });\\n}\\n```\\n\\n对比起这段代码的回调地狱版本，使用`async`方式使我们能够更好地组织我们的异步任务。并且不会嵌套回调，因为我们只需要提供一个的任务列表，通常对于用于每个异步操作，然后异步任务将依次执行：\\n\\n1. 首先是下载`URL`的内容。我们将响应体保存到一个闭包变量（`body`）中，以便它可以与其他任务共享。\\n2. 创建并保存下载的页面的目录。我们通过执行`mkdirp()`函数实现，并和创建的目录路径绑定。这样，我们可以节省几行代码并增加其可读性。\\n3. 最后，我们将下载的`URL`的内容写入文件。在这种情况下，我们无法执行部分应用程序（就像我们在第二个任务中所做的那样），因为变量`body`只在系列中的下载任务完成后才可用。但是，通过将任务的回调直接传递到`fs.writeFile()`函数，我们仍然可以通过利用异步的自动错误管理来保存一些代码行。\\n4.完成所有任务后，将调用`async.series()`的最后回调。在我们的例子中，我们只是做一些错误管理，然后返回`body`变量来回调`download()`函数。\\n\\n对于上述情况，`async.series()`的一个可替代的方法是`async.waterfall()`，它仍然按顺序执行任务，但另外还提供每个任务的输出作为下一个输入。在我们的情况下，我们可以使用这个特征来传播`body`变量直到序列结束。\\n\\n### 顺序迭代\\n在前面讲了如何按顺序执行一组任务。上面的例子`async.series()`来做到这一点。可以使用相同的功能来实现`Web爬虫版本2`的`spiderLinks()`函数。然而，`async`为特定的情况提供了一个更合适的`API`，遍历一个集合，这个`API`是`async.eachSeries()`。我们来使用它来重新实现我们的`spiderLinks()`函数（版本2，串行下载），如下所示：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting, callback) {\\n  if (nesting === 0) {\\n    return process.nextTick(callback);\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  if (links.length === 0) {\\n    return process.nextTick(callback);\\n  }\\n  async.eachSeries(links, (link, callback) => {\\n    spider(link, nesting - 1, callback);\\n  }, callback);\\n}\\n```\\n\\n如果我们将使用`async`的上述代码与使用纯`JavaScript`模式实现的相同功能的代码进行比较，我们将注意到`async`在代码组织和可读性方面给我们带来的巨大优势。\\n\\n## 并行执行\\n`async`不具有处理并行流的功能，其中可以找到`each()`，`map()`，`filter()`，`reject()`，`detect()`，`some()`，`every()`，`concat()`，`parallel()`，`applyEach()`和`times()`。它们遵循与我们已经看到的用于顺序执行的功能相同的逻辑，区别在于所提供的任务是并行执行的。\\n\\n为了证明这一点，我们可以尝试应用上述功能之一来实现我们的`Web爬虫`应用程序的第三版，即使用无限制的并行流程来执行下载。\\n\\n如果我们记住我们之前使用的代码来实现`spiderLinks()`函数的顺序版本，那么调整它使其并行工作就比较简单：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting, callback) {\\n  // ...\\n  async.each(links, (link, callback) => {\\n    spider(link, nesting - 1, callback);\\n  }, callback);\\n}\\n```\\n\\n这个函数与我们用于顺序下载的功能完全相同，但是使用的是`async.each()`而非`async.eachSeries()`。这清楚地表明了使用库（例如`async`）抽象异步流的功能。代码不再绑定到特定的执行流程了，没有专门为此写的代码。大多数只是应用逻辑。\\n\\n## 限制并行执行\\n如果你想知道`async`还可以用来限制并行任务的并发性，答案是肯定的。我们有一些我们可以使用的函数，即`eachLimit()`，`mapLimit()`，`parallelLimit()`，`queue()`和`cargo()`。\\n\\n我们试图利用其中的一个来实现`Web爬虫`应用程序的第4版，以有限的并发性并行执行链接的下载。幸运的是，`async`有`async.queue()`，它的工作方式与本章前面创建的`TaskQueue`类似。 `async.queue()`函数创建一个新的队列，它使用一个`worker()`函数来执行一组具有指定并发限制的任务：\\n\\n```javascript\\nconst q = async.queue(worker, concurrency);\\n```\\n\\n`worker()`函数作为输入接收要运行的任务和一个回调函数作为参数，当任务完成时执行回调：\\n\\n```\\nfunction worker(task, callback);\\n```\\n\\n我们应该注意到在这个例子中 `task` 可以是任何类型，而不仅仅只能是函数。实际上， `worker`有责任以最适当的方式处理任务。新建任务，可以通过`q.push(task, callback)`将任务添加到队列中。一个任务处理完后，关联一个任务的回调函数必须被`worker`调用。\\n\\n现在，我们再次修改我们的代码实现一个全面并行的有并发限制的执行流，利用`async.queue()`,首先，我们需要创建一个队列:\\n\\n```javascript\\nconst downloadQueue = async.queue((taskData, callback) => {\\n  spider(taskData.link, taskData.nesting - 1, callback);\\n}, 2);\\n```\\n\\n代码很简单。我们正在创建一个并发限制为2的新队列，让一个工作人员只需使用与任务关联的数据调用我们的`spider()`函数。接下来，我们实现`spiderLinks()`函数：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting, callback) {\\n  if (nesting === 0) {\\n    return process.nextTick(callback);\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  if (links.length === 0) {\\n    return process.nextTick(callback);\\n  }\\n  const completed = 0,\\n    hasErrors = false;\\n  links.forEach(function(link) {\\n    const taskData = {\\n      link: link,\\n      nesting: nesting\\n    };\\n    downloadQueue.push(taskData, err => {\\n      if (err) {\\n        hasErrors = true;\\n        return callback(err);\\n      }\\n      if (++completed === links.length && !hasErrors) {\\n        callback();\\n      }\\n    });\\n  });\\n}\\n```\\n\\n前面的代码应该看起来非常熟悉，因为它几乎和使用`TaskQueue`对象来实现相同流程的代码相同。此外，在这种情况下，要分析的重要部分是将新任务推入队列的位置。在这一点上，我们确保我们传递一个回调，使我们能够检查当前页面的所有下载任务是否完成，并最终调用最终回调。\\n\\n辛亏有`async.queue()`，我们可以轻松地复制我们的`TaskQueue`对象的功能，再次证明了通过`async`，我们可以避免从头开始编写异步控制流模式，减少我们的工作量，代码量更加简洁。\\n\\n## 总结\\n在本章开始的时候，我们说`Node.js`的编程可能很难因为它的异步性，特别是对于以前在其他平台上开发的人而言。然而，在本章中，我们展示了异步`API`如何可以从简单原生`JavaScript`开始，从而为我们分析更复杂的技术奠定了基础。然后我们看到，除了为每一种口味提供编程风格，我们所掌握的工具确实是多样化的，并为我们大部分的问题提供了很好的解决方案。例如，我们可以选择`async`库来简化最常见的流程。\\n\\n还有更为先进的技术，如`Promise`和`Generator`函数，这将是下一章的重点。当了解所有这些技术时，能够根据需求选择最佳解决方案，或者在同一个项目中使用多种技术。\"\n}"
*************** response log end ***************

[2017-12-01 12:09:45.950] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/users/login
request client ip:  ::1
request body: 
{"userName":"admin","password":"2017Dctm@1234"}
response time: 2
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"success\",\n  \"data\": {\n    \"token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxMzg1LCJleHAiOjE1MTIxNDQ1ODV9.3ZUMjiYY52uT86EorXlttbw6p7vlKKZAdpv1nH21U4U\",\n    \"userName\": \"admin\",\n    \"role\": \"normal\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:09:46.269] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/users/getUserInfo?userName=admin
request client ip:  ::1
request query:  {"userName":"admin"}
response time: 2
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"回复成功\",\n  \"data\": {\n    \"userName\": \"admin\",\n    \"registerTime\": \"2017-11-23T07:36:51.931Z\",\n    \"message\": []\n  }\n}"
*************** response log end ***************

[2017-12-01 12:09:46.282] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/art/getArticleLists
request client ip:  ::1
request body: 
{"currentPage":1,"pageSize":10,"sortField":"lastReplyTime","totalElement":1,"labels":[],"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxMzg1LCJleHAiOjE1MTIxNDQ1ODV9.3ZUMjiYY52uT86EorXlttbw6p7vlKKZAdpv1nH21U4U"}
response time: 8
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"data\": [\n      {\n        \"_id\": \"5a0e8b7949b148371be1f96e\",\n        \"title\": \"fvf\",\n        \"content\": \"fvfv\",\n        \"author\": \"qichangjun\",\n        \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n        \"__v\": 0,\n        \"replyList\": [\n          {\n            \"userName\": \"admin\",\n            \"content\": \"hohoho\",\n            \"_id\": \"5a16847e98682e4e67834b7e\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"hohoho\",\n            \"_id\": \"5a16848198682e4e67834b80\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"hohoho\",\n            \"_id\": \"5a16848398682e4e67834b82\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"1111\",\n            \"_id\": \"5a179235954bda0eb0fb667e\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n          }\n        ],\n        \"label\": [],\n        \"replyNum\": 4,\n        \"viewed\": 25,\n        \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n      },\n      {\n        \"_id\": \"5a1785b3bbb11c04f3f739ea\",\n        \"title\": \"asd\",\n        \"content\": \"sadsads\",\n        \"author\": \"admin\",\n        \"lastReplyTime\": \"2017-11-24T02:36:35.619Z\",\n        \"__v\": 0,\n        \"replyList\": [],\n        \"label\": [\n          \"111\",\n          \"222\"\n        ],\n        \"replyNum\": 0,\n        \"viewed\": 1,\n        \"creatDate\": \"2017-11-24T02:36:35.619Z\"\n      },\n      {\n        \"_id\": \"5a0e8b7f49b148371be1f96f\",\n        \"title\": \"vedvde\",\n        \"content\": \"vdve\",\n        \"author\": \"qichangjun\",\n        \"lastReplyTime\": \"2017-11-23T08:18:03.507Z\",\n        \"__v\": 0,\n        \"replyList\": [\n          {\n            \"userName\": \"qichangjun\",\n            \"content\": \"dd\",\n            \"_id\": \"5a0e8cd449b148371be1f971\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-17T07:16:36.427Z\"\n          },\n          {\n            \"userName\": \"qichangjun\",\n            \"content\": \"ddcc\",\n            \"_id\": \"5a0e8cd849b148371be1f972\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-17T07:16:40.748Z\"\n          },\n          {\n            \"userName\": \"qichangjun\",\n            \"content\": \"ddccxxsa\",\n            \"_id\": \"5a0e8cdb49b148371be1f973\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-17T07:16:43.954Z\"\n          },\n          {\n            \"userName\": \"qichangjun\",\n            \"content\": \"![32f8b3d82fc63.jpg](http://7xpyje.com1.z0.glb.clouddn.com/32f8b3d82fc63.jpg)\",\n            \"_id\": \"5a0e956027648c3bc64a8f77\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-17T07:53:04.705Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"![1edca434719e2.png](http://7xpyje.com1.z0.glb.clouddn.com/1edca434719e2.png?imageView2/1/w/400/h/400/q/75|watermark/2/text/5bCP5LiD5Y2a5a6i/font/5a6L5L2T/fontsize/400/fill/I0RBQ0RDRA==/dissolve/48/gravity/SouthEast/dx/10/dy/10|imageslim)\",\n            \"_id\": \"5a1230b76b9523050f9cff65\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-20T01:32:39.609Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"hahaha\",\n            \"_id\": \"5a16843b98682e4e67834b7c\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-23T08:18:03.507Z\"\n          }\n        ],\n        \"label\": [],\n        \"replyNum\": 6,\n        \"viewed\": 31,\n        \"creatDate\": \"2017-11-17T07:10:55.336Z\"\n      },\n      {\n        \"_id\": \"5a14ddccfcab6103ee8315f8\",\n        \"title\": \"aaaa\",\n        \"content\": \"![0c88904a90297.png](http://7xpyje.com1.z0.glb.clouddn.com/0c88904a90297.png?imageView2/1/w/400/h/400/q/75|watermark/2/text/5bCP5LiD5Y2a5a6i/font/5a6L5L2T/fontsize/400/fill/I0RBQ0RDRA==/dissolve/48/gravity/SouthEast/dx/10/dy/10|imageslim)\",\n        \"author\": \"admin\",\n        \"lastReplyTime\": \"2017-11-23T08:17:45.908Z\",\n        \"__v\": 0,\n        \"replyList\": [\n          {\n            \"userName\": \"admin\",\n            \"content\": \" \\n[aaaa](http://baidu.com)\",\n            \"_id\": \"5a14ef1afcab6103ee8315fb\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-22T03:29:30.148Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"abc\",\n            \"_id\": \"5a1679e2fc7df847971b2c10\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-23T07:33:54.750Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"bdcd\",\n            \"_id\": \"5a167a45b5e32e47bd287713\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-23T07:35:33.273Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"bdea\",\n            \"_id\": \"5a167ac7149269481c27a09d\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-23T07:37:43.576Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"bdba\",\n            \"_id\": \"5a16842998682e4e67834b7b\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-23T08:17:45.908Z\"\n          }\n        ],\n        \"label\": [],\n        \"replyNum\": 5,\n        \"viewed\": 112,\n        \"creatDate\": \"2017-11-22T02:15:40.492Z\"\n      },\n      {\n        \"_id\": \"5a13dd0b2874a8757e13e9ed\",\n        \"title\": \"ghhhh\",\n        \"content\": \"gggerge\",\n        \"author\": \"admin\",\n        \"lastReplyTime\": \"2017-11-21T08:00:11.544Z\",\n        \"__v\": 0,\n        \"replyList\": [],\n        \"label\": [\n          \"angular\"\n        ],\n        \"replyNum\": 0,\n        \"viewed\": 49,\n        \"creatDate\": \"2017-11-21T08:00:11.544Z\"\n      },\n      {\n        \"_id\": \"5a13dcea314c147535a700b7\",\n        \"title\": \"ghhhh\",\n        \"content\": \"gggerge\",\n        \"author\": \"admin\",\n        \"lastReplyTime\": \"2017-11-21T07:59:38.425Z\",\n        \"__v\": 0,\n        \"replyList\": [],\n        \"label\": [\n          \"angular\"\n        ],\n        \"replyNum\": 0,\n        \"viewed\": 1,\n        \"creatDate\": \"2017-11-21T07:59:38.425Z\"\n      },\n      {\n        \"_id\": \"5a13dcca314c147535a700b4\",\n        \"title\": \"测试标签\",\n        \"content\": \"测试标签\",\n        \"author\": \"admin\",\n        \"lastReplyTime\": \"2017-11-21T07:59:06.772Z\",\n        \"__v\": 0,\n        \"replyList\": [],\n        \"label\": [\n          \"angular\",\n          \"javascript\"\n        ],\n        \"replyNum\": 0,\n        \"viewed\": 1,\n        \"creatDate\": \"2017-11-21T07:59:06.772Z\"\n      },\n      {\n        \"_id\": \"5a13dbfb49a16c75252cc059\",\n        \"title\": \"cd\",\n        \"content\": \"cdcd\",\n        \"author\": \"admin\",\n        \"lastReplyTime\": \"2017-11-21T07:55:39.191Z\",\n        \"__v\": 0,\n        \"replyList\": [],\n        \"label\": [\n          \"111\",\n          \"222\"\n        ],\n        \"replyNum\": 0,\n        \"viewed\": 0,\n        \"creatDate\": \"2017-11-21T07:55:39.191Z\"\n      },\n      {\n        \"_id\": \"5a13daee318f07746f106f06\",\n        \"title\": \"测试测试标签\",\n        \"content\": \"sss\",\n        \"author\": \"admin\",\n        \"lastReplyTime\": \"2017-11-21T07:51:10.817Z\",\n        \"__v\": 0,\n        \"replyList\": [],\n        \"label\": [\n          \"angular\",\n          \"javascript\"\n        ],\n        \"replyNum\": 0,\n        \"viewed\": 0,\n        \"creatDate\": \"2017-11-21T07:51:10.817Z\"\n      },\n      {\n        \"_id\": \"5a13da0771bb24738eaa2364\",\n        \"title\": \"hhh\",\n        \"content\": \"hhhh\",\n        \"author\": \"admin\",\n        \"lastReplyTime\": \"2017-11-21T07:47:19.202Z\",\n        \"__v\": 0,\n        \"replyList\": [],\n        \"label\": [\n          \"angular\",\n          \"javascript\"\n        ],\n        \"replyNum\": 0,\n        \"viewed\": 0,\n        \"creatDate\": \"2017-11-21T07:47:19.202Z\"\n      }\n    ],\n    \"totalElement\": 27\n  }\n}"
*************** response log end ***************

[2017-12-01 12:09:46.287] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/label/getLabelLists
request client ip:  ::1
request body: 
{"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxMzg1LCJleHAiOjE1MTIxNDQ1ODV9.3ZUMjiYY52uT86EorXlttbw6p7vlKKZAdpv1nH21U4U","keyword":""}
response time: 3
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": [\n    {\n      \"_id\": \"5a13dcca314c147535a700b5\",\n      \"name\": \"angular\",\n      \"__v\": 0,\n      \"number\": 2\n    },\n    {\n      \"_id\": \"5a13dcca314c147535a700b6\",\n      \"name\": \"javascript\",\n      \"__v\": 0,\n      \"number\": 1\n    },\n    {\n      \"_id\": \"5a1785b3bbb11c04f3f739eb\",\n      \"name\": \"111\",\n      \"__v\": 0,\n      \"number\": 1\n    },\n    {\n      \"_id\": \"5a1785b3bbb11c04f3f739ec\",\n      \"name\": \"222\",\n      \"__v\": 0,\n      \"number\": 1\n    }\n  ]\n}"
*************** response log end ***************

[2017-12-01 12:09:48.031] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/art/updateCheckTimes
request client ip:  ::1
request body: 
{"id":"5a0e8b7949b148371be1f96e","token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxMzg1LCJleHAiOjE1MTIxNDQ1ODV9.3ZUMjiYY52uT86EorXlttbw6p7vlKKZAdpv1nH21U4U"}
response time: 8
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 26,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:09:48.032] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/art/getArticleDetail?id=5a0e8b7949b148371be1f96e
request client ip:  ::1
request query:  {"id":"5a0e8b7949b148371be1f96e"}
response time: 7
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 26,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:12:56.825] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/users/login
request client ip:  ::1
request body: 
{"userName":"admin","password":"2017Dctm@1234"}
response time: 2
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"success\",\n  \"data\": {\n    \"token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxNTc2LCJleHAiOjE1MTIxNDQ3NzZ9.uKBuLKHhVqQEXpCm68cxufPp3HqLhF25sI_3iT0rBmI\",\n    \"userName\": \"admin\",\n    \"role\": \"normal\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:12:57.173] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/users/getUserInfo?userName=admin
request client ip:  ::1
request query:  {"userName":"admin"}
response time: 2
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"回复成功\",\n  \"data\": {\n    \"userName\": \"admin\",\n    \"registerTime\": \"2017-11-23T07:36:51.931Z\",\n    \"message\": []\n  }\n}"
*************** response log end ***************

[2017-12-01 12:12:57.186] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/art/getArticleLists
request client ip:  ::1
request body: 
{"currentPage":1,"pageSize":10,"sortField":"lastReplyTime","totalElement":1,"labels":[],"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxNTc2LCJleHAiOjE1MTIxNDQ3NzZ9.uKBuLKHhVqQEXpCm68cxufPp3HqLhF25sI_3iT0rBmI"}
response time: 7
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"data\": [\n      {\n        \"_id\": \"5a0e8b7949b148371be1f96e\",\n        \"title\": \"fvf\",\n        \"content\": \"fvfv\",\n        \"author\": \"qichangjun\",\n        \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n        \"__v\": 0,\n        \"replyList\": [\n          {\n            \"userName\": \"admin\",\n            \"content\": \"hohoho\",\n            \"_id\": \"5a16847e98682e4e67834b7e\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"hohoho\",\n            \"_id\": \"5a16848198682e4e67834b80\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"hohoho\",\n            \"_id\": \"5a16848398682e4e67834b82\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"1111\",\n            \"_id\": \"5a179235954bda0eb0fb667e\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n          }\n        ],\n        \"label\": [],\n        \"replyNum\": 4,\n        \"viewed\": 26,\n        \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n      },\n      {\n        \"_id\": \"5a1785b3bbb11c04f3f739ea\",\n        \"title\": \"asd\",\n        \"content\": \"sadsads\",\n        \"author\": \"admin\",\n        \"lastReplyTime\": \"2017-11-24T02:36:35.619Z\",\n        \"__v\": 0,\n        \"replyList\": [],\n        \"label\": [\n          \"111\",\n          \"222\"\n        ],\n        \"replyNum\": 0,\n        \"viewed\": 1,\n        \"creatDate\": \"2017-11-24T02:36:35.619Z\"\n      },\n      {\n        \"_id\": \"5a0e8b7f49b148371be1f96f\",\n        \"title\": \"vedvde\",\n        \"content\": \"vdve\",\n        \"author\": \"qichangjun\",\n        \"lastReplyTime\": \"2017-11-23T08:18:03.507Z\",\n        \"__v\": 0,\n        \"replyList\": [\n          {\n            \"userName\": \"qichangjun\",\n            \"content\": \"dd\",\n            \"_id\": \"5a0e8cd449b148371be1f971\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-17T07:16:36.427Z\"\n          },\n          {\n            \"userName\": \"qichangjun\",\n            \"content\": \"ddcc\",\n            \"_id\": \"5a0e8cd849b148371be1f972\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-17T07:16:40.748Z\"\n          },\n          {\n            \"userName\": \"qichangjun\",\n            \"content\": \"ddccxxsa\",\n            \"_id\": \"5a0e8cdb49b148371be1f973\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-17T07:16:43.954Z\"\n          },\n          {\n            \"userName\": \"qichangjun\",\n            \"content\": \"![32f8b3d82fc63.jpg](http://7xpyje.com1.z0.glb.clouddn.com/32f8b3d82fc63.jpg)\",\n            \"_id\": \"5a0e956027648c3bc64a8f77\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-17T07:53:04.705Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"![1edca434719e2.png](http://7xpyje.com1.z0.glb.clouddn.com/1edca434719e2.png?imageView2/1/w/400/h/400/q/75|watermark/2/text/5bCP5LiD5Y2a5a6i/font/5a6L5L2T/fontsize/400/fill/I0RBQ0RDRA==/dissolve/48/gravity/SouthEast/dx/10/dy/10|imageslim)\",\n            \"_id\": \"5a1230b76b9523050f9cff65\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-20T01:32:39.609Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"hahaha\",\n            \"_id\": \"5a16843b98682e4e67834b7c\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-23T08:18:03.507Z\"\n          }\n        ],\n        \"label\": [],\n        \"replyNum\": 6,\n        \"viewed\": 31,\n        \"creatDate\": \"2017-11-17T07:10:55.336Z\"\n      },\n      {\n        \"_id\": \"5a14ddccfcab6103ee8315f8\",\n        \"title\": \"aaaa\",\n        \"content\": \"![0c88904a90297.png](http://7xpyje.com1.z0.glb.clouddn.com/0c88904a90297.png?imageView2/1/w/400/h/400/q/75|watermark/2/text/5bCP5LiD5Y2a5a6i/font/5a6L5L2T/fontsize/400/fill/I0RBQ0RDRA==/dissolve/48/gravity/SouthEast/dx/10/dy/10|imageslim)\",\n        \"author\": \"admin\",\n        \"lastReplyTime\": \"2017-11-23T08:17:45.908Z\",\n        \"__v\": 0,\n        \"replyList\": [\n          {\n            \"userName\": \"admin\",\n            \"content\": \" \\n[aaaa](http://baidu.com)\",\n            \"_id\": \"5a14ef1afcab6103ee8315fb\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-22T03:29:30.148Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"abc\",\n            \"_id\": \"5a1679e2fc7df847971b2c10\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-23T07:33:54.750Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"bdcd\",\n            \"_id\": \"5a167a45b5e32e47bd287713\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-23T07:35:33.273Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"bdea\",\n            \"_id\": \"5a167ac7149269481c27a09d\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-23T07:37:43.576Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"bdba\",\n            \"_id\": \"5a16842998682e4e67834b7b\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-23T08:17:45.908Z\"\n          }\n        ],\n        \"label\": [],\n        \"replyNum\": 5,\n        \"viewed\": 112,\n        \"creatDate\": \"2017-11-22T02:15:40.492Z\"\n      },\n      {\n        \"_id\": \"5a13dd0b2874a8757e13e9ed\",\n        \"title\": \"ghhhh\",\n        \"content\": \"gggerge\",\n        \"author\": \"admin\",\n        \"lastReplyTime\": \"2017-11-21T08:00:11.544Z\",\n        \"__v\": 0,\n        \"replyList\": [],\n        \"label\": [\n          \"angular\"\n        ],\n        \"replyNum\": 0,\n        \"viewed\": 49,\n        \"creatDate\": \"2017-11-21T08:00:11.544Z\"\n      },\n      {\n        \"_id\": \"5a13dcea314c147535a700b7\",\n        \"title\": \"ghhhh\",\n        \"content\": \"gggerge\",\n        \"author\": \"admin\",\n        \"lastReplyTime\": \"2017-11-21T07:59:38.425Z\",\n        \"__v\": 0,\n        \"replyList\": [],\n        \"label\": [\n          \"angular\"\n        ],\n        \"replyNum\": 0,\n        \"viewed\": 1,\n        \"creatDate\": \"2017-11-21T07:59:38.425Z\"\n      },\n      {\n        \"_id\": \"5a13dcca314c147535a700b4\",\n        \"title\": \"测试标签\",\n        \"content\": \"测试标签\",\n        \"author\": \"admin\",\n        \"lastReplyTime\": \"2017-11-21T07:59:06.772Z\",\n        \"__v\": 0,\n        \"replyList\": [],\n        \"label\": [\n          \"angular\",\n          \"javascript\"\n        ],\n        \"replyNum\": 0,\n        \"viewed\": 1,\n        \"creatDate\": \"2017-11-21T07:59:06.772Z\"\n      },\n      {\n        \"_id\": \"5a13dbfb49a16c75252cc059\",\n        \"title\": \"cd\",\n        \"content\": \"cdcd\",\n        \"author\": \"admin\",\n        \"lastReplyTime\": \"2017-11-21T07:55:39.191Z\",\n        \"__v\": 0,\n        \"replyList\": [],\n        \"label\": [\n          \"111\",\n          \"222\"\n        ],\n        \"replyNum\": 0,\n        \"viewed\": 0,\n        \"creatDate\": \"2017-11-21T07:55:39.191Z\"\n      },\n      {\n        \"_id\": \"5a13daee318f07746f106f06\",\n        \"title\": \"测试测试标签\",\n        \"content\": \"sss\",\n        \"author\": \"admin\",\n        \"lastReplyTime\": \"2017-11-21T07:51:10.817Z\",\n        \"__v\": 0,\n        \"replyList\": [],\n        \"label\": [\n          \"angular\",\n          \"javascript\"\n        ],\n        \"replyNum\": 0,\n        \"viewed\": 0,\n        \"creatDate\": \"2017-11-21T07:51:10.817Z\"\n      },\n      {\n        \"_id\": \"5a13da0771bb24738eaa2364\",\n        \"title\": \"hhh\",\n        \"content\": \"hhhh\",\n        \"author\": \"admin\",\n        \"lastReplyTime\": \"2017-11-21T07:47:19.202Z\",\n        \"__v\": 0,\n        \"replyList\": [],\n        \"label\": [\n          \"angular\",\n          \"javascript\"\n        ],\n        \"replyNum\": 0,\n        \"viewed\": 0,\n        \"creatDate\": \"2017-11-21T07:47:19.202Z\"\n      }\n    ],\n    \"totalElement\": 27\n  }\n}"
*************** response log end ***************

[2017-12-01 12:12:57.188] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/label/getLabelLists
request client ip:  ::1
request body: 
{"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxNTc2LCJleHAiOjE1MTIxNDQ3NzZ9.uKBuLKHhVqQEXpCm68cxufPp3HqLhF25sI_3iT0rBmI","keyword":""}
response time: 7
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": [\n    {\n      \"_id\": \"5a13dcca314c147535a700b5\",\n      \"name\": \"angular\",\n      \"__v\": 0,\n      \"number\": 2\n    },\n    {\n      \"_id\": \"5a13dcca314c147535a700b6\",\n      \"name\": \"javascript\",\n      \"__v\": 0,\n      \"number\": 1\n    },\n    {\n      \"_id\": \"5a1785b3bbb11c04f3f739eb\",\n      \"name\": \"111\",\n      \"__v\": 0,\n      \"number\": 1\n    },\n    {\n      \"_id\": \"5a1785b3bbb11c04f3f739ec\",\n      \"name\": \"222\",\n      \"__v\": 0,\n      \"number\": 1\n    }\n  ]\n}"
*************** response log end ***************

[2017-12-01 12:13:00.444] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/art/updateCheckTimes
request client ip:  ::1
request body: 
{"id":"5a0e8b7949b148371be1f96e","token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxNTc2LCJleHAiOjE1MTIxNDQ3NzZ9.uKBuLKHhVqQEXpCm68cxufPp3HqLhF25sI_3iT0rBmI"}
response time: 5
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 27,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:13:00.445] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/art/getArticleDetail?id=5a0e8b7949b148371be1f96e
request client ip:  ::1
request query:  {"id":"5a0e8b7949b148371be1f96e"}
response time: 5
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 27,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:13:12.875] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/users/getUserInfo?userName=admin
request client ip:  ::1
request query:  {"userName":"admin"}
response time: 2
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"回复成功\",\n  \"data\": {\n    \"userName\": \"admin\",\n    \"registerTime\": \"2017-11-23T07:36:51.931Z\",\n    \"message\": []\n  }\n}"
*************** response log end ***************

[2017-12-01 12:13:12.886] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/art/updateCheckTimes
request client ip:  ::1
request body: 
{"id":"5a0e8b7949b148371be1f96e","token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxNTc2LCJleHAiOjE1MTIxNDQ3NzZ9.uKBuLKHhVqQEXpCm68cxufPp3HqLhF25sI_3iT0rBmI"}
response time: 4
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 28,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:13:12.889] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/art/getArticleDetail?id=5a0e8b7949b148371be1f96e
request client ip:  ::1
request query:  {"id":"5a0e8b7949b148371be1f96e"}
response time: 4
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 28,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:13:37.790] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/users/getUserInfo?userName=admin
request client ip:  ::1
request query:  {"userName":"admin"}
response time: 3
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"回复成功\",\n  \"data\": {\n    \"userName\": \"admin\",\n    \"registerTime\": \"2017-11-23T07:36:51.931Z\",\n    \"message\": []\n  }\n}"
*************** response log end ***************

[2017-12-01 12:13:37.813] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/art/updateCheckTimes
request client ip:  ::1
request body: 
{"id":"5a0e8b7949b148371be1f96e","token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxNTc2LCJleHAiOjE1MTIxNDQ3NzZ9.uKBuLKHhVqQEXpCm68cxufPp3HqLhF25sI_3iT0rBmI"}
response time: 5
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 29,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:13:37.815] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/art/getArticleDetail?id=5a0e8b7949b148371be1f96e
request client ip:  ::1
request query:  {"id":"5a0e8b7949b148371be1f96e"}
response time: 1
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 29,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:13:44.071] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/users/getUserInfo?userName=admin
request client ip:  ::1
request query:  {"userName":"admin"}
response time: 2
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"回复成功\",\n  \"data\": {\n    \"userName\": \"admin\",\n    \"registerTime\": \"2017-11-23T07:36:51.931Z\",\n    \"message\": []\n  }\n}"
*************** response log end ***************

[2017-12-01 12:13:44.084] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/art/updateCheckTimes
request client ip:  ::1
request body: 
{"id":"5a0e8b7949b148371be1f96e","token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxNTc2LCJleHAiOjE1MTIxNDQ3NzZ9.uKBuLKHhVqQEXpCm68cxufPp3HqLhF25sI_3iT0rBmI"}
response time: 5
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 30,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:13:44.087] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/art/getArticleDetail?id=5a0e8b7949b148371be1f96e
request client ip:  ::1
request query:  {"id":"5a0e8b7949b148371be1f96e"}
response time: 4
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 30,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:13:46.831] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/users/getUserInfo?userName=admin
request client ip:  ::1
request query:  {"userName":"admin"}
response time: 2
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"回复成功\",\n  \"data\": {\n    \"userName\": \"admin\",\n    \"registerTime\": \"2017-11-23T07:36:51.931Z\",\n    \"message\": []\n  }\n}"
*************** response log end ***************

[2017-12-01 12:13:46.847] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/art/updateCheckTimes
request client ip:  ::1
request body: 
{"id":"5a0e8b7949b148371be1f96e","token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxNTc2LCJleHAiOjE1MTIxNDQ3NzZ9.uKBuLKHhVqQEXpCm68cxufPp3HqLhF25sI_3iT0rBmI"}
response time: 7
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 31,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:13:46.851] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/art/getArticleDetail?id=5a0e8b7949b148371be1f96e
request client ip:  ::1
request query:  {"id":"5a0e8b7949b148371be1f96e"}
response time: 2
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 31,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:13:53.228] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/users/getUserInfo?userName=admin
request client ip:  ::1
request query:  {"userName":"admin"}
response time: 1
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"回复成功\",\n  \"data\": {\n    \"userName\": \"admin\",\n    \"registerTime\": \"2017-11-23T07:36:51.931Z\",\n    \"message\": []\n  }\n}"
*************** response log end ***************

[2017-12-01 12:13:53.241] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/art/updateCheckTimes
request client ip:  ::1
request body: 
{"id":"5a0e8b7949b148371be1f96e","token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxNTc2LCJleHAiOjE1MTIxNDQ3NzZ9.uKBuLKHhVqQEXpCm68cxufPp3HqLhF25sI_3iT0rBmI"}
response time: 6
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 32,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:13:53.243] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/art/getArticleDetail?id=5a0e8b7949b148371be1f96e
request client ip:  ::1
request query:  {"id":"5a0e8b7949b148371be1f96e"}
response time: 5
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 32,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:14:01.134] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/users/getUserInfo?userName=admin
request client ip:  ::1
request query:  {"userName":"admin"}
response time: 2
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"回复成功\",\n  \"data\": {\n    \"userName\": \"admin\",\n    \"registerTime\": \"2017-11-23T07:36:51.931Z\",\n    \"message\": []\n  }\n}"
*************** response log end ***************

[2017-12-01 12:14:01.145] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/art/updateCheckTimes
request client ip:  ::1
request body: 
{"id":"5a0e8b7949b148371be1f96e","token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxNTc2LCJleHAiOjE1MTIxNDQ3NzZ9.uKBuLKHhVqQEXpCm68cxufPp3HqLhF25sI_3iT0rBmI"}
response time: 5
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 33,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:14:01.150] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/art/getArticleDetail?id=5a0e8b7949b148371be1f96e
request client ip:  ::1
request query:  {"id":"5a0e8b7949b148371be1f96e"}
response time: 3
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 33,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:14:04.465] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/users/getUserInfo?userName=admin
request client ip:  ::1
request query:  {"userName":"admin"}
response time: 2
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"回复成功\",\n  \"data\": {\n    \"userName\": \"admin\",\n    \"registerTime\": \"2017-11-23T07:36:51.931Z\",\n    \"message\": []\n  }\n}"
*************** response log end ***************

[2017-12-01 12:14:04.478] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/art/updateCheckTimes
request client ip:  ::1
request body: 
{"id":"5a0e8b7949b148371be1f96e","token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxNTc2LCJleHAiOjE1MTIxNDQ3NzZ9.uKBuLKHhVqQEXpCm68cxufPp3HqLhF25sI_3iT0rBmI"}
response time: 5
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 34,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:14:04.480] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/art/getArticleDetail?id=5a0e8b7949b148371be1f96e
request client ip:  ::1
request query:  {"id":"5a0e8b7949b148371be1f96e"}
response time: 3
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 34,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:14:10.931] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/users/getUserInfo?userName=admin
request client ip:  ::1
request query:  {"userName":"admin"}
response time: 2
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"回复成功\",\n  \"data\": {\n    \"userName\": \"admin\",\n    \"registerTime\": \"2017-11-23T07:36:51.931Z\",\n    \"message\": []\n  }\n}"
*************** response log end ***************

[2017-12-01 12:14:10.941] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/art/updateCheckTimes
request client ip:  ::1
request body: 
{"id":"5a0e8b7949b148371be1f96e","token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxNTc2LCJleHAiOjE1MTIxNDQ3NzZ9.uKBuLKHhVqQEXpCm68cxufPp3HqLhF25sI_3iT0rBmI"}
response time: 4
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 35,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:14:10.944] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/art/getArticleDetail?id=5a0e8b7949b148371be1f96e
request client ip:  ::1
request query:  {"id":"5a0e8b7949b148371be1f96e"}
response time: 2
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 35,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:14:14.908] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/users/getUserInfo?userName=admin
request client ip:  ::1
request query:  {"userName":"admin"}
response time: 1
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"回复成功\",\n  \"data\": {\n    \"userName\": \"admin\",\n    \"registerTime\": \"2017-11-23T07:36:51.931Z\",\n    \"message\": []\n  }\n}"
*************** response log end ***************

[2017-12-01 12:14:14.921] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/art/updateCheckTimes
request client ip:  ::1
request body: 
{"id":"5a0e8b7949b148371be1f96e","token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxNTc2LCJleHAiOjE1MTIxNDQ3NzZ9.uKBuLKHhVqQEXpCm68cxufPp3HqLhF25sI_3iT0rBmI"}
response time: 6
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 36,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:14:14.922] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/art/getArticleDetail?id=5a0e8b7949b148371be1f96e
request client ip:  ::1
request query:  {"id":"5a0e8b7949b148371be1f96e"}
response time: 3
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 36,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:14:23.616] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/users/getUserInfo?userName=admin
request client ip:  ::1
request query:  {"userName":"admin"}
response time: 2
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"回复成功\",\n  \"data\": {\n    \"userName\": \"admin\",\n    \"registerTime\": \"2017-11-23T07:36:51.931Z\",\n    \"message\": []\n  }\n}"
*************** response log end ***************

[2017-12-01 12:14:23.628] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/art/updateCheckTimes
request client ip:  ::1
request body: 
{"id":"5a0e8b7949b148371be1f96e","token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxNTc2LCJleHAiOjE1MTIxNDQ3NzZ9.uKBuLKHhVqQEXpCm68cxufPp3HqLhF25sI_3iT0rBmI"}
response time: 5
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 37,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:14:23.631] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/art/getArticleDetail?id=5a0e8b7949b148371be1f96e
request client ip:  ::1
request query:  {"id":"5a0e8b7949b148371be1f96e"}
response time: 2
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 37,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:14:27.009] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/users/getUserInfo?userName=admin
request client ip:  ::1
request query:  {"userName":"admin"}
response time: 2
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"回复成功\",\n  \"data\": {\n    \"userName\": \"admin\",\n    \"registerTime\": \"2017-11-23T07:36:51.931Z\",\n    \"message\": []\n  }\n}"
*************** response log end ***************

[2017-12-01 12:14:27.024] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/art/updateCheckTimes
request client ip:  ::1
request body: 
{"id":"5a0e8b7949b148371be1f96e","token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxNTc2LCJleHAiOjE1MTIxNDQ3NzZ9.uKBuLKHhVqQEXpCm68cxufPp3HqLhF25sI_3iT0rBmI"}
response time: 5
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 38,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:14:27.026] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/art/getArticleDetail?id=5a0e8b7949b148371be1f96e
request client ip:  ::1
request query:  {"id":"5a0e8b7949b148371be1f96e"}
response time: 2
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 38,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:14:46.391] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/users/getUserInfo?userName=admin
request client ip:  ::1
request query:  {"userName":"admin"}
response time: 2
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"回复成功\",\n  \"data\": {\n    \"userName\": \"admin\",\n    \"registerTime\": \"2017-11-23T07:36:51.931Z\",\n    \"message\": []\n  }\n}"
*************** response log end ***************

[2017-12-01 12:14:46.403] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/art/updateCheckTimes
request client ip:  ::1
request body: 
{"id":"5a0e8b7949b148371be1f96e","token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxNTc2LCJleHAiOjE1MTIxNDQ3NzZ9.uKBuLKHhVqQEXpCm68cxufPp3HqLhF25sI_3iT0rBmI"}
response time: 4
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 39,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:14:46.405] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/art/getArticleDetail?id=5a0e8b7949b148371be1f96e
request client ip:  ::1
request query:  {"id":"5a0e8b7949b148371be1f96e"}
response time: 2
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 39,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:14:53.642] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/users/getUserInfo?userName=admin
request client ip:  ::1
request query:  {"userName":"admin"}
response time: 1
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"回复成功\",\n  \"data\": {\n    \"userName\": \"admin\",\n    \"registerTime\": \"2017-11-23T07:36:51.931Z\",\n    \"message\": []\n  }\n}"
*************** response log end ***************

[2017-12-01 12:14:53.655] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/art/updateCheckTimes
request client ip:  ::1
request body: 
{"id":"5a0e8b7949b148371be1f96e","token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxNTc2LCJleHAiOjE1MTIxNDQ3NzZ9.uKBuLKHhVqQEXpCm68cxufPp3HqLhF25sI_3iT0rBmI"}
response time: 5
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 40,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:14:53.657] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/art/getArticleDetail?id=5a0e8b7949b148371be1f96e
request client ip:  ::1
request query:  {"id":"5a0e8b7949b148371be1f96e"}
response time: 2
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 40,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:14:57.883] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/users/getUserInfo?userName=admin
request client ip:  ::1
request query:  {"userName":"admin"}
response time: 2
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"回复成功\",\n  \"data\": {\n    \"userName\": \"admin\",\n    \"registerTime\": \"2017-11-23T07:36:51.931Z\",\n    \"message\": []\n  }\n}"
*************** response log end ***************

[2017-12-01 12:14:57.900] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/art/updateCheckTimes
request client ip:  ::1
request body: 
{"id":"5a0e8b7949b148371be1f96e","token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxNTc2LCJleHAiOjE1MTIxNDQ3NzZ9.uKBuLKHhVqQEXpCm68cxufPp3HqLhF25sI_3iT0rBmI"}
response time: 10
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 41,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:14:57.903] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/art/getArticleDetail?id=5a0e8b7949b148371be1f96e
request client ip:  ::1
request query:  {"id":"5a0e8b7949b148371be1f96e"}
response time: 10
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 41,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:15:08.786] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/users/getUserInfo?userName=admin
request client ip:  ::1
request query:  {"userName":"admin"}
response time: 2
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"回复成功\",\n  \"data\": {\n    \"userName\": \"admin\",\n    \"registerTime\": \"2017-11-23T07:36:51.931Z\",\n    \"message\": []\n  }\n}"
*************** response log end ***************

[2017-12-01 12:15:08.798] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/art/updateCheckTimes
request client ip:  ::1
request body: 
{"id":"5a0e8b7949b148371be1f96e","token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxNTc2LCJleHAiOjE1MTIxNDQ3NzZ9.uKBuLKHhVqQEXpCm68cxufPp3HqLhF25sI_3iT0rBmI"}
response time: 5
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 42,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:15:08.801] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/art/getArticleDetail?id=5a0e8b7949b148371be1f96e
request client ip:  ::1
request query:  {"id":"5a0e8b7949b148371be1f96e"}
response time: 2
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 42,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:15:24.877] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/users/getUserInfo?userName=admin
request client ip:  ::1
request query:  {"userName":"admin"}
response time: 2
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"回复成功\",\n  \"data\": {\n    \"userName\": \"admin\",\n    \"registerTime\": \"2017-11-23T07:36:51.931Z\",\n    \"message\": []\n  }\n}"
*************** response log end ***************

[2017-12-01 12:15:24.890] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/art/updateCheckTimes
request client ip:  ::1
request body: 
{"id":"5a0e8b7949b148371be1f96e","token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxNTc2LCJleHAiOjE1MTIxNDQ3NzZ9.uKBuLKHhVqQEXpCm68cxufPp3HqLhF25sI_3iT0rBmI"}
response time: 5
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 43,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:15:24.893] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/art/getArticleDetail?id=5a0e8b7949b148371be1f96e
request client ip:  ::1
request query:  {"id":"5a0e8b7949b148371be1f96e"}
response time: 3
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 43,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:15:28.004] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/users/getUserInfo?userName=admin
request client ip:  ::1
request query:  {"userName":"admin"}
response time: 2
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"回复成功\",\n  \"data\": {\n    \"userName\": \"admin\",\n    \"registerTime\": \"2017-11-23T07:36:51.931Z\",\n    \"message\": []\n  }\n}"
*************** response log end ***************

[2017-12-01 12:15:28.030] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/art/updateCheckTimes
request client ip:  ::1
request body: 
{"id":"5a0e8b7949b148371be1f96e","token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxNTc2LCJleHAiOjE1MTIxNDQ3NzZ9.uKBuLKHhVqQEXpCm68cxufPp3HqLhF25sI_3iT0rBmI"}
response time: 5
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 44,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:15:28.032] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/art/getArticleDetail?id=5a0e8b7949b148371be1f96e
request client ip:  ::1
request query:  {"id":"5a0e8b7949b148371be1f96e"}
response time: 3
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 44,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:15:30.878] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/users/getUserInfo?userName=admin
request client ip:  ::1
request query:  {"userName":"admin"}
response time: 2
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"回复成功\",\n  \"data\": {\n    \"userName\": \"admin\",\n    \"registerTime\": \"2017-11-23T07:36:51.931Z\",\n    \"message\": []\n  }\n}"
*************** response log end ***************

[2017-12-01 12:15:30.899] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/art/updateCheckTimes
request client ip:  ::1
request body: 
{"id":"5a0e8b7949b148371be1f96e","token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxNTc2LCJleHAiOjE1MTIxNDQ3NzZ9.uKBuLKHhVqQEXpCm68cxufPp3HqLhF25sI_3iT0rBmI"}
response time: 4
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 45,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:15:30.902] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/art/getArticleDetail?id=5a0e8b7949b148371be1f96e
request client ip:  ::1
request query:  {"id":"5a0e8b7949b148371be1f96e"}
response time: 2
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 45,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:15:33.814] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/users/getUserInfo?userName=admin
request client ip:  ::1
request query:  {"userName":"admin"}
response time: 2
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"回复成功\",\n  \"data\": {\n    \"userName\": \"admin\",\n    \"registerTime\": \"2017-11-23T07:36:51.931Z\",\n    \"message\": []\n  }\n}"
*************** response log end ***************

[2017-12-01 12:15:33.830] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/art/updateCheckTimes
request client ip:  ::1
request body: 
{"id":"5a0e8b7949b148371be1f96e","token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxNTc2LCJleHAiOjE1MTIxNDQ3NzZ9.uKBuLKHhVqQEXpCm68cxufPp3HqLhF25sI_3iT0rBmI"}
response time: 5
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 46,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:15:33.832] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/art/getArticleDetail?id=5a0e8b7949b148371be1f96e
request client ip:  ::1
request query:  {"id":"5a0e8b7949b148371be1f96e"}
response time: 3
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 46,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:15:45.727] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/users/getUserInfo?userName=admin
request client ip:  ::1
request query:  {"userName":"admin"}
response time: 2
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"回复成功\",\n  \"data\": {\n    \"userName\": \"admin\",\n    \"registerTime\": \"2017-11-23T07:36:51.931Z\",\n    \"message\": []\n  }\n}"
*************** response log end ***************

[2017-12-01 12:15:45.739] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/art/updateCheckTimes
request client ip:  ::1
request body: 
{"id":"5a0e8b7949b148371be1f96e","token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxNTc2LCJleHAiOjE1MTIxNDQ3NzZ9.uKBuLKHhVqQEXpCm68cxufPp3HqLhF25sI_3iT0rBmI"}
response time: 4
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 47,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:15:45.742] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/art/getArticleDetail?id=5a0e8b7949b148371be1f96e
request client ip:  ::1
request query:  {"id":"5a0e8b7949b148371be1f96e"}
response time: 2
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 47,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:15:49.666] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/users/getUserInfo?userName=admin
request client ip:  ::1
request query:  {"userName":"admin"}
response time: 2
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"回复成功\",\n  \"data\": {\n    \"userName\": \"admin\",\n    \"registerTime\": \"2017-11-23T07:36:51.931Z\",\n    \"message\": []\n  }\n}"
*************** response log end ***************

[2017-12-01 12:15:49.677] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/art/updateCheckTimes
request client ip:  ::1
request body: 
{"id":"5a0e8b7949b148371be1f96e","token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxNTc2LCJleHAiOjE1MTIxNDQ3NzZ9.uKBuLKHhVqQEXpCm68cxufPp3HqLhF25sI_3iT0rBmI"}
response time: 4
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 48,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:15:49.680] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/art/getArticleDetail?id=5a0e8b7949b148371be1f96e
request client ip:  ::1
request query:  {"id":"5a0e8b7949b148371be1f96e"}
response time: 2
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 48,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:16:14.225] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/users/getUserInfo?userName=admin
request client ip:  ::1
request query:  {"userName":"admin"}
response time: 1
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"回复成功\",\n  \"data\": {\n    \"userName\": \"admin\",\n    \"registerTime\": \"2017-11-23T07:36:51.931Z\",\n    \"message\": []\n  }\n}"
*************** response log end ***************

[2017-12-01 12:16:14.240] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/art/updateCheckTimes
request client ip:  ::1
request body: 
{"id":"5a0e8b7949b148371be1f96e","token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxNTc2LCJleHAiOjE1MTIxNDQ3NzZ9.uKBuLKHhVqQEXpCm68cxufPp3HqLhF25sI_3iT0rBmI"}
response time: 8
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 49,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:16:14.242] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/art/getArticleDetail?id=5a0e8b7949b148371be1f96e
request client ip:  ::1
request query:  {"id":"5a0e8b7949b148371be1f96e"}
response time: 3
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-11-24T03:29:57.306Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 4,\n    \"viewed\": 49,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:16:19.057] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/upload/getMdFileContent
request client ip:  ::1
request body: 
{}
response time: 3
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"解析成功\",\n  \"data\": \"# Asynchronous Control Flow Patterns with ES2015 and Beyond\\n在上一章中，我们学习了如何使用回调处理异步代码，以及如何解决如回调地狱代码等异步问题。回调是`JavaScript`和`Node.js`中的异步编程的基础，但是现在，其他替代方案已经出现。这些替代方案更复杂，以便能够以更方便的方式处理异步代码。\\n\\n在本章中，我们将探讨一些代表性的替代方案，`Promise`和`Generator`。以及`async await`，这是一种创新的语法，可在高版本的`JavaScript`中提供，其也作为`ECMAScript 2017`发行版的一部分。\\n\\n我们将看到这些替代方案如何简化处理异步控制流的方式。最后，我们将比较所有这些方法，以了解所有这些方法的所有优点和缺点，并能够明智地选择最适合我们下一个`Node.js`项目要求的方法。\\n\\n## Promise\\n我们在前面的章节中提到，`CPS风格`不是编写异步代码的唯一方法。事实上，`JavaScript`生态系统为传统的回调模式提供了有趣的替代方案。最着名的选择之一是`Promise`，特别是现在它是`ECMAScript 2015`的一部分，并且现在可以在`Node.js`中可用。\\n\\n### 什么是Promise？\\n`Promise`是一种抽象的对象，我们通常允许函数返回一个名为`Promise`的对象，它表示异步操作的最终结果。通常情况下，我们说当异步操作尚未完成时，我们说`Promise`对象处于`pending`状态，当操作成功完成时，我们说`Promise`对象处于`resolve`状态，当操作错误终止时，我们说`Promise`对象处于`reject`状态。一旦`Promise`处于`resolve`或`reject`，我们认为当前异步操作结束。\\n\\n为了接收到异步操作的正确结果或错误捕获，我们可以使用`Promise`的`then`方法：\\n\\n```javascript\\npromise.then([onFulfilled], [onRejected])\\n```\\n\\n在前面的代码中，`onFulfilled()`是一个函数，最终会收到`Promise`的正确结果，而`onRejected()`是另一个函数，它将接收产生异常的原因（如果有的话）。两个参数都是可选的。\\n\\n要了解`Promise`如何转换我们的代码，让我们考虑以下几点：\\n\\n```javascript\\nasyncOperation(arg, (err, result) => {\\n  if (err) {\\n    // 错误处理\\n  }\\n  // 正常结果处理\\n});\\n```\\n\\n`Promise`允许我们将这个典型的`CPS`代码转换成更好的结构化和更优雅的代码，如下所示：\\n\\n```javascript\\nasyncOperation(arg)\\n  .then(result => {\\n    // 错误处理\\n  }, err => {\\n    // 正常结果处理\\n  });\\n```\\n\\n`then()`方法的一个关键特征是它同步地返回另一个`Promise`对象。如果`onFulfilled()`或`onRejected()`函数中的任何一个函数返回`x`，则`then()`方法返回的`Promise`对象将如下所示：\\n\\n* 如果`x`是一个值，则这个`Promise`对象会正确处理(`resolve`)`x`\\n* 如果`x`是一个`Promise`对象或`thenable`，则会正确处理(`resolve`)`x`\\n* 如果`x`是一个异常，则会捕获异常(`reject`)`x`\\n\\n> 注：thenable是一个具有then方法的类似于Promise的对象(Promise-like)。\\n\\n这个特点使我们能够链式构建`Promise`，允许轻松排列组合我们的异步操作。另外，如果我们没有指定一个`onFulfilled()`或`onRejected()`处理程序，则正确结果或异常捕获将自动转发到`Promise`链的下一个`Promise`。例如，这允许我们在整个链中自动传播错误，直到被`onRejected()`处理程序捕获。随着`Promise`链，任务的顺序执行突然变成简单多了：\\n\\n```javascript\\nasyncOperation(arg)\\n  .then(result1 => {\\n    // 返回另一个Promise\\n    return asyncOperation(arg2);\\n  })\\n  .then(result2 => {\\n    // 返回一个值\\n    return 'done';\\n  })\\n  .then(undefined, err => {\\n    // 捕获Promise链中的异常\\n  });\\n```\\n\\n下图展示了链式`Promise`如何工作：\\n\\n![](http://oczira72b.bkt.clouddn.com/17-10-31/46370382.jpg)\\n\\n`Promise`的另一个重要特性是`onFulfilled()`和`onRejected()`函数是异步调用的，如同上述的例子，在最后那个`then`函数`resolve`一个同步的`Promise`，它也是同步的。这种模式避免了`Zalgo`（参见`Chapter2-Node.js Essential Patterns`），使我们的异步代码更加一致和稳健。\\n\\n如果在`onFulfilled()`或`onRejected()`处理程序中抛出异常（使用`throw`语句），则`then()`方法返回的`Promise`将被自动地`reject`，抛出异常作为`reject`的原因。这相对于`CPS`来说是一个巨大的优势，因为它意味着有了`Promise`，异常将在整个链中自动传播，并且`throw`语句终于可以使用。\\n\\n在以前，许多不同的库实现了`Promise`，大多数时候它们之间不兼容，这意味着不可能在使用不同`Promise`库的`thenable`链式传播错误。\\n\\n`JavaScript`社区非常努力地解决了这个限制，这些努力导致了`Promises / A +`规范的创建。该规范详细描述了`then`方法的行为，提供了一个可互兼容的基础，这使得来自不同库的`Promise`对象能够彼此兼容，开箱即用。\\n\\n有关`Promises / A +`规范的详细说明，可以参考[Promises / A + 官方网站](https://promisesaplus.com)。\\n\\n### Promise / A + 的实施\\n在`JavaScript`中以及`Node.js`中，有几个实现`Promises / A +`规范的库。以下是最受欢迎的：\\n\\n* [Bluebird](https://npmjs.org/package/bluebird)\\n* [Q](https://npmjs.org/package/q)\\n* [RSVP](https://npmjs.org/package/rsvp)\\n* [Vow](https://npmjs.org/package/vow)\\n* [When.js](https://npmjs.org/package/when)\\n* ES2015 promises\\n\\n真正区别他们的是在`Promises / A +`标准之上提供的额外功能。正如我们上述所说的那样，该标准定义了`then()`方法和`Promise`解析过程的行为，但它没有指定其他功能，例如，如何从基于回调的异步函数创建`Promise`。\\n\\n在我们的示例中，我们将使用由`ES2015`的`Promise`，因为`Promise`对象自`Node.js 4`后即可使用，而不需要任何库来实现。\\n\\n作为参考，以下是`ES2015`的`Promise`提供的API：\\n\\n`constructor`(`new Promise（function（resolve, reject）{}）`)：创建了一个新的`Promise`，它基于作为传递两个类型为函数的参数来决定`resolve`或`reject`。构造函数的参数解释如下：\\n\\n* `resolve(obj)` ：`resolve`一个`Promise`，并带上一个参数`obj`，如果`obj`是一个值，这个值就是传递的异步操作成功的结果。如果`obj`是一个`Promise`或一个`thenable`，则会进行正确处理。\\n* `reject(err)`：`reject`一个`Promise`，并带上一个参数`err`。它是`Error`对象的一个实例。\\n\\n#### Promise对象的静态方法\\n* `Promise.resolve(obj)`： 将会创建一个`resolve`的`Promise`实例\\n* `Promise.reject(err)`： 将会创建一个`reject`的`Promise`实例\\n* `Promise.all(iterable)`：返回一个新的`Promise`实例，并且在`iterable`中所\\n有`Promise`状态为`reject`时, 返回的`Promise`实例的状态会被置为`reject`，如果`iterable`中至少有一个`Promise`状态为`reject`时, 返回的`Promise`实例状态也会被置为`reject`，并且`reject`的原因是第一个被`reject`的`Promise`对象的`reject`原因。\\n* `Promise.race(iterable)`：返回一个`Promise`实例，当`iterable`中任何一个`Promise`被`resolve`或被`reject`时， 返回的`Promise`实例以同样的原因`resolve`或`reject`。\\n\\n#### Promise实例方法\\n* `Promise.then(onFulfilled, onRejected)`：这是`Promise`的基本方法。它的行为与我们之前描述的`Promises / A +`标准兼容。\\n* `Promise.catch(onRejected)`：这只是`Promise.then(undefined，onRejected)`的语法糖。\\n\\n> 值得一提的是，一些Promise实现提供了另一种机制来创建新的Promise，称为deferreds。我们不会在这里描述，因为它不是ES2015标准的一部分，但是如果您想了解更多信息，可以阅读Q文档 (https://github.com/kriskowal/q#using-deferreds) 或When.js文档 (https://github.com/cujojs/when/wiki/Deferred) 。\\n\\n### Promisifying一个Node.js回调风格的函数\\n在`JavaScript`中，并不是所有的异步函数和库都支持开箱即用的`Promise`。大多数情况下，我们必须将一个典型的基于回调的函数转换成一个返回`Promise`的函数，这个过程也被称为`promisification`。\\n\\n幸运的是，`Node.js`中使用的回调约定允许我们创建一个可重用的函数，我们通过使用`Promise`对象的构造函数来简化任何`Node.js`风格的`API`。让我们创建一个名为`promisify()`的新函数，并将其包含到`utilities.js`模块中（以便稍后在我们的`Web爬虫应用程序`中使用它）：\\n\\n```javascript\\nmodule.exports.promisify = function(callbackBasedApi) {\\n  return function promisified() {\\n    const args = [].slice.call(arguments);\\n    return new Promise((resolve, reject) => {\\n      args.push((err, result) => {\\n        if (err) {\\n          return reject(err);\\n        }\\n        if (arguments.length <= 2) {\\n          resolve(result);\\n        } else {\\n          resolve([].slice.call(arguments, 1));\\n        }\\n      });\\n      callbackBasedApi.apply(null, args);\\n    });\\n  }\\n};\\n```\\n\\n前面的函数返回另一个名为`promisified()`的函数，它表示输入中给出的`callbackBasedApi`的`promisified`版本。以下展示它是如何工作的：\\n\\n1. `promisified()`函数使用`Promise`构造函数创建一个新的`Promise`对象，并立即将其返回给调用者。\\n2. 在传递给`Promise`构造函数的函数中，我们确保传递给`callbackBasedApi`，这是一个特殊的回调函数。由于我们知道回调总是最后调用的，我们只需将回调函数附加到提供给`promisified()`函数的参数列表里（`args`）。\\n3. 在特殊的回调中，如果我们收到错误，我们立即`reject`这个`Promise`。\\n4. 如果没有收到错误，我们使用一个值或一个数组值来`resolve`这个`Promise`，具体取决于传递给回调的结果数量。\\n5. 最后，我们只需使用我们构建的参数列表调用`callbackBasedApi`。\\n\\n> 大部分的Promise已经提供了一个开箱即用的接口来将一个Node.js风格的API转换成一个返回Promise的API。例如，Q有Q.denodeify()和Q.nbind()，Bluebird有Promise.promisify()，而When.js有node.lift()。\\n\\n### 顺序执行\\n在一些必要的理论之后，我们现在准备将我们的`Web爬虫应用程序`转换为使用`Promise`的形式。让我们直接从版本2开始，直接下载一个Web网页的链接。\\n\\n在`spider.js`模块中，第一步是加载我们的`Promise`实现（我们稍后会使用它）和`Promisifying`我们打算使用的基于回调的函数：\\n\\n```javascript\\nconst utilities = require('./utilities');\\nconst request = utilities.promisify(require('request'));\\nconst mkdirp = utilities.promisify(require('mkdirp'));\\nconst fs = require('fs');\\nconst readFile = utilities.promisify(fs.readFile);\\nconst writeFile = utilities.promisify(fs.writeFile);\\n```\\n\\n现在，我们开始更改我们的`download`函数：\\n\\n```javascript\\nfunction download(url, filename) {\\n  console.log(`Downloading ${url}`);\\n  let body;\\n  return request(url)\\n    .then(response => {\\n      body = response.body;\\n      return mkdirp(path.dirname(filename));\\n    })\\n    .then(() => writeFile(filename, body))\\n    .then(() => {\\n      console.log(`Downloaded and saved: ${url}`);\\n      return body;\\n    });\\n}\\n```\\n\\n这里要注意的到的最重要的是我们也为`readFile()`返回的`Promise`注册\\n一个`onRejected()`函数，用来处理一个网页没有被下载的情况(或文件不存在)。 还有，看我们如何使用`throw`来传递`onRejected()`函数中的错误的。\\n\\n既然我们已经更改我们的`spider()`函数，我们这么修改它的调用方式：\\n\\n```javascript\\nspider(process.argv[2], 1)\\n  .then(() => console.log('Download complete'))\\n  .catch(err => console.log(err));\\n```\\n\\n注意我们是如何第一次使用`Promise`的语法糖`catch`来处理源自`spider()`函数的任何错误情况。如果我们再看看迄今为止我们所写的所有代码，那么我们会惊喜的发现，我们没有包含任何错误传播逻辑，因为我们在使用回调函数时会被迫做这样的事情。这显然是一个巨大的优势，因为它极大地减少了我们代码中的样板文件以及丢失任何异步错误的机会。\\n\\n现在，完成我们唯一缺失的`Web爬虫应用程序`的第二版的`spiderLinks()`函数，我们将在稍后实现它。\\n\\n### 顺序迭代\\n到目前为止，`Web爬虫应用程序`代码库主要是对`Promise`是什么以及如何使用的概述，展示了使用`Promise`实现顺序执行流程的简单性和优雅性。但是，我们现在考虑的代码只涉及到一组已知的异步操作的执行。所以，完成我们对顺序执行流程的探索的缺失部分是看我们如何使用`Promise`来实现迭代。同样，网络蜘蛛第二版的`spiderLinks()`函数也是一个很好的例子。\\n\\n让我们添加缺少的这一块：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  let promise = Promise.resolve();\\n  if (nesting === 0) {\\n    return promise;\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  links.forEach(link => {\\n    promise = promise.then(() => spider(link, nesting - 1));\\n  });\\n  return promise;\\n}\\n```\\n\\n为了异步迭代一个网页的全部链接，我们必须动态创建一个`Promise`的迭代链。\\n\\n1. 首先，我们定义一个空的`Promise`，`resolve`为`undefined`。这个`Promise`只是用来作为`Promise`的迭代链的起始点。 \\n2. 然后，我们通过在循环中调用链中前一个`Promise`的`then()`方法获得的新的`Promise`来更新`Promise`变量。这就是我们使用`Promise`的异步迭代模式。\\n\\n这样，循环的结束，`promise`变量会包含循环中最后一个`then()`返回的`Promise`对象，所以它只有当`Promise`的迭代链中全部`Promise`对象被`resolve`后才能被`resolve`。\\n\\n> 注：在最后调用了这个then方法来resolve这个Promise对象\\n\\n通过这个，我们已使用`Promise`对象重写了我们的`Web爬虫应用程序`。我们现在应该可以运行它了。\\n\\n### 顺序迭代模式\\n为了总结这个顺序执行的部分，让我们提取一个模式来依次遍历一组`Promise`：\\n\\n```javascript\\nlet tasks = [ /* ... */ ]\\nlet promise = Promise.resolve();\\ntasks.forEach(task => {\\n  promise = promise.then(() => {\\n    return task();\\n  });\\n});\\npromise.then(() => {\\n  // 所有任务都完成\\n});\\n```\\n\\n使用`reduce()`方法来替代`forEach()`方法，允许我们写出更为简洁的代码：\\n\\n```javascript\\nlet tasks = [ /* ... */ ]\\nlet promise = tasks.reduce((prev, task) => {\\n  return prev.then(() => {\\n    return task();\\n  });\\n}, Promise.resolve());\\n\\npromise.then(() => {\\n  //All tasks completed\\n});\\n```\\n\\n与往常一样，通过对这种模式的简单调整，我们可以将所有任务的结果收集到一个数组中，我们可以实现一个`mapping`算法，或者构建一个`filter`等等。\\n\\n> 上述这个模式使用循环动态地建立一个链式的Promise。\\n\\n### 并行执行\\n另一个适合用`Promise`的执行流程是并行执行流程。实际上，我们需要做的就是使用内置的`Promise.all()`。这个方法创造了另一个`Promise`对象，只有在输入中的所有`Promise`都`resolve`时才能`resolve`。这是一个并行执行，因为在其参数`Promise`对象的之间没有执行顺序可言。\\n\\n为了演示这一点，我们来看我们的`Web爬虫应用程序`的第三版，它将页面中的所有链接并行下载。让我们再次使用`Promise`更新`spiderLinks()`函数来实现并行流程：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return Promise.resolve();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  const promises = links.map(link => spider(link, nesting - 1));\\n  return Promise.all(promises);\\n}\\n```\\n\\n这里的模式在`elements.map()`迭代中产生一个数组，存放所有异步任务，之后便于同时启动`spider()`任务。这一次，在循环中，我们不等待以前的下载完成，然后开始一个新的下载任务：所有的下载任务在一个循环中一个接一个地开始。之后，我们利用`Promise.all()`方法，它返回一个新的`Promise`对象，当数组中的所有`Promise`对象都被`resolve`时，这个`Promise`对象将被`resolve`。换句话说，所有的下载任务完成，这正是我们想要的。\\n\\n### 限制并行执行\\n不幸的是，`ES2015`的`Promise API`并没有提供一种原生的方式来限制并发任务的数量，但是我们总是可以依靠我们所学到的有关用普通`JavaScript`来限制并发。事实上，我们在`TaskQueue`类中实现的模式可以很容易地被调整来支持返回承诺的任务。这很容易通过修改`next()`方法来完成：\\n\\n```javascript\\nclass TaskQueue {\\n  constructor(concurrency) {\\n    this.concurrency = concurrency;\\n    this.running = 0;\\n    this.queue = [];\\n  }\\n\\n  pushTask(task) {\\n    this.queue.push(task);\\n    this.next();\\n  }\\n\\n  next() {\\n    while (this.running < this.concurrency && this.queue.length) {\\n      const task = this.queue.shift();\\n      task().then(() => {\\n        this.running--;\\n        this.next();\\n      });\\n      this.running++;\\n    }\\n  }\\n}\\n```\\n\\n不同于使用一个回调函数来处理任务，我们简单地调用`Promise`的`then()`。\\n\\n让我们回到`spider.js`模块，并修改它以支持我们的新版本的`TaskQueue`类。首先，我们确保定义一个`TaskQueue`的新实例：\\n\\n```javascript\\nconst TaskQueue = require('./taskQueue');\\nconst downloadQueue = new TaskQueue(2);\\n```\\n\\n然后，是我们的`spiderLinks()`函数。这里的修改也是很简单：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return Promise.resolve();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  // 我们需要如下代码，用于创建Promise对象\\n  // 如果没有下列代码，当任务数量为0时，将永远不会resolve\\n  if (links.length === 0) {\\n    return Promise.resolve();\\n  }\\n  return new Promise((resolve, reject) => {\\n    let completed = 0;\\n    let errored = false;\\n    links.forEach(link => {\\n      let task = () => {\\n        return spider(link, nesting - 1)\\n          .then(() => {\\n            if (++completed === links.length) {\\n              resolve();\\n            }\\n          })\\n          .catch(() => {\\n            if (!errored) {\\n              errored = true;\\n              reject();\\n            }\\n          });\\n      };\\n      downloadQueue.pushTask(task);\\n    });\\n  });\\n}\\n```\\n\\n在上述代码中有几点值得我们注意的：\\n\\n* 首先，我们需要返回使用`Promise`构造函数创建的新的`Promise`对象。正如我们将看到的，这使我们能够在队列中的所有任务完成时手动`resolve`我们的`Promise`对象。\\n* 然后，我们应该看看我们如何定义任务。我们所做的是将一个`onFulfilled()`回调函数的调用添加到由`spider()`返回的`Promise`对象中，所以我们可以计算完成的下载任务的数量。当完成的下载量与当前页面中链接的数量相同时，我们知道任务已经处理完毕，所以我们可以调用外部`Promise`的`resolve()`函数。\\n\\n> Promises / A +规范规定，then()方法的onFulfilled()和onRejected()回调函数只能调用一次（仅调用onFulfilled()和onRejected()）。Promise接口的实现确保即使我们多次手动调用resolve或reject，Promise也仅可以被resolve或reject一次。\\n\\n现在，使用`Promise`的`Web爬虫应用程序`的第4版应该已经准备好了。我们可能再次注意到下载任务如何并行运行，并发数量限制为2。\\n\\n### 在公有API中暴露回调函数和Promise\\n正如我们在前面所学到的，`Promise`可以被用作回调函数的一个很好的替代品。它们使我们的代码更具可读性和易于理解。虽然`Promise`带来了许多优点，但也要求开发人员理解许多不易于理解的概念，以便正确和熟练地使用。由于这个原因和其他原因，在某些情况下，比起`Promise`来说，很多开发者更偏向于回调函数。\\n\\n现在让我们想象一下，我们想要构建一个执行异步操作的公共库。我们需要做什么？我们是创建了一个基于回调函数的`API`还是一个面向`Promise`的`API`？还是两者均有？\\n\\n这是许多知名的库所面临的问题，至少有两种方法值得一提，使我们能够提供一个多功能的`API`。\\n\\n像`request`，`redis`和`mysql`这样的库所使用的第一种方法是提供一个简单的基于回调函数的`API`，如果需要，开发人员可以选择公开函数。其中一些库提供工具函数来`Promise`化异步回调，但开发人员仍然需要以某种方式将暴露的`API`转换为能够使用`Promise`对象。\\n\\n第二种方法更透明。它还提供了一个面向回调的`API`，但它使回调参数可选。每当回调作为参数传递时，函数将正常运行，在完成时或失败时执行回调。当回调未被传递时，函数将立即返回一个`Promise`对象。这种方法有效地结合了回调函数和`Promise`，使得开发者可以在调用时选择采用什么接口，而不需要提前进行`Promise`化。许多库，如`mongoose`和`sequelize`，都支持这种方法。\\n\\n我们来看一个简单的例子。假设我们要实现一个异步执行除法的模块：\\n\\n```javascript\\nmodule.exports = function asyncDivision(dividend, divisor, cb) {\\n  return new Promise((resolve, reject) => { // [1]\\n    process.nextTick(() => {\\n      const result = dividend / divisor;\\n      if (isNaN(result) || !Number.isFinite(result)) {\\n        const error = new Error('Invalid operands');\\n        if (cb) {\\n          cb(error); // [2]\\n        }\\n        return reject(error);\\n      }\\n      if (cb) {\\n        cb(null, result); // [3]\\n      }\\n      resolve(result);\\n    });\\n  });\\n};\\n```\\n\\n该模块的代码非常简单，但是有一些值得强调的细节：\\n\\n* 首先，返回使用`Promise`的构造函数创建的新承诺。我们在构造函数参数函数内定义全部逻辑。\\n* 在发生错误的情况下，我们`reject`这个`Promise`，但如果回调函数在被调用时作为参数传递，我们也执行回调来进行错误传播。\\n* 在计算结果之后，我们`resolve`了这个`Promise`，但是如果有回调函数，我们也会将结果传播给回调函数。\\n\\n我们现在看如何用回调函数和`Promise`来使用这个模块：\\n\\n```javascript\\n// 回调函数的方式\\nasyncDivision(10, 2, (error, result) => {\\n  if (error) {\\n    return console.error(error);\\n  }\\n  console.log(result);\\n});\\n\\n// Promise化的调用方式\\nasyncDivision(22, 11)\\n  .then(result => console.log(result))\\n  .catch(error => console.error(error));\\n```\\n\\n应该很清楚的是，即将开始使用类似于上述的新模块的开发人员将很容易地选择最适合自己需求的风格，而无需在希望利用`Promise`时引入外部`promisification`功能。\\n\\n## Generators\\n`ES2015`规范引入了另外一种机制，除了其他新功能外，还可以用来简化`Node.js`应用程序的异步控制流程。我们正在谈论`Generator`，也被称为`semi-coroutines`。它们是子程序的一般化，可以有不同的入口点。在一个正常的函数中，实际上我们只能有一个入口点，这个入口点对应着函数本身的调用。`Generator`与一般函数类似，但是可以暂停（使用`yield`语句），然后在稍后继续执行。在实现迭代器时，`Generator`特别有用，因为我们已经讨论了如何使用迭代器来实现重要的异步控制流模式，如顺序执行和限制并行执行。\\n\\n### Generators基础\\n在我们探索使用`Generator`来实现异步控制流程之前，学习一些基本概念是很重要的。我们从语法开始吧。可以通过在函数关键字之后附加`*`（星号）运算符来声明`Generator`函数：\\n\\n```javascript\\nfunction* makeGenerator() {\\n  // body\\n}\\n```\\n\\n在`makeGenerator()`函数内部，我们可以使用关键字`yield`暂停执行并返回给调用者传递给它的值：\\n\\n```javascript\\nfunction* makeGenerator() {\\n  yield 'Hello World';\\n  console.log('Re-entered');\\n}\\n```\\n\\n在前面的代码中，`Generator`通过`yield`一个字符串`Hello World`暂停当前函数的执行。当`Generator`恢复时，执行将从下列语句开始：\\n\\n```javascript\\nconsole.log('Re-entered');\\n```\\n\\n`makeGenerator()`函数本质上是一个工厂，它在被调用时返回一个新的`Generator`对象：\\n\\n```javascript\\nconst gen = makeGenerator();\\n```\\n\\n生成器对象的最重要的方法是`next()`，它用于启动/恢复`Generator`的执行，并返回如下形式的对象：\\n\\n```\\n{\\n  value: <yielded value>\\n  done: <true if the execution reached the end>\\n}\\n```\\n\\n这个对象包含`Generator` `yield`的值和一个指示`Generator`是否已经完成执行的符号。\\n\\n### 一个简单的例子\\n为了演示`Generator`，我们来创建一个名为`fruitGenerator.js`的新模块：\\n\\n```javascript\\nfunction* fruitGenerator() {\\n  yield 'apple';\\n  yield 'orange';\\n  return 'watermelon';\\n}\\nconst newFruitGenerator = fruitGenerator();\\nconsole.log(newFruitGenerator.next()); // [1]\\nconsole.log(newFruitGenerator.next()); // [2]\\nconsole.log(newFruitGenerator.next()); // [3]\\n```\\n\\n前面的代码将打印下面的输出：\\n\\n```\\n{ value: 'apple', done: false }\\n{ value: 'orange', done: false }\\n{ value: 'watermelon', done: true }\\n```\\n\\n我们可以这么解释上述现象：\\n\\n* 第一次调用`newFruitGenerator.next()`时，`Generator`函数开始执行，直到达到第一个`yield`语句为止，该命令暂停`Generator`函数执行，并将值`apple`返回给调用者。\\n* 在第二次调用`newFruitGenerator.next()`时，`Generator`函数恢复执行，从第二个`yield`语句开始，这又使得执行暂停，同时将`orange`返回给调用者。\\n* `newFruitGenerator.next()`的最后一次调用导致`Generator`函数的执行从其最后的`yield`恢复，一个返回语句，它终止`Generator`函数，返回`watermelon`，并将结果对象中的`done`属性设置为`true`。\\n\\n### Generators作为迭代器\\n为了更好地理解为什么`Generator`函数对实现迭代器非常有用，我们来构建一个例子。在我们将调用`iteratorGenerator.js`的新模块中，我们编写下面的代码：\\n\\n```javascript\\nfunction* iteratorGenerator(arr) {\\n  for (let i = 0; i < arr.length; i++) {\\n    yield arr[i];\\n  }\\n}\\nconst iterator = iteratorGenerator(['apple', 'orange', 'watermelon']);\\nlet currentItem = iterator.next();\\nwhile (!currentItem.done) {\\n  console.log(currentItem.value);\\n  currentItem = iterator.next();\\n}\\n```\\n\\n此代码应按如下所示打印数组中的元素：\\n\\n```\\napple\\norange\\nwatermelon\\n```\\n\\n在这个例子中，每次我们调用`iterator.next()`时，我们都会恢复`Generator`函数的`for`循环，通过`yield`数组中的下一个项来运行另一个循环。这演示了如何在函数调用过程中维护`Generator`的状态。当继续执行时，循环和所有变量的值与`Generator`函数执行暂停时的状态完全相同。\\n\\n### 传值给Generators\\n现在我们继续研究`Generator`的基本功能，首先学习如何将值传递回`Generator`函数。这其实很简单，我们需要做的只是为`next()`方法提供一个参数，并且该值将作为`Generator`函数内的`yield`语句的返回值提供。\\n\\n为了展示这一点，我们来创建一个新的简单模块：\\n\\n```javascript\\nfunction* twoWayGenerator() {\\n  const what = yield null;\\n  console.log('Hello ' + what);\\n}\\nconst twoWay = twoWayGenerator();\\ntwoWay.next();\\ntwoWay.next('world');\\n```\\n\\n当执行时，前面的代码会输出`Hello world`。我们做如下的解释：\\n\\n* 第一次调用`next()`方法时，`Generator`函数到达第一个`yield`语句，然后暂停。\\n* 当`next('world')`被调用时，`Generator`函数从上次停止的位置，也就是上次的`yield`语句点恢复，但是这次我们有一个值传递到`Generator`函数。这个值将被赋值到`what`变量。生成器然后执行`console.log()`指令并终止。\\n\\n用类似的方式，我们可以强制`Generator`函数抛出异常。这可以通过使用`Generator`函数的`throw`方法来实现，如下例所示：\\n\\n```javascript\\nconst twoWay = twoWayGenerator();\\ntwoWay.next();\\ntwoWay.throw(new Error());\\n```\\n\\n在这个最后这段代码，`twoWayGenerator()`函数将在`yield`函数返回的时候抛出异常。这就好像从`Generator`函数内部抛出了一个异常一样，这意味着它可以像使用`try ... catch`块一样进行捕获和处理异常。\\n\\n### Generator实现异步控制流\\n你一定想知道`Generator`函数如何帮助我们处理异步操作。我们可以通过创建一个接受`Generator`函数作为参数的特殊函数来演示这一点，并允许我们在`Generator`函数内部使用异步代码。这个函数在异步操作完成时要注意恢复`Generator`函数的执行。我们将调用这个函数`asyncFlow()`：\\n\\n```javascript\\nfunction asyncFlow(generatorFunction) {\\n  function callback(err) {\\n    if (err) {\\n      return generator.throw(err);\\n    }\\n    const results = [].slice.call(arguments, 1);\\n    generator.next(results.length > 1 ? results : results[0]);\\n  }\\n  const generator = generatorFunction(callback);\\n  generator.next();\\n}\\n```\\n\\n前面的函数取一个`Generator`函数作为输入，然后立即调用：\\n\\n```javascript\\nconst generator = generatorFunction(callback);\\ngenerator.next();\\n```\\n\\n`generatorFunction()`接受一个特殊的回调函数作为参数，当`generator.throw()`如果接收到一个错误，便立即返回。另外，通过将在回调函数中接收的`results`传值回`Generator`函数继续`Generator`函数的执行:\\n\\n```javascript\\nif (err) {\\n  return generator.throw(err);\\n}\\nconst results = [].slice.call(arguments, 1);\\ngenerator.next(results.length > 1 ? results : results[0]);\\n```\\n\\n为了说明这个简单的辅助函数的强大，我们创建一个叫做`clone.js`的新模块，这个模块只是创建它本身的克隆。粘贴我们刚才创建的`asyncFlow()`函数，核心代码如下：\\n\\n```javascript\\nconst fs = require('fs');\\nconst path = require('path');\\nasyncFlow(function*(callback) {\\n  const fileName = path.basename(__filename);\\n  const myself = yield fs.readFile(fileName, 'utf8', callback);\\n  yield fs.writeFile(`clone_of_${filename}`, myself, callback);\\n  console.log('Clone created');\\n});\\n```\\n\\n明显地，有了`asyncFlow()`函数的帮助，我们可以像我们书写同步阻塞函数一样用同步的方式来书写异步代码了。并且这个结果背后的原理显得很清楚。一旦异步操作结束，传递给每个异步函数的回调函数将继续`Generator`函数的执行。没有什么复杂的，但是结果确实很令人意外。\\n\\n这个技术有其他两个变化，一个是`Promise`的使用，另外一个则是`thunks`。\\n\\n> 在基于Generator的控制流中使用的thunk只是一个简单的函数，它除了回调之外，部分地应用了原始函数的所有参数。返回值是另一个只接受回调作为参数的函数。例如，fs.readFile（）的thunkified版本如下所示：\\n\\n```javascript\\nfunction readFileThunk(filename, options) {\\n  return function(callback) {\\n    fs.readFile(filename, options, callback);\\n  }\\n}\\n```\\n\\n`thunk`和`Promise`都允许我们创建不需要回调的`Generator`函数作为参数传递，例如，使用`thunk`的`asyncFlow()`版本如下：\\n\\n```javascript\\nfunction asyncFlowWithThunks(generatorFunction) {\\n  function callback(err) {\\n    if (err) {\\n      return generator.throw(err);\\n    }\\n    const results = [].slice.call(arguments, 1);\\n    const thunk = generator.next(results.length > 1 ? results : results[0]).value;\\n    thunk && thunk(callback);\\n  }\\n  const generator = generatorFunction();\\n  const thunk = generator.next().value;\\n  thunk && thunk(callback);\\n}\\n```\\n\\n这个技巧是读取`generator.next()`的返回值，返回值中包含`thunk`。下一步是通过注入特殊的回调函数调用`thunk`本身。这允许我们写下面的代码：\\n\\n```javascript\\nasyncFlowWithThunk(function*() {\\n  const fileName = path.basename(__filename);\\n  const myself = yield readFileThunk(__filename, 'utf8');\\n  yield writeFileThunk(`clone_of_${fileName}`, myself);\\n  console.log(\\\"Clone created\\\")\\n});\\n```\\n\\n### 使用co的基于Gernator的控制流\\n你应该已经猜到了，`Node.js`生态系统会借助`Generator`函数来提供一些处理异步控制流的解决方案，例如，[suspend](https://npm/js.org/package/suspend)是其中一个最老的支持`Promise`、`thunks`和`Node.js`风格回调函数和正常风格的回调函数的 库。还有，大部分我们之前分析的`Promise`库都提供工具函数使得`Generator`和`Promise`可以一起使用。\\n\\n我们选择[co](https://npmjs.org/package/co)作为本章节的例子。它支持很多类型的`yieldables`，其中一些是：\\n\\n* `Thunks`\\n* `Promises`\\n* `Arrays`(并行执行)\\n* `Objects`(并行执行)\\n* `Generators`(委托)\\n* `Generator`函数(委托)\\n\\n还有很多框架或库是基于`co`生态系统的，包括以下一些：\\n\\n* `Web框架`，最流行的是[koa](https://npmjs.org/package/koa)\\n* 实现特定控制流模式的库\\n* 包装流行的`API`兼容`co`的库\\n\\n我们使用`co`重新实现我们的`Generator`版本的`Web爬虫应用程序`。\\n\\n为了将`Node.js`风格的函数转换成`thunks`，我们将会使用一个叫做[thunkify](https://npmjs.org/package/thunkify)的库。\\n\\n### 顺序执行\\n让我们通过修改`Web爬虫应用程序`的版本2开始我们对`Generator`函数和`co`的实际探索。我们要做的第一件事就是加载我们的依赖包，并生成我们要使用的函数的`thunkified`版本。这些将在`spider.js`模块的最开始进行：\\n\\n```javascript\\nconst thunkify = require('thunkify');\\nconst co = require('co');\\nconst request = thunkify(require('request'));\\nconst fs = require('fs');\\nconst mkdirp = thunkify(require('mkdirp'));\\nconst readFile = thunkify(fs.readFile);\\nconst writeFile = thunkify(fs.writeFile);\\nconst nextTick = thunkify(process.nextTick);\\n```\\n\\n看上述代码，我们可以注意到与本章前面`promisify`化的`API`的代码的一些相似之处。在这一点上，有意思的是，如果我们使用我们的`promisified`版本的函数来代替`thunkified`的版本，代码将保持完全一样，这要归功于`co`支持`thunk`和`Promise`对象作为`yieldable`对象。事实上，如果我们想，甚至可以在同一个应用程序中使用`thunk`和`Promise`，即使在同一个`Generator`函数中。就灵活性而言，这是一个巨大的优势，因为它使我们能够使用基于`Generator`函数的控制流来解决我们应用程序中的问题。\\n\\n好的，现在让我们开始将`download()`函数转换为一个`Generator`函数：\\n\\n```javascript\\nfunction* download(url, filename) {\\n  console.log(`Downloading ${url}`);\\n  const response = yield request(url);\\n  const body = response[1];\\n  yield mkdirp(path.dirname(filename));\\n  yield writeFile(filename, body);\\n  console.log(`Downloaded and saved ${url}`);\\n  return body;\\n}\\n```\\n\\n通过使用`Generator`和`co`，我们的`download()`函数变得简单多了。当我们需要做异步操作的时候，我们使用异步的`Generator`函数作为`thunk`来把之前的内容转化到`Generator`函数，并使用`yield`子句。\\n\\n然后我们开始实现我们的`spider()`函数：\\n\\n```javascript\\nfunction* spider(url, nesting) {\\n  cost filename = utilities.urlToFilename(url);\\n  let body;\\n  try {\\n    body = yield readFile(filename, 'utf8');\\n  } catch (err) {\\n    if (err.code !== 'ENOENT') {\\n      throw err;\\n    }\\n    body = yield download(url, filename);\\n  }\\n  yield spiderLinks(url, body, nesting);\\n}\\n```\\n\\n从上述代码中一个有趣的细节是我们可以使用`try...catch`语句块来处理异常。我们还可以使用`throw`来传播异常。另外一个细节是我们`yield`我们的`download()`函数，而这个函数既不是一个`thunk`，也不是一个`promisified`函数，只是另外的一个`Generator`函数。这也毫无问题，由于`co`也支持其他`Generators`作为`yieldables`。\\n\\n最后转换`spiderLinks()`，在这个函数中，我们递归下载一个网页的链接。在这个函数中使用`Generators`，显得简单多了：\\n\\n```javascript\\nfunction* spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return nextTick();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  for (let i = 0; i < links.length; i++) {\\n    yield spider(links[i], nesting - 1);\\n  }\\n}\\n```\\n\\n看上述代码。虽然顺序迭代没有什么模式可以展示。`Generator`和`co`辅助我们做了很多，方便了我们可以使用同步方式开书写异步代码。\\n\\n看最重要的部分，程序的入口：\\n\\n```javascript\\nco(function*() {\\n  try {\\n    yield spider(process.argv[2], 1);\\n    console.log(`Download complete`);\\n  } catch (err) {\\n    console.log(err);\\n  }\\n});\\n```\\n\\n这是唯一一处需要调用`co(...)`来封装的一个`Generator`。实际上，一旦我们这么做，`co`会自动封装我们传递给`yield`语句的任何`Generator`函数，并且这个过程是递归的，所以程序的剩余部分与我们是否使用`co`是完全无关的，虽然是被`co`封装在里面。\\n\\n现在应该可以运行使用`Generator`函数改写的`Web爬虫应用程序`了。\\n\\n### 并行执行\\n不幸的是，虽然`Generator`很方便地进行顺序执行，但是不能直接用来并行化执行一组任务，至少不能仅仅使用`yield`和`Generator`。之前，在种情况下我们使用的模式只是简单地依赖于一个基于回调或者`Promise`的函数，但使用了`Generator`函数后，一切会显得更简单。\\n\\n幸运的是，如果不限制并发数的并行执行，`co`已经可以通过`yield`一个`Promise`对象、`thunk`、`Generator`函数，甚至包含`Generator`函数的数组来实现。\\n\\n考虑到这一点，我们的`Web爬虫应用程序`第三版可以通过重写`spiderLinks()`函数来做如下改动：\\n\\n```javascript\\nfunction* spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return nextTick();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  const tasks = links.map(link => spider(link, nesting - 1));\\n  yield tasks;\\n}\\n```\\n\\n但是上述函数所做的只是拿到所有的任务，这些任务本质上都是通过`Generator`函数来实现异步的，如果在`co`的`thunk`内对一个包含`Generator`函数的数组使用`yield`，这些任务都会并行执行。外层的`Generator`函数会等到`yield`子句的所有异步任务并行执行后再继续执行。\\n\\n接下来我们看怎么用一个基于回调函数的方式来解决相同的并行流。我们用这种方式重写`spiderLinks()`函数：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return nextTick();\\n  }\\n  // 返回一个thunk\\n  return callback => {\\n    let completed = 0,\\n      hasErrors = false;\\n    const links = utilities.getPageLinks(currentUrl, body);\\n    if (links.length === 0) {\\n      return process.nextTick(callback);\\n    }\\n\\n    function done(err, result) {\\n      if (err && !hasErrors) {\\n        hasErrors = true;\\n        return callback(err);\\n      }\\n      if (++completed === links.length && !hasErrors) {\\n        callback();\\n      }\\n    }\\n    for (let i = 0; i < links.length; i++) {\\n      co(spider(links[i], nesting - 1)).then(done);\\n    }\\n  }\\n}\\n```\\n\\n我们使用`co`并行运行`spider()`函数，调用`Generator`函数返回了一个`Promise`对象。这样，等待`Promise`完成后调用`done()`函数。通常，基于`Generator`控制流的库都有这一功能，因此如果需要，你总是可以将一个`Generator`转换成一个基于回调或基于`Promise`的函数。\\n\\n为了并行开启多个下载任务，我们只要重用在前面定义的基于回调的并行执行的模式。我们应该也注意到我们将`spiderLinks()`转换成一个`thunk`(而不再是一个`Generator`函数)。这使得当全部并行任务完成时，我们有一个回调函数可以调用。\\n\\n> 上面讲到的是将一个Generator函数转换为一个thunk的模式，使之能够支持其他的基于回调或基于Promise的控制流算法，并可以通过同步阻塞的代码风格书写异步代码。\\n\\n### 限制并行执行\\n现在我们知道如何处理异步执行流程，应该很容易规划我们的`Web爬虫应用程序`的第四版的实现，这个版本对并发下载任务的数量施加了限制。我们有几个方案可以用来做到这一点。其中一些方案如下：\\n\\n* 使用先前实现的基于回调的`TaskQueue`类。我们只需要`thunkify`我们的`Generator`函数和其提供的回调函数即可。\\n* 使用基于`Promise`的`TaskQueue`类，并确保每个作为任务的`Generator`函数都被转换成一个返回`Promise`对象的函数。\\n* 使用`async`，`thunkify`我们打算使用的工具函数，此外还需要把我们用到的`Generator`函数转化为基于回调的模式，以便于能够被这个库较好地使用。\\n* 使用基于`co`的生态系统中的库，特别是专门为这种场景的库，如[co-limiter](https://npmjs.org/package/co-limiter)。\\n* 实现基于生产者 - 消费者模型的自定义算法，这与`co-limiter`的内部实现原理相同。\\n\\n为了学习，我们选择最后一个方案，甚至帮助我们可以更好地理解一种经常与协程(也和线程和进程)同步相关的模式。\\n\\n### 生产者 - 消费者模式\\n我们的目标是利用队列来提供固定数量的`workers`，与我们想要设置的并发级别一样多。为了实现这个算法，我们将基于本章前面定义的`TaskQueue`类改写：\\n\\n```javascript\\nclass TaskQueue {\\n  constructor(concurrency) {\\n    this.concurrency = concurrency;\\n    this.running = 0;\\n    this.taskQueue = [];\\n    this.consumerQueue = [];\\n    this.spawnWorkers(concurrency);\\n  }\\n  pushTask(task) {\\n    if (this.consumerQueue.length !== 0) {\\n      this.consumerQueue.shift()(null, task);\\n    } else {\\n      this.taskQueue.push(task);\\n    }\\n  }\\n  spawnWorkers(concurrency) {\\n    const self = this;\\n    for (let i = 0; i < concurrency; i++) {\\n      co(function*() {\\n        while (true) {\\n          const task = yield self.nextTask();\\n          yield task;\\n        }\\n      });\\n    }\\n  }\\n  nextTask() {\\n    return callback => {\\n      if (this.taskQueue.length !== 0) {\\n        return callback(null, this.taskQueue.shift());\\n      }\\n      this.consumerQueue.push(callback);\\n    }\\n  }\\n}\\n```\\n\\n让我们分析这个`TaskQueue`类的新实现。首先是在构造函数中。需要调用一次`this.spawnWorkers()`，因为这是启动`worker`的方法。\\n\\n我们的`worker`很简单，它们只是用`co()`包装的立即执行的`Generator`函数，所以每个`Generator`函数可以并行执行。在内部，每个`worker`正在运行在一个死循环（`while(true){}`）中，一直阻塞（`yield`）到新任务在队列中可用时（`yield self.nextTask()`），一旦可以执行新任务，`yield`这个异步任务直到其完成。您可能想知道我们如何能够限制并行执行，并让下一个任务在队列中处于等待状态。答案是在`nextTask()`方法中。我们来详细地看看在这个方法的原理：\\n\\n```javascript\\nnextTask() {\\n  return callback => {\\n    if (this.taskQueue.length !== 0) {\\n      return callback(null, this.taskQueue.shift());\\n    }\\n    this.consumerQueue.push(callback);\\n  }\\n}\\n```\\n\\n我们看这个函数内部发生了什么，这才是这个模式的核心：\\n\\n1. 这个方法返回一个对于`co`而言是一个合法的`yieldable`的`thunk`。\\n2. 只要`taskQueue`类生成的实例中还有下一个任务，`thunk`的回调函数会被立即调用。回调函数调用时，立马解锁一个`worker`的阻塞状态，`yield`这一个任务。\\n3. 如果队列中没有任务了，回调函数本身会被放入`consumerQueue`中。通过这种做法，我们将一个`worker`置于空闲（`idle`）的模式。一旦我们有一个新的任务来要处理，在`consumerQueue`队列中的回调函数会被调用，立马唤醒我们这一`worker`进行异步处理。\\n\\n现在，为了理解`consumerQueue`队列中的空闲`worker`是如何恢复工作的，我们需要分析`pushTask()`方法。如果当前有回调函数可用的话，`pushTask()`方法将调用`consumerQueue`队列中的第一个回调函数，从而将取消对`worker`的锁定。如果没有可用的回调函数，这意味着所有的`worker`都是工作状态，只需要添加一个新的任务到`taskQueue`任务队列中。\\n\\n在`TaskQueue`类中，`worker`充当消费者的角色，而调用`pushTask()`函数的角色可以被认为是生产者。这个模式向我们展示了一个`Generator`函数实际上可以跟一个线程或进程类似。实际上，生产者 - 消费者之间问题是研究进程间通信和同步时最常见的问题，但正如我们已经提到的那样，它对于进程和线程来说，也是一个常见的例子。\\n\\n### 限制下载任务的并发量\\n既然我们已经使用`Generator`函数和生产者 - 消费者模型实现一个限制并行算法，并且已经在`Web爬虫应用程序`第四版应用它来限制中下载任务的并发数。 首先，我们加载和初始化一个`TaskQueue`对象：\\n\\n```javascript\\nconst TaskQueue = require('./taskQueue');\\nconst downloadQueue = new TaskQueue(2);\\n```\\n\\n然后，修改`spiderLinks()`函数。和之前不限制并发的版本类似，所以这里我们只展示修改的部分，主要是通过调用新版本的`TaskQueue`类生成的实例的`pushTask()`方法来限制并行执行：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  //...\\n  return (callback) => {\\n    //...\\n    function done(err, result) {\\n      //...\\n    }\\n    links.forEach(function(link) {\\n      downloadQueue.pushTask(function*() {\\n        yield spider(link, nesting - 1);\\n        done();\\n      });\\n    });\\n  }\\n}\\n```\\n\\n在每个任务中，我们在下载完成后立即调用`done()`函数，因此我们可以计算下载了多少个链接，然后在完成下载时通知`thunk`的回调函数执行。\\n\\n## 配合Babel使用Async await新语法\\n回调函数、`Promise`和`Generator`函数都是用于处理`JavaScript`和`Node.js`异步问题的方式。正如我们所看到的，`Generator`的真正意义在于它提供了一种方式来暂停一个函数的执行，然后等待前面的任务完成后再继续执行。我们可以使用这样的特性来书写异步代码，并且让开发者用同步阻塞的代码风格来书写异步代码。等到异步操作的结果返回后才恢复当前函数的执行。\\n\\n但`Generator`函数是更多的是用来处理迭代器，然而迭代器在异步代码的使用显得有点笨重。代码可能难以理解，导致代码易读性和可维护性差。\\n\\n但在不远的将来会有一种更加简洁的语法。实际上，这个提议即将引入到`ESMASCript 2017`的规范中，这项规范定义了`async`函数语法。\\n\\n`async`函数规范引入两个关键字(`async`和`await`)到原生的`JavaScript`语言中，改进我们书写异步代码的方式。\\n\\n为了理解这项语法的用法和优势为，我们看一个简单的例子：\\n\\n```javascript\\nconst request = require('request');\\n\\nfunction getPageHtml(url) {\\n  return new Promise(function(resolve, reject) {\\n    request(url, function(error, response, body) {\\n      resolve(body);\\n    });\\n  });\\n}\\nasync function main() {\\n  const html = await getPageHtml('http://google.com');\\n  console.log(html);\\n}\\n\\nmain();\\nconsole.log('Loading...');\\n```\\n\\n在上述代码中，有两个函数：`getPageHtml`和`main`。第一个函数的作用是提取给定`URL`的一个远程网页的`HTML`文档代码。值得注意的是，这个函数返回一个`Promise`对象。\\n\\n重点在于`main`函数，因为在这里使用了`async`和`await`关键字。首先要注意的是函数要以`async`关键字为前缀。意思是这个函数执行的是异步代码并且允许它在函数体内使用`await`关键字。`await`关键字在`getPageHtml`调用之前，告诉`JavaScript`解释器在继续执行下一条指令之前，等待`getPageHtml`返回的`Promise`对象的结果。这样，`main`函数内部哪部分代码是异步的，它会等待异步代码的完成再继续执行后续操作，并且不会阻塞这段程序其余部分的正常执行。实际上，控制台会打印字符串`Loading...`，随后是Google主页的`HTML`代码。\\n\\n是不是这种方法的可读性更好并且更容易理解呢? 不幸地是，这个提议尚未定案，即使通过这个提议，我们需要等下一个版本\\n的`ECMAScript`规范出来并把它集成到`Node.js`后，才能使用这个新语法。 所以我们今天做了什么?只是漫无目的地等待?不是，当然不是！我们已经可以在我们的代码中使用`async await`语法，只要我们使用`Babel`。\\n\\n### 安装与运行Babel\\n`Babel`是一个`JavaScript`编译器(或翻译器)，能够使用语法转换器将高版本的`JavaScript`代码转换成其他`JavaScript`代码。语法转换器允许例如我们书写并使用`ES2015`，`ES2016`，`JSX`和其它的新语法，来翻译成往后兼容的代码，在`JavaScript`运行环境如浏览器或`Node.js`中都可以使用`Babel`。\\n\\n在项目中使用`npm`安装`Babel`，命令如下：\\n\\n```\\nnpm install --save-dev babel-cli\\n```\\n\\n我们还需要安装插件以支持`async await`语法的解释或翻译：\\n\\n```\\nnpm install --save-dev babel-plugin-syntax-async-functions babel-plugin-tranform-async-to-generator\\n```\\n\\n现在假设我们想运行我们之前的例子（称为`index.js`）。我们需要通过以下命令启动：\\n\\n```\\nnode_modules/.bin/babel-node --plugins \\\"syntax-async-functions,transform-async-to-generator\\\" index.js\\n```\\n\\n这样，我们使用支持`async await`的转换器动态地转换源代码。`Node.js`运行的实际是保存在内存中的往后兼容的代码。\\n\\n`Babel`也能被配置为一个代码构建工具，保存翻译或解释后的代码到本地文件系统中，便于我们部署和运行生成的代码。\\n\\n> 关于如何安装和配置Babel，可以到官方网站 https://babeljs.io 查阅相关文档。\\n\\n## 几种方式的比较\\n现在，我们应该对于怎么处理`JavaScript`的异步问题有了一个更好的认识和总结。在下面的表格中总结几大机制的优势和劣势：\\n\\n![](http://oczira72b.bkt.clouddn.com/17-11-7/55293366.jpg)\\n\\n> 值得一提的是，我们选择在本章中仅介绍处理异步控制流程的最受欢迎的解决方案，或者是广泛使用的解决方案，但是例如Fibers（ https://npmjs.org/package/fibers ）和Streamline（ https://npmjs.org/p ackage/streamline ）也是值得一看的。\\n\\n## 总结\\n在本章中，我们分析了一些处理异步控制流的方法，分析了`Promise`、`Generator`函数和即将到来的`async await`语法。\\n\\n我们学习了如何使用这些方法编写更简洁，更具有可读性的异步代码。我们讨论了这些方法的一些最重要的优点和缺点，并认识到即使它们非常有用，也需要一些时间来掌握。这就是这几种方式也没有完全取代在许多情况下仍然非常有用的回调的原因。作为一名开发人员，应该按照实际情况分析决定使用哪种解决方案。如果您正在构建执行异步操作的公共库，则应该提供易于使用的`API`，即使对于只想使用回调的开发人员也是如此。\\n\\n在下一章中，我们将探讨另一个与异步代码执行相关的机制，这也是整个`Node.js`生态系统中的另一个基本构建块：`streams`。\"\n}"
*************** response log end ***************

[2017-12-01 12:16:24.308] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/art/addReply
request client ip:  ::1
request body: 
{"content":"# Asynchronous Control Flow Patterns with ES2015 and Beyond\n在上一章中，我们学习了如何使用回调处理异步代码，以及如何解决如回调地狱代码等异步问题。回调是`JavaScript`和`Node.js`中的异步编程的基础，但是现在，其他替代方案已经出现。这些替代方案更复杂，以便能够以更方便的方式处理异步代码。\n\n在本章中，我们将探讨一些代表性的替代方案，`Promise`和`Generator`。以及`async await`，这是一种创新的语法，可在高版本的`JavaScript`中提供，其也作为`ECMAScript 2017`发行版的一部分。\n\n我们将看到这些替代方案如何简化处理异步控制流的方式。最后，我们将比较所有这些方法，以了解所有这些方法的所有优点和缺点，并能够明智地选择最适合我们下一个`Node.js`项目要求的方法。\n\n## Promise\n我们在前面的章节中提到，`CPS风格`不是编写异步代码的唯一方法。事实上，`JavaScript`生态系统为传统的回调模式提供了有趣的替代方案。最着名的选择之一是`Promise`，特别是现在它是`ECMAScript 2015`的一部分，并且现在可以在`Node.js`中可用。\n\n### 什么是Promise？\n`Promise`是一种抽象的对象，我们通常允许函数返回一个名为`Promise`的对象，它表示异步操作的最终结果。通常情况下，我们说当异步操作尚未完成时，我们说`Promise`对象处于`pending`状态，当操作成功完成时，我们说`Promise`对象处于`resolve`状态，当操作错误终止时，我们说`Promise`对象处于`reject`状态。一旦`Promise`处于`resolve`或`reject`，我们认为当前异步操作结束。\n\n为了接收到异步操作的正确结果或错误捕获，我们可以使用`Promise`的`then`方法：\n\n```javascript\npromise.then([onFulfilled], [onRejected])\n```\n\n在前面的代码中，`onFulfilled()`是一个函数，最终会收到`Promise`的正确结果，而`onRejected()`是另一个函数，它将接收产生异常的原因（如果有的话）。两个参数都是可选的。\n\n要了解`Promise`如何转换我们的代码，让我们考虑以下几点：\n\n```javascript\nasyncOperation(arg, (err, result) => {\n  if (err) {\n    // 错误处理\n  }\n  // 正常结果处理\n});\n```\n\n`Promise`允许我们将这个典型的`CPS`代码转换成更好的结构化和更优雅的代码，如下所示：\n\n```javascript\nasyncOperation(arg)\n  .then(result => {\n    // 错误处理\n  }, err => {\n    // 正常结果处理\n  });\n```\n\n`then()`方法的一个关键特征是它同步地返回另一个`Promise`对象。如果`onFulfilled()`或`onRejected()`函数中的任何一个函数返回`x`，则`then()`方法返回的`Promise`对象将如下所示：\n\n* 如果`x`是一个值，则这个`Promise`对象会正确处理(`resolve`)`x`\n* 如果`x`是一个`Promise`对象或`thenable`，则会正确处理(`resolve`)`x`\n* 如果`x`是一个异常，则会捕获异常(`reject`)`x`\n\n> 注：thenable是一个具有then方法的类似于Promise的对象(Promise-like)。\n\n这个特点使我们能够链式构建`Promise`，允许轻松排列组合我们的异步操作。另外，如果我们没有指定一个`onFulfilled()`或`onRejected()`处理程序，则正确结果或异常捕获将自动转发到`Promise`链的下一个`Promise`。例如，这允许我们在整个链中自动传播错误，直到被`onRejected()`处理程序捕获。随着`Promise`链，任务的顺序执行突然变成简单多了：\n\n```javascript\nasyncOperation(arg)\n  .then(result1 => {\n    // 返回另一个Promise\n    return asyncOperation(arg2);\n  })\n  .then(result2 => {\n    // 返回一个值\n    return 'done';\n  })\n  .then(undefined, err => {\n    // 捕获Promise链中的异常\n  });\n```\n\n下图展示了链式`Promise`如何工作：\n\n![](http://oczira72b.bkt.clouddn.com/17-10-31/46370382.jpg)\n\n`Promise`的另一个重要特性是`onFulfilled()`和`onRejected()`函数是异步调用的，如同上述的例子，在最后那个`then`函数`resolve`一个同步的`Promise`，它也是同步的。这种模式避免了`Zalgo`（参见`Chapter2-Node.js Essential Patterns`），使我们的异步代码更加一致和稳健。\n\n如果在`onFulfilled()`或`onRejected()`处理程序中抛出异常（使用`throw`语句），则`then()`方法返回的`Promise`将被自动地`reject`，抛出异常作为`reject`的原因。这相对于`CPS`来说是一个巨大的优势，因为它意味着有了`Promise`，异常将在整个链中自动传播，并且`throw`语句终于可以使用。\n\n在以前，许多不同的库实现了`Promise`，大多数时候它们之间不兼容，这意味着不可能在使用不同`Promise`库的`thenable`链式传播错误。\n\n`JavaScript`社区非常努力地解决了这个限制，这些努力导致了`Promises / A +`规范的创建。该规范详细描述了`then`方法的行为，提供了一个可互兼容的基础，这使得来自不同库的`Promise`对象能够彼此兼容，开箱即用。\n\n有关`Promises / A +`规范的详细说明，可以参考[Promises / A + 官方网站](https://promisesaplus.com)。\n\n### Promise / A + 的实施\n在`JavaScript`中以及`Node.js`中，有几个实现`Promises / A +`规范的库。以下是最受欢迎的：\n\n* [Bluebird](https://npmjs.org/package/bluebird)\n* [Q](https://npmjs.org/package/q)\n* [RSVP](https://npmjs.org/package/rsvp)\n* [Vow](https://npmjs.org/package/vow)\n* [When.js](https://npmjs.org/package/when)\n* ES2015 promises\n\n真正区别他们的是在`Promises / A +`标准之上提供的额外功能。正如我们上述所说的那样，该标准定义了`then()`方法和`Promise`解析过程的行为，但它没有指定其他功能，例如，如何从基于回调的异步函数创建`Promise`。\n\n在我们的示例中，我们将使用由`ES2015`的`Promise`，因为`Promise`对象自`Node.js 4`后即可使用，而不需要任何库来实现。\n\n作为参考，以下是`ES2015`的`Promise`提供的API：\n\n`constructor`(`new Promise（function（resolve, reject）{}）`)：创建了一个新的`Promise`，它基于作为传递两个类型为函数的参数来决定`resolve`或`reject`。构造函数的参数解释如下：\n\n* `resolve(obj)` ：`resolve`一个`Promise`，并带上一个参数`obj`，如果`obj`是一个值，这个值就是传递的异步操作成功的结果。如果`obj`是一个`Promise`或一个`thenable`，则会进行正确处理。\n* `reject(err)`：`reject`一个`Promise`，并带上一个参数`err`。它是`Error`对象的一个实例。\n\n#### Promise对象的静态方法\n* `Promise.resolve(obj)`： 将会创建一个`resolve`的`Promise`实例\n* `Promise.reject(err)`： 将会创建一个`reject`的`Promise`实例\n* `Promise.all(iterable)`：返回一个新的`Promise`实例，并且在`iterable`中所\n有`Promise`状态为`reject`时, 返回的`Promise`实例的状态会被置为`reject`，如果`iterable`中至少有一个`Promise`状态为`reject`时, 返回的`Promise`实例状态也会被置为`reject`，并且`reject`的原因是第一个被`reject`的`Promise`对象的`reject`原因。\n* `Promise.race(iterable)`：返回一个`Promise`实例，当`iterable`中任何一个`Promise`被`resolve`或被`reject`时， 返回的`Promise`实例以同样的原因`resolve`或`reject`。\n\n#### Promise实例方法\n* `Promise.then(onFulfilled, onRejected)`：这是`Promise`的基本方法。它的行为与我们之前描述的`Promises / A +`标准兼容。\n* `Promise.catch(onRejected)`：这只是`Promise.then(undefined，onRejected)`的语法糖。\n\n> 值得一提的是，一些Promise实现提供了另一种机制来创建新的Promise，称为deferreds。我们不会在这里描述，因为它不是ES2015标准的一部分，但是如果您想了解更多信息，可以阅读Q文档 (https://github.com/kriskowal/q#using-deferreds) 或When.js文档 (https://github.com/cujojs/when/wiki/Deferred) 。\n\n### Promisifying一个Node.js回调风格的函数\n在`JavaScript`中，并不是所有的异步函数和库都支持开箱即用的`Promise`。大多数情况下，我们必须将一个典型的基于回调的函数转换成一个返回`Promise`的函数，这个过程也被称为`promisification`。\n\n幸运的是，`Node.js`中使用的回调约定允许我们创建一个可重用的函数，我们通过使用`Promise`对象的构造函数来简化任何`Node.js`风格的`API`。让我们创建一个名为`promisify()`的新函数，并将其包含到`utilities.js`模块中（以便稍后在我们的`Web爬虫应用程序`中使用它）：\n\n```javascript\nmodule.exports.promisify = function(callbackBasedApi) {\n  return function promisified() {\n    const args = [].slice.call(arguments);\n    return new Promise((resolve, reject) => {\n      args.push((err, result) => {\n        if (err) {\n          return reject(err);\n        }\n        if (arguments.length <= 2) {\n          resolve(result);\n        } else {\n          resolve([].slice.call(arguments, 1));\n        }\n      });\n      callbackBasedApi.apply(null, args);\n    });\n  }\n};\n```\n\n前面的函数返回另一个名为`promisified()`的函数，它表示输入中给出的`callbackBasedApi`的`promisified`版本。以下展示它是如何工作的：\n\n1. `promisified()`函数使用`Promise`构造函数创建一个新的`Promise`对象，并立即将其返回给调用者。\n2. 在传递给`Promise`构造函数的函数中，我们确保传递给`callbackBasedApi`，这是一个特殊的回调函数。由于我们知道回调总是最后调用的，我们只需将回调函数附加到提供给`promisified()`函数的参数列表里（`args`）。\n3. 在特殊的回调中，如果我们收到错误，我们立即`reject`这个`Promise`。\n4. 如果没有收到错误，我们使用一个值或一个数组值来`resolve`这个`Promise`，具体取决于传递给回调的结果数量。\n5. 最后，我们只需使用我们构建的参数列表调用`callbackBasedApi`。\n\n> 大部分的Promise已经提供了一个开箱即用的接口来将一个Node.js风格的API转换成一个返回Promise的API。例如，Q有Q.denodeify()和Q.nbind()，Bluebird有Promise.promisify()，而When.js有node.lift()。\n\n### 顺序执行\n在一些必要的理论之后，我们现在准备将我们的`Web爬虫应用程序`转换为使用`Promise`的形式。让我们直接从版本2开始，直接下载一个Web网页的链接。\n\n在`spider.js`模块中，第一步是加载我们的`Promise`实现（我们稍后会使用它）和`Promisifying`我们打算使用的基于回调的函数：\n\n```javascript\nconst utilities = require('./utilities');\nconst request = utilities.promisify(require('request'));\nconst mkdirp = utilities.promisify(require('mkdirp'));\nconst fs = require('fs');\nconst readFile = utilities.promisify(fs.readFile);\nconst writeFile = utilities.promisify(fs.writeFile);\n```\n\n现在，我们开始更改我们的`download`函数：\n\n```javascript\nfunction download(url, filename) {\n  console.log(`Downloading ${url}`);\n  let body;\n  return request(url)\n    .then(response => {\n      body = response.body;\n      return mkdirp(path.dirname(filename));\n    })\n    .then(() => writeFile(filename, body))\n    .then(() => {\n      console.log(`Downloaded and saved: ${url}`);\n      return body;\n    });\n}\n```\n\n这里要注意的到的最重要的是我们也为`readFile()`返回的`Promise`注册\n一个`onRejected()`函数，用来处理一个网页没有被下载的情况(或文件不存在)。 还有，看我们如何使用`throw`来传递`onRejected()`函数中的错误的。\n\n既然我们已经更改我们的`spider()`函数，我们这么修改它的调用方式：\n\n```javascript\nspider(process.argv[2], 1)\n  .then(() => console.log('Download complete'))\n  .catch(err => console.log(err));\n```\n\n注意我们是如何第一次使用`Promise`的语法糖`catch`来处理源自`spider()`函数的任何错误情况。如果我们再看看迄今为止我们所写的所有代码，那么我们会惊喜的发现，我们没有包含任何错误传播逻辑，因为我们在使用回调函数时会被迫做这样的事情。这显然是一个巨大的优势，因为它极大地减少了我们代码中的样板文件以及丢失任何异步错误的机会。\n\n现在，完成我们唯一缺失的`Web爬虫应用程序`的第二版的`spiderLinks()`函数，我们将在稍后实现它。\n\n### 顺序迭代\n到目前为止，`Web爬虫应用程序`代码库主要是对`Promise`是什么以及如何使用的概述，展示了使用`Promise`实现顺序执行流程的简单性和优雅性。但是，我们现在考虑的代码只涉及到一组已知的异步操作的执行。所以，完成我们对顺序执行流程的探索的缺失部分是看我们如何使用`Promise`来实现迭代。同样，网络蜘蛛第二版的`spiderLinks()`函数也是一个很好的例子。\n\n让我们添加缺少的这一块：\n\n```javascript\nfunction spiderLinks(currentUrl, body, nesting) {\n  let promise = Promise.resolve();\n  if (nesting === 0) {\n    return promise;\n  }\n  const links = utilities.getPageLinks(currentUrl, body);\n  links.forEach(link => {\n    promise = promise.then(() => spider(link, nesting - 1));\n  });\n  return promise;\n}\n```\n\n为了异步迭代一个网页的全部链接，我们必须动态创建一个`Promise`的迭代链。\n\n1. 首先，我们定义一个空的`Promise`，`resolve`为`undefined`。这个`Promise`只是用来作为`Promise`的迭代链的起始点。 \n2. 然后，我们通过在循环中调用链中前一个`Promise`的`then()`方法获得的新的`Promise`来更新`Promise`变量。这就是我们使用`Promise`的异步迭代模式。\n\n这样，循环的结束，`promise`变量会包含循环中最后一个`then()`返回的`Promise`对象，所以它只有当`Promise`的迭代链中全部`Promise`对象被`resolve`后才能被`resolve`。\n\n> 注：在最后调用了这个then方法来resolve这个Promise对象\n\n通过这个，我们已使用`Promise`对象重写了我们的`Web爬虫应用程序`。我们现在应该可以运行它了。\n\n### 顺序迭代模式\n为了总结这个顺序执行的部分，让我们提取一个模式来依次遍历一组`Promise`：\n\n```javascript\nlet tasks = [ /* ... */ ]\nlet promise = Promise.resolve();\ntasks.forEach(task => {\n  promise = promise.then(() => {\n    return task();\n  });\n});\npromise.then(() => {\n  // 所有任务都完成\n});\n```\n\n使用`reduce()`方法来替代`forEach()`方法，允许我们写出更为简洁的代码：\n\n```javascript\nlet tasks = [ /* ... */ ]\nlet promise = tasks.reduce((prev, task) => {\n  return prev.then(() => {\n    return task();\n  });\n}, Promise.resolve());\n\npromise.then(() => {\n  //All tasks completed\n});\n```\n\n与往常一样，通过对这种模式的简单调整，我们可以将所有任务的结果收集到一个数组中，我们可以实现一个`mapping`算法，或者构建一个`filter`等等。\n\n> 上述这个模式使用循环动态地建立一个链式的Promise。\n\n### 并行执行\n另一个适合用`Promise`的执行流程是并行执行流程。实际上，我们需要做的就是使用内置的`Promise.all()`。这个方法创造了另一个`Promise`对象，只有在输入中的所有`Promise`都`resolve`时才能`resolve`。这是一个并行执行，因为在其参数`Promise`对象的之间没有执行顺序可言。\n\n为了演示这一点，我们来看我们的`Web爬虫应用程序`的第三版，它将页面中的所有链接并行下载。让我们再次使用`Promise`更新`spiderLinks()`函数来实现并行流程：\n\n```javascript\nfunction spiderLinks(currentUrl, body, nesting) {\n  if (nesting === 0) {\n    return Promise.resolve();\n  }\n  const links = utilities.getPageLinks(currentUrl, body);\n  const promises = links.map(link => spider(link, nesting - 1));\n  return Promise.all(promises);\n}\n```\n\n这里的模式在`elements.map()`迭代中产生一个数组，存放所有异步任务，之后便于同时启动`spider()`任务。这一次，在循环中，我们不等待以前的下载完成，然后开始一个新的下载任务：所有的下载任务在一个循环中一个接一个地开始。之后，我们利用`Promise.all()`方法，它返回一个新的`Promise`对象，当数组中的所有`Promise`对象都被`resolve`时，这个`Promise`对象将被`resolve`。换句话说，所有的下载任务完成，这正是我们想要的。\n\n### 限制并行执行\n不幸的是，`ES2015`的`Promise API`并没有提供一种原生的方式来限制并发任务的数量，但是我们总是可以依靠我们所学到的有关用普通`JavaScript`来限制并发。事实上，我们在`TaskQueue`类中实现的模式可以很容易地被调整来支持返回承诺的任务。这很容易通过修改`next()`方法来完成：\n\n```javascript\nclass TaskQueue {\n  constructor(concurrency) {\n    this.concurrency = concurrency;\n    this.running = 0;\n    this.queue = [];\n  }\n\n  pushTask(task) {\n    this.queue.push(task);\n    this.next();\n  }\n\n  next() {\n    while (this.running < this.concurrency && this.queue.length) {\n      const task = this.queue.shift();\n      task().then(() => {\n        this.running--;\n        this.next();\n      });\n      this.running++;\n    }\n  }\n}\n```\n\n不同于使用一个回调函数来处理任务，我们简单地调用`Promise`的`then()`。\n\n让我们回到`spider.js`模块，并修改它以支持我们的新版本的`TaskQueue`类。首先，我们确保定义一个`TaskQueue`的新实例：\n\n```javascript\nconst TaskQueue = require('./taskQueue');\nconst downloadQueue = new TaskQueue(2);\n```\n\n然后，是我们的`spiderLinks()`函数。这里的修改也是很简单：\n\n```javascript\nfunction spiderLinks(currentUrl, body, nesting) {\n  if (nesting === 0) {\n    return Promise.resolve();\n  }\n  const links = utilities.getPageLinks(currentUrl, body);\n  // 我们需要如下代码，用于创建Promise对象\n  // 如果没有下列代码，当任务数量为0时，将永远不会resolve\n  if (links.length === 0) {\n    return Promise.resolve();\n  }\n  return new Promise((resolve, reject) => {\n    let completed = 0;\n    let errored = false;\n    links.forEach(link => {\n      let task = () => {\n        return spider(link, nesting - 1)\n          .then(() => {\n            if (++completed === links.length) {\n              resolve();\n            }\n          })\n          .catch(() => {\n            if (!errored) {\n              errored = true;\n              reject();\n            }\n          });\n      };\n      downloadQueue.pushTask(task);\n    });\n  });\n}\n```\n\n在上述代码中有几点值得我们注意的：\n\n* 首先，我们需要返回使用`Promise`构造函数创建的新的`Promise`对象。正如我们将看到的，这使我们能够在队列中的所有任务完成时手动`resolve`我们的`Promise`对象。\n* 然后，我们应该看看我们如何定义任务。我们所做的是将一个`onFulfilled()`回调函数的调用添加到由`spider()`返回的`Promise`对象中，所以我们可以计算完成的下载任务的数量。当完成的下载量与当前页面中链接的数量相同时，我们知道任务已经处理完毕，所以我们可以调用外部`Promise`的`resolve()`函数。\n\n> Promises / A +规范规定，then()方法的onFulfilled()和onRejected()回调函数只能调用一次（仅调用onFulfilled()和onRejected()）。Promise接口的实现确保即使我们多次手动调用resolve或reject，Promise也仅可以被resolve或reject一次。\n\n现在，使用`Promise`的`Web爬虫应用程序`的第4版应该已经准备好了。我们可能再次注意到下载任务如何并行运行，并发数量限制为2。\n\n### 在公有API中暴露回调函数和Promise\n正如我们在前面所学到的，`Promise`可以被用作回调函数的一个很好的替代品。它们使我们的代码更具可读性和易于理解。虽然`Promise`带来了许多优点，但也要求开发人员理解许多不易于理解的概念，以便正确和熟练地使用。由于这个原因和其他原因，在某些情况下，比起`Promise`来说，很多开发者更偏向于回调函数。\n\n现在让我们想象一下，我们想要构建一个执行异步操作的公共库。我们需要做什么？我们是创建了一个基于回调函数的`API`还是一个面向`Promise`的`API`？还是两者均有？\n\n这是许多知名的库所面临的问题，至少有两种方法值得一提，使我们能够提供一个多功能的`API`。\n\n像`request`，`redis`和`mysql`这样的库所使用的第一种方法是提供一个简单的基于回调函数的`API`，如果需要，开发人员可以选择公开函数。其中一些库提供工具函数来`Promise`化异步回调，但开发人员仍然需要以某种方式将暴露的`API`转换为能够使用`Promise`对象。\n\n第二种方法更透明。它还提供了一个面向回调的`API`，但它使回调参数可选。每当回调作为参数传递时，函数将正常运行，在完成时或失败时执行回调。当回调未被传递时，函数将立即返回一个`Promise`对象。这种方法有效地结合了回调函数和`Promise`，使得开发者可以在调用时选择采用什么接口，而不需要提前进行`Promise`化。许多库，如`mongoose`和`sequelize`，都支持这种方法。\n\n我们来看一个简单的例子。假设我们要实现一个异步执行除法的模块：\n\n```javascript\nmodule.exports = function asyncDivision(dividend, divisor, cb) {\n  return new Promise((resolve, reject) => { // [1]\n    process.nextTick(() => {\n      const result = dividend / divisor;\n      if (isNaN(result) || !Number.isFinite(result)) {\n        const error = new Error('Invalid operands');\n        if (cb) {\n          cb(error); // [2]\n        }\n        return reject(error);\n      }\n      if (cb) {\n        cb(null, result); // [3]\n      }\n      resolve(result);\n    });\n  });\n};\n```\n\n该模块的代码非常简单，但是有一些值得强调的细节：\n\n* 首先，返回使用`Promise`的构造函数创建的新承诺。我们在构造函数参数函数内定义全部逻辑。\n* 在发生错误的情况下，我们`reject`这个`Promise`，但如果回调函数在被调用时作为参数传递，我们也执行回调来进行错误传播。\n* 在计算结果之后，我们`resolve`了这个`Promise`，但是如果有回调函数，我们也会将结果传播给回调函数。\n\n我们现在看如何用回调函数和`Promise`来使用这个模块：\n\n```javascript\n// 回调函数的方式\nasyncDivision(10, 2, (error, result) => {\n  if (error) {\n    return console.error(error);\n  }\n  console.log(result);\n});\n\n// Promise化的调用方式\nasyncDivision(22, 11)\n  .then(result => console.log(result))\n  .catch(error => console.error(error));\n```\n\n应该很清楚的是，即将开始使用类似于上述的新模块的开发人员将很容易地选择最适合自己需求的风格，而无需在希望利用`Promise`时引入外部`promisification`功能。\n\n## Generators\n`ES2015`规范引入了另外一种机制，除了其他新功能外，还可以用来简化`Node.js`应用程序的异步控制流程。我们正在谈论`Generator`，也被称为`semi-coroutines`。它们是子程序的一般化，可以有不同的入口点。在一个正常的函数中，实际上我们只能有一个入口点，这个入口点对应着函数本身的调用。`Generator`与一般函数类似，但是可以暂停（使用`yield`语句），然后在稍后继续执行。在实现迭代器时，`Generator`特别有用，因为我们已经讨论了如何使用迭代器来实现重要的异步控制流模式，如顺序执行和限制并行执行。\n\n### Generators基础\n在我们探索使用`Generator`来实现异步控制流程之前，学习一些基本概念是很重要的。我们从语法开始吧。可以通过在函数关键字之后附加`*`（星号）运算符来声明`Generator`函数：\n\n```javascript\nfunction* makeGenerator() {\n  // body\n}\n```\n\n在`makeGenerator()`函数内部，我们可以使用关键字`yield`暂停执行并返回给调用者传递给它的值：\n\n```javascript\nfunction* makeGenerator() {\n  yield 'Hello World';\n  console.log('Re-entered');\n}\n```\n\n在前面的代码中，`Generator`通过`yield`一个字符串`Hello World`暂停当前函数的执行。当`Generator`恢复时，执行将从下列语句开始：\n\n```javascript\nconsole.log('Re-entered');\n```\n\n`makeGenerator()`函数本质上是一个工厂，它在被调用时返回一个新的`Generator`对象：\n\n```javascript\nconst gen = makeGenerator();\n```\n\n生成器对象的最重要的方法是`next()`，它用于启动/恢复`Generator`的执行，并返回如下形式的对象：\n\n```\n{\n  value: <yielded value>\n  done: <true if the execution reached the end>\n}\n```\n\n这个对象包含`Generator` `yield`的值和一个指示`Generator`是否已经完成执行的符号。\n\n### 一个简单的例子\n为了演示`Generator`，我们来创建一个名为`fruitGenerator.js`的新模块：\n\n```javascript\nfunction* fruitGenerator() {\n  yield 'apple';\n  yield 'orange';\n  return 'watermelon';\n}\nconst newFruitGenerator = fruitGenerator();\nconsole.log(newFruitGenerator.next()); // [1]\nconsole.log(newFruitGenerator.next()); // [2]\nconsole.log(newFruitGenerator.next()); // [3]\n```\n\n前面的代码将打印下面的输出：\n\n```\n{ value: 'apple', done: false }\n{ value: 'orange', done: false }\n{ value: 'watermelon', done: true }\n```\n\n我们可以这么解释上述现象：\n\n* 第一次调用`newFruitGenerator.next()`时，`Generator`函数开始执行，直到达到第一个`yield`语句为止，该命令暂停`Generator`函数执行，并将值`apple`返回给调用者。\n* 在第二次调用`newFruitGenerator.next()`时，`Generator`函数恢复执行，从第二个`yield`语句开始，这又使得执行暂停，同时将`orange`返回给调用者。\n* `newFruitGenerator.next()`的最后一次调用导致`Generator`函数的执行从其最后的`yield`恢复，一个返回语句，它终止`Generator`函数，返回`watermelon`，并将结果对象中的`done`属性设置为`true`。\n\n### Generators作为迭代器\n为了更好地理解为什么`Generator`函数对实现迭代器非常有用，我们来构建一个例子。在我们将调用`iteratorGenerator.js`的新模块中，我们编写下面的代码：\n\n```javascript\nfunction* iteratorGenerator(arr) {\n  for (let i = 0; i < arr.length; i++) {\n    yield arr[i];\n  }\n}\nconst iterator = iteratorGenerator(['apple', 'orange', 'watermelon']);\nlet currentItem = iterator.next();\nwhile (!currentItem.done) {\n  console.log(currentItem.value);\n  currentItem = iterator.next();\n}\n```\n\n此代码应按如下所示打印数组中的元素：\n\n```\napple\norange\nwatermelon\n```\n\n在这个例子中，每次我们调用`iterator.next()`时，我们都会恢复`Generator`函数的`for`循环，通过`yield`数组中的下一个项来运行另一个循环。这演示了如何在函数调用过程中维护`Generator`的状态。当继续执行时，循环和所有变量的值与`Generator`函数执行暂停时的状态完全相同。\n\n### 传值给Generators\n现在我们继续研究`Generator`的基本功能，首先学习如何将值传递回`Generator`函数。这其实很简单，我们需要做的只是为`next()`方法提供一个参数，并且该值将作为`Generator`函数内的`yield`语句的返回值提供。\n\n为了展示这一点，我们来创建一个新的简单模块：\n\n```javascript\nfunction* twoWayGenerator() {\n  const what = yield null;\n  console.log('Hello ' + what);\n}\nconst twoWay = twoWayGenerator();\ntwoWay.next();\ntwoWay.next('world');\n```\n\n当执行时，前面的代码会输出`Hello world`。我们做如下的解释：\n\n* 第一次调用`next()`方法时，`Generator`函数到达第一个`yield`语句，然后暂停。\n* 当`next('world')`被调用时，`Generator`函数从上次停止的位置，也就是上次的`yield`语句点恢复，但是这次我们有一个值传递到`Generator`函数。这个值将被赋值到`what`变量。生成器然后执行`console.log()`指令并终止。\n\n用类似的方式，我们可以强制`Generator`函数抛出异常。这可以通过使用`Generator`函数的`throw`方法来实现，如下例所示：\n\n```javascript\nconst twoWay = twoWayGenerator();\ntwoWay.next();\ntwoWay.throw(new Error());\n```\n\n在这个最后这段代码，`twoWayGenerator()`函数将在`yield`函数返回的时候抛出异常。这就好像从`Generator`函数内部抛出了一个异常一样，这意味着它可以像使用`try ... catch`块一样进行捕获和处理异常。\n\n### Generator实现异步控制流\n你一定想知道`Generator`函数如何帮助我们处理异步操作。我们可以通过创建一个接受`Generator`函数作为参数的特殊函数来演示这一点，并允许我们在`Generator`函数内部使用异步代码。这个函数在异步操作完成时要注意恢复`Generator`函数的执行。我们将调用这个函数`asyncFlow()`：\n\n```javascript\nfunction asyncFlow(generatorFunction) {\n  function callback(err) {\n    if (err) {\n      return generator.throw(err);\n    }\n    const results = [].slice.call(arguments, 1);\n    generator.next(results.length > 1 ? results : results[0]);\n  }\n  const generator = generatorFunction(callback);\n  generator.next();\n}\n```\n\n前面的函数取一个`Generator`函数作为输入，然后立即调用：\n\n```javascript\nconst generator = generatorFunction(callback);\ngenerator.next();\n```\n\n`generatorFunction()`接受一个特殊的回调函数作为参数，当`generator.throw()`如果接收到一个错误，便立即返回。另外，通过将在回调函数中接收的`results`传值回`Generator`函数继续`Generator`函数的执行:\n\n```javascript\nif (err) {\n  return generator.throw(err);\n}\nconst results = [].slice.call(arguments, 1);\ngenerator.next(results.length > 1 ? results : results[0]);\n```\n\n为了说明这个简单的辅助函数的强大，我们创建一个叫做`clone.js`的新模块，这个模块只是创建它本身的克隆。粘贴我们刚才创建的`asyncFlow()`函数，核心代码如下：\n\n```javascript\nconst fs = require('fs');\nconst path = require('path');\nasyncFlow(function*(callback) {\n  const fileName = path.basename(__filename);\n  const myself = yield fs.readFile(fileName, 'utf8', callback);\n  yield fs.writeFile(`clone_of_${filename}`, myself, callback);\n  console.log('Clone created');\n});\n```\n\n明显地，有了`asyncFlow()`函数的帮助，我们可以像我们书写同步阻塞函数一样用同步的方式来书写异步代码了。并且这个结果背后的原理显得很清楚。一旦异步操作结束，传递给每个异步函数的回调函数将继续`Generator`函数的执行。没有什么复杂的，但是结果确实很令人意外。\n\n这个技术有其他两个变化，一个是`Promise`的使用，另外一个则是`thunks`。\n\n> 在基于Generator的控制流中使用的thunk只是一个简单的函数，它除了回调之外，部分地应用了原始函数的所有参数。返回值是另一个只接受回调作为参数的函数。例如，fs.readFile（）的thunkified版本如下所示：\n\n```javascript\nfunction readFileThunk(filename, options) {\n  return function(callback) {\n    fs.readFile(filename, options, callback);\n  }\n}\n```\n\n`thunk`和`Promise`都允许我们创建不需要回调的`Generator`函数作为参数传递，例如，使用`thunk`的`asyncFlow()`版本如下：\n\n```javascript\nfunction asyncFlowWithThunks(generatorFunction) {\n  function callback(err) {\n    if (err) {\n      return generator.throw(err);\n    }\n    const results = [].slice.call(arguments, 1);\n    const thunk = generator.next(results.length > 1 ? results : results[0]).value;\n    thunk && thunk(callback);\n  }\n  const generator = generatorFunction();\n  const thunk = generator.next().value;\n  thunk && thunk(callback);\n}\n```\n\n这个技巧是读取`generator.next()`的返回值，返回值中包含`thunk`。下一步是通过注入特殊的回调函数调用`thunk`本身。这允许我们写下面的代码：\n\n```javascript\nasyncFlowWithThunk(function*() {\n  const fileName = path.basename(__filename);\n  const myself = yield readFileThunk(__filename, 'utf8');\n  yield writeFileThunk(`clone_of_${fileName}`, myself);\n  console.log(\"Clone created\")\n});\n```\n\n### 使用co的基于Gernator的控制流\n你应该已经猜到了，`Node.js`生态系统会借助`Generator`函数来提供一些处理异步控制流的解决方案，例如，[suspend](https://npm/js.org/package/suspend)是其中一个最老的支持`Promise`、`thunks`和`Node.js`风格回调函数和正常风格的回调函数的 库。还有，大部分我们之前分析的`Promise`库都提供工具函数使得`Generator`和`Promise`可以一起使用。\n\n我们选择[co](https://npmjs.org/package/co)作为本章节的例子。它支持很多类型的`yieldables`，其中一些是：\n\n* `Thunks`\n* `Promises`\n* `Arrays`(并行执行)\n* `Objects`(并行执行)\n* `Generators`(委托)\n* `Generator`函数(委托)\n\n还有很多框架或库是基于`co`生态系统的，包括以下一些：\n\n* `Web框架`，最流行的是[koa](https://npmjs.org/package/koa)\n* 实现特定控制流模式的库\n* 包装流行的`API`兼容`co`的库\n\n我们使用`co`重新实现我们的`Generator`版本的`Web爬虫应用程序`。\n\n为了将`Node.js`风格的函数转换成`thunks`，我们将会使用一个叫做[thunkify](https://npmjs.org/package/thunkify)的库。\n\n### 顺序执行\n让我们通过修改`Web爬虫应用程序`的版本2开始我们对`Generator`函数和`co`的实际探索。我们要做的第一件事就是加载我们的依赖包，并生成我们要使用的函数的`thunkified`版本。这些将在`spider.js`模块的最开始进行：\n\n```javascript\nconst thunkify = require('thunkify');\nconst co = require('co');\nconst request = thunkify(require('request'));\nconst fs = require('fs');\nconst mkdirp = thunkify(require('mkdirp'));\nconst readFile = thunkify(fs.readFile);\nconst writeFile = thunkify(fs.writeFile);\nconst nextTick = thunkify(process.nextTick);\n```\n\n看上述代码，我们可以注意到与本章前面`promisify`化的`API`的代码的一些相似之处。在这一点上，有意思的是，如果我们使用我们的`promisified`版本的函数来代替`thunkified`的版本，代码将保持完全一样，这要归功于`co`支持`thunk`和`Promise`对象作为`yieldable`对象。事实上，如果我们想，甚至可以在同一个应用程序中使用`thunk`和`Promise`，即使在同一个`Generator`函数中。就灵活性而言，这是一个巨大的优势，因为它使我们能够使用基于`Generator`函数的控制流来解决我们应用程序中的问题。\n\n好的，现在让我们开始将`download()`函数转换为一个`Generator`函数：\n\n```javascript\nfunction* download(url, filename) {\n  console.log(`Downloading ${url}`);\n  const response = yield request(url);\n  const body = response[1];\n  yield mkdirp(path.dirname(filename));\n  yield writeFile(filename, body);\n  console.log(`Downloaded and saved ${url}`);\n  return body;\n}\n```\n\n通过使用`Generator`和`co`，我们的`download()`函数变得简单多了。当我们需要做异步操作的时候，我们使用异步的`Generator`函数作为`thunk`来把之前的内容转化到`Generator`函数，并使用`yield`子句。\n\n然后我们开始实现我们的`spider()`函数：\n\n```javascript\nfunction* spider(url, nesting) {\n  cost filename = utilities.urlToFilename(url);\n  let body;\n  try {\n    body = yield readFile(filename, 'utf8');\n  } catch (err) {\n    if (err.code !== 'ENOENT') {\n      throw err;\n    }\n    body = yield download(url, filename);\n  }\n  yield spiderLinks(url, body, nesting);\n}\n```\n\n从上述代码中一个有趣的细节是我们可以使用`try...catch`语句块来处理异常。我们还可以使用`throw`来传播异常。另外一个细节是我们`yield`我们的`download()`函数，而这个函数既不是一个`thunk`，也不是一个`promisified`函数，只是另外的一个`Generator`函数。这也毫无问题，由于`co`也支持其他`Generators`作为`yieldables`。\n\n最后转换`spiderLinks()`，在这个函数中，我们递归下载一个网页的链接。在这个函数中使用`Generators`，显得简单多了：\n\n```javascript\nfunction* spiderLinks(currentUrl, body, nesting) {\n  if (nesting === 0) {\n    return nextTick();\n  }\n  const links = utilities.getPageLinks(currentUrl, body);\n  for (let i = 0; i < links.length; i++) {\n    yield spider(links[i], nesting - 1);\n  }\n}\n```\n\n看上述代码。虽然顺序迭代没有什么模式可以展示。`Generator`和`co`辅助我们做了很多，方便了我们可以使用同步方式开书写异步代码。\n\n看最重要的部分，程序的入口：\n\n```javascript\nco(function*() {\n  try {\n    yield spider(process.argv[2], 1);\n    console.log(`Download complete`);\n  } catch (err) {\n    console.log(err);\n  }\n});\n```\n\n这是唯一一处需要调用`co(...)`来封装的一个`Generator`。实际上，一旦我们这么做，`co`会自动封装我们传递给`yield`语句的任何`Generator`函数，并且这个过程是递归的，所以程序的剩余部分与我们是否使用`co`是完全无关的，虽然是被`co`封装在里面。\n\n现在应该可以运行使用`Generator`函数改写的`Web爬虫应用程序`了。\n\n### 并行执行\n不幸的是，虽然`Generator`很方便地进行顺序执行，但是不能直接用来并行化执行一组任务，至少不能仅仅使用`yield`和`Generator`。之前，在种情况下我们使用的模式只是简单地依赖于一个基于回调或者`Promise`的函数，但使用了`Generator`函数后，一切会显得更简单。\n\n幸运的是，如果不限制并发数的并行执行，`co`已经可以通过`yield`一个`Promise`对象、`thunk`、`Generator`函数，甚至包含`Generator`函数的数组来实现。\n\n考虑到这一点，我们的`Web爬虫应用程序`第三版可以通过重写`spiderLinks()`函数来做如下改动：\n\n```javascript\nfunction* spiderLinks(currentUrl, body, nesting) {\n  if (nesting === 0) {\n    return nextTick();\n  }\n  const links = utilities.getPageLinks(currentUrl, body);\n  const tasks = links.map(link => spider(link, nesting - 1));\n  yield tasks;\n}\n```\n\n但是上述函数所做的只是拿到所有的任务，这些任务本质上都是通过`Generator`函数来实现异步的，如果在`co`的`thunk`内对一个包含`Generator`函数的数组使用`yield`，这些任务都会并行执行。外层的`Generator`函数会等到`yield`子句的所有异步任务并行执行后再继续执行。\n\n接下来我们看怎么用一个基于回调函数的方式来解决相同的并行流。我们用这种方式重写`spiderLinks()`函数：\n\n```javascript\nfunction spiderLinks(currentUrl, body, nesting) {\n  if (nesting === 0) {\n    return nextTick();\n  }\n  // 返回一个thunk\n  return callback => {\n    let completed = 0,\n      hasErrors = false;\n    const links = utilities.getPageLinks(currentUrl, body);\n    if (links.length === 0) {\n      return process.nextTick(callback);\n    }\n\n    function done(err, result) {\n      if (err && !hasErrors) {\n        hasErrors = true;\n        return callback(err);\n      }\n      if (++completed === links.length && !hasErrors) {\n        callback();\n      }\n    }\n    for (let i = 0; i < links.length; i++) {\n      co(spider(links[i], nesting - 1)).then(done);\n    }\n  }\n}\n```\n\n我们使用`co`并行运行`spider()`函数，调用`Generator`函数返回了一个`Promise`对象。这样，等待`Promise`完成后调用`done()`函数。通常，基于`Generator`控制流的库都有这一功能，因此如果需要，你总是可以将一个`Generator`转换成一个基于回调或基于`Promise`的函数。\n\n为了并行开启多个下载任务，我们只要重用在前面定义的基于回调的并行执行的模式。我们应该也注意到我们将`spiderLinks()`转换成一个`thunk`(而不再是一个`Generator`函数)。这使得当全部并行任务完成时，我们有一个回调函数可以调用。\n\n> 上面讲到的是将一个Generator函数转换为一个thunk的模式，使之能够支持其他的基于回调或基于Promise的控制流算法，并可以通过同步阻塞的代码风格书写异步代码。\n\n### 限制并行执行\n现在我们知道如何处理异步执行流程，应该很容易规划我们的`Web爬虫应用程序`的第四版的实现，这个版本对并发下载任务的数量施加了限制。我们有几个方案可以用来做到这一点。其中一些方案如下：\n\n* 使用先前实现的基于回调的`TaskQueue`类。我们只需要`thunkify`我们的`Generator`函数和其提供的回调函数即可。\n* 使用基于`Promise`的`TaskQueue`类，并确保每个作为任务的`Generator`函数都被转换成一个返回`Promise`对象的函数。\n* 使用`async`，`thunkify`我们打算使用的工具函数，此外还需要把我们用到的`Generator`函数转化为基于回调的模式，以便于能够被这个库较好地使用。\n* 使用基于`co`的生态系统中的库，特别是专门为这种场景的库，如[co-limiter](https://npmjs.org/package/co-limiter)。\n* 实现基于生产者 - 消费者模型的自定义算法，这与`co-limiter`的内部实现原理相同。\n\n为了学习，我们选择最后一个方案，甚至帮助我们可以更好地理解一种经常与协程(也和线程和进程)同步相关的模式。\n\n### 生产者 - 消费者模式\n我们的目标是利用队列来提供固定数量的`workers`，与我们想要设置的并发级别一样多。为了实现这个算法，我们将基于本章前面定义的`TaskQueue`类改写：\n\n```javascript\nclass TaskQueue {\n  constructor(concurrency) {\n    this.concurrency = concurrency;\n    this.running = 0;\n    this.taskQueue = [];\n    this.consumerQueue = [];\n    this.spawnWorkers(concurrency);\n  }\n  pushTask(task) {\n    if (this.consumerQueue.length !== 0) {\n      this.consumerQueue.shift()(null, task);\n    } else {\n      this.taskQueue.push(task);\n    }\n  }\n  spawnWorkers(concurrency) {\n    const self = this;\n    for (let i = 0; i < concurrency; i++) {\n      co(function*() {\n        while (true) {\n          const task = yield self.nextTask();\n          yield task;\n        }\n      });\n    }\n  }\n  nextTask() {\n    return callback => {\n      if (this.taskQueue.length !== 0) {\n        return callback(null, this.taskQueue.shift());\n      }\n      this.consumerQueue.push(callback);\n    }\n  }\n}\n```\n\n让我们分析这个`TaskQueue`类的新实现。首先是在构造函数中。需要调用一次`this.spawnWorkers()`，因为这是启动`worker`的方法。\n\n我们的`worker`很简单，它们只是用`co()`包装的立即执行的`Generator`函数，所以每个`Generator`函数可以并行执行。在内部，每个`worker`正在运行在一个死循环（`while(true){}`）中，一直阻塞（`yield`）到新任务在队列中可用时（`yield self.nextTask()`），一旦可以执行新任务，`yield`这个异步任务直到其完成。您可能想知道我们如何能够限制并行执行，并让下一个任务在队列中处于等待状态。答案是在`nextTask()`方法中。我们来详细地看看在这个方法的原理：\n\n```javascript\nnextTask() {\n  return callback => {\n    if (this.taskQueue.length !== 0) {\n      return callback(null, this.taskQueue.shift());\n    }\n    this.consumerQueue.push(callback);\n  }\n}\n```\n\n我们看这个函数内部发生了什么，这才是这个模式的核心：\n\n1. 这个方法返回一个对于`co`而言是一个合法的`yieldable`的`thunk`。\n2. 只要`taskQueue`类生成的实例中还有下一个任务，`thunk`的回调函数会被立即调用。回调函数调用时，立马解锁一个`worker`的阻塞状态，`yield`这一个任务。\n3. 如果队列中没有任务了，回调函数本身会被放入`consumerQueue`中。通过这种做法，我们将一个`worker`置于空闲（`idle`）的模式。一旦我们有一个新的任务来要处理，在`consumerQueue`队列中的回调函数会被调用，立马唤醒我们这一`worker`进行异步处理。\n\n现在，为了理解`consumerQueue`队列中的空闲`worker`是如何恢复工作的，我们需要分析`pushTask()`方法。如果当前有回调函数可用的话，`pushTask()`方法将调用`consumerQueue`队列中的第一个回调函数，从而将取消对`worker`的锁定。如果没有可用的回调函数，这意味着所有的`worker`都是工作状态，只需要添加一个新的任务到`taskQueue`任务队列中。\n\n在`TaskQueue`类中，`worker`充当消费者的角色，而调用`pushTask()`函数的角色可以被认为是生产者。这个模式向我们展示了一个`Generator`函数实际上可以跟一个线程或进程类似。实际上，生产者 - 消费者之间问题是研究进程间通信和同步时最常见的问题，但正如我们已经提到的那样，它对于进程和线程来说，也是一个常见的例子。\n\n### 限制下载任务的并发量\n既然我们已经使用`Generator`函数和生产者 - 消费者模型实现一个限制并行算法，并且已经在`Web爬虫应用程序`第四版应用它来限制中下载任务的并发数。 首先，我们加载和初始化一个`TaskQueue`对象：\n\n```javascript\nconst TaskQueue = require('./taskQueue');\nconst downloadQueue = new TaskQueue(2);\n```\n\n然后，修改`spiderLinks()`函数。和之前不限制并发的版本类似，所以这里我们只展示修改的部分，主要是通过调用新版本的`TaskQueue`类生成的实例的`pushTask()`方法来限制并行执行：\n\n```javascript\nfunction spiderLinks(currentUrl, body, nesting) {\n  //...\n  return (callback) => {\n    //...\n    function done(err, result) {\n      //...\n    }\n    links.forEach(function(link) {\n      downloadQueue.pushTask(function*() {\n        yield spider(link, nesting - 1);\n        done();\n      });\n    });\n  }\n}\n```\n\n在每个任务中，我们在下载完成后立即调用`done()`函数，因此我们可以计算下载了多少个链接，然后在完成下载时通知`thunk`的回调函数执行。\n\n## 配合Babel使用Async await新语法\n回调函数、`Promise`和`Generator`函数都是用于处理`JavaScript`和`Node.js`异步问题的方式。正如我们所看到的，`Generator`的真正意义在于它提供了一种方式来暂停一个函数的执行，然后等待前面的任务完成后再继续执行。我们可以使用这样的特性来书写异步代码，并且让开发者用同步阻塞的代码风格来书写异步代码。等到异步操作的结果返回后才恢复当前函数的执行。\n\n但`Generator`函数是更多的是用来处理迭代器，然而迭代器在异步代码的使用显得有点笨重。代码可能难以理解，导致代码易读性和可维护性差。\n\n但在不远的将来会有一种更加简洁的语法。实际上，这个提议即将引入到`ESMASCript 2017`的规范中，这项规范定义了`async`函数语法。\n\n`async`函数规范引入两个关键字(`async`和`await`)到原生的`JavaScript`语言中，改进我们书写异步代码的方式。\n\n为了理解这项语法的用法和优势为，我们看一个简单的例子：\n\n```javascript\nconst request = require('request');\n\nfunction getPageHtml(url) {\n  return new Promise(function(resolve, reject) {\n    request(url, function(error, response, body) {\n      resolve(body);\n    });\n  });\n}\nasync function main() {\n  const html = await getPageHtml('http://google.com');\n  console.log(html);\n}\n\nmain();\nconsole.log('Loading...');\n```\n\n在上述代码中，有两个函数：`getPageHtml`和`main`。第一个函数的作用是提取给定`URL`的一个远程网页的`HTML`文档代码。值得注意的是，这个函数返回一个`Promise`对象。\n\n重点在于`main`函数，因为在这里使用了`async`和`await`关键字。首先要注意的是函数要以`async`关键字为前缀。意思是这个函数执行的是异步代码并且允许它在函数体内使用`await`关键字。`await`关键字在`getPageHtml`调用之前，告诉`JavaScript`解释器在继续执行下一条指令之前，等待`getPageHtml`返回的`Promise`对象的结果。这样，`main`函数内部哪部分代码是异步的，它会等待异步代码的完成再继续执行后续操作，并且不会阻塞这段程序其余部分的正常执行。实际上，控制台会打印字符串`Loading...`，随后是Google主页的`HTML`代码。\n\n是不是这种方法的可读性更好并且更容易理解呢? 不幸地是，这个提议尚未定案，即使通过这个提议，我们需要等下一个版本\n的`ECMAScript`规范出来并把它集成到`Node.js`后，才能使用这个新语法。 所以我们今天做了什么?只是漫无目的地等待?不是，当然不是！我们已经可以在我们的代码中使用`async await`语法，只要我们使用`Babel`。\n\n### 安装与运行Babel\n`Babel`是一个`JavaScript`编译器(或翻译器)，能够使用语法转换器将高版本的`JavaScript`代码转换成其他`JavaScript`代码。语法转换器允许例如我们书写并使用`ES2015`，`ES2016`，`JSX`和其它的新语法，来翻译成往后兼容的代码，在`JavaScript`运行环境如浏览器或`Node.js`中都可以使用`Babel`。\n\n在项目中使用`npm`安装`Babel`，命令如下：\n\n```\nnpm install --save-dev babel-cli\n```\n\n我们还需要安装插件以支持`async await`语法的解释或翻译：\n\n```\nnpm install --save-dev babel-plugin-syntax-async-functions babel-plugin-tranform-async-to-generator\n```\n\n现在假设我们想运行我们之前的例子（称为`index.js`）。我们需要通过以下命令启动：\n\n```\nnode_modules/.bin/babel-node --plugins \"syntax-async-functions,transform-async-to-generator\" index.js\n```\n\n这样，我们使用支持`async await`的转换器动态地转换源代码。`Node.js`运行的实际是保存在内存中的往后兼容的代码。\n\n`Babel`也能被配置为一个代码构建工具，保存翻译或解释后的代码到本地文件系统中，便于我们部署和运行生成的代码。\n\n> 关于如何安装和配置Babel，可以到官方网站 https://babeljs.io 查阅相关文档。\n\n## 几种方式的比较\n现在，我们应该对于怎么处理`JavaScript`的异步问题有了一个更好的认识和总结。在下面的表格中总结几大机制的优势和劣势：\n\n![](http://oczira72b.bkt.clouddn.com/17-11-7/55293366.jpg)\n\n> 值得一提的是，我们选择在本章中仅介绍处理异步控制流程的最受欢迎的解决方案，或者是广泛使用的解决方案，但是例如Fibers（ https://npmjs.org/package/fibers ）和Streamline（ https://npmjs.org/p ackage/streamline ）也是值得一看的。\n\n## 总结\n在本章中，我们分析了一些处理异步控制流的方法，分析了`Promise`、`Generator`函数和即将到来的`async await`语法。\n\n我们学习了如何使用这些方法编写更简洁，更具有可读性的异步代码。我们讨论了这些方法的一些最重要的优点和缺点，并认识到即使它们非常有用，也需要一些时间来掌握。这就是这几种方式也没有完全取代在许多情况下仍然非常有用的回调的原因。作为一名开发人员，应该按照实际情况分析决定使用哪种解决方案。如果您正在构建执行异步操作的公共库，则应该提供易于使用的`API`，即使对于只想使用回调的开发人员也是如此。\n\n在下一章中，我们将探讨另一个与异步代码执行相关的机制，这也是整个`Node.js`生态系统中的另一个基本构建块：`streams`。","MarkdownContent":"<h1 id=\"asynchronous-control-flow-patterns-with-es2015-and-beyond\">Asynchronous Control Flow Patterns with ES2015 and Beyond</h1>\n<p>在上一章中，我们学习了如何使用回调处理异步代码，以及如何解决如回调地狱代码等异步问题。回调是<code>JavaScript</code>和<code>Node.js</code>中的异步编程的基础，但是现在，其他替代方案已经出现。这些替代方案更复杂，以便能够以更方便的方式处理异步代码。</p>\n<p>在本章中，我们将探讨一些代表性的替代方案，<code>Promise</code>和<code>Generator</code>。以及<code>async await</code>，这是一种创新的语法，可在高版本的<code>JavaScript</code>中提供，其也作为<code>ECMAScript 2017</code>发行版的一部分。</p>\n<p>我们将看到这些替代方案如何简化处理异步控制流的方式。最后，我们将比较所有这些方法，以了解所有这些方法的所有优点和缺点，并能够明智地选择最适合我们下一个<code>Node.js</code>项目要求的方法。</p>\n<h2 id=\"promise\">Promise</h2>\n<p>我们在前面的章节中提到，<code>CPS风格</code>不是编写异步代码的唯一方法。事实上，<code>JavaScript</code>生态系统为传统的回调模式提供了有趣的替代方案。最着名的选择之一是<code>Promise</code>，特别是现在它是<code>ECMAScript 2015</code>的一部分，并且现在可以在<code>Node.js</code>中可用。</p>\n<h3 id=\"-promise-\">什么是Promise？</h3>\n<p><code>Promise</code>是一种抽象的对象，我们通常允许函数返回一个名为<code>Promise</code>的对象，它表示异步操作的最终结果。通常情况下，我们说当异步操作尚未完成时，我们说<code>Promise</code>对象处于<code>pending</code>状态，当操作成功完成时，我们说<code>Promise</code>对象处于<code>resolve</code>状态，当操作错误终止时，我们说<code>Promise</code>对象处于<code>reject</code>状态。一旦<code>Promise</code>处于<code>resolve</code>或<code>reject</code>，我们认为当前异步操作结束。</p>\n<p>为了接收到异步操作的正确结果或错误捕获，我们可以使用<code>Promise</code>的<code>then</code>方法：</p>\n<pre><code class=\"lang-javascript\">promise.then([onFulfilled], [onRejected])\n</code></pre>\n<p>在前面的代码中，<code>onFulfilled()</code>是一个函数，最终会收到<code>Promise</code>的正确结果，而<code>onRejected()</code>是另一个函数，它将接收产生异常的原因（如果有的话）。两个参数都是可选的。</p>\n<p>要了解<code>Promise</code>如何转换我们的代码，让我们考虑以下几点：</p>\n<pre><code class=\"lang-javascript\">asyncOperation(arg, (err, result) =&gt; {\n  if (err) {\n    // 错误处理\n  }\n  // 正常结果处理\n});\n</code></pre>\n<p><code>Promise</code>允许我们将这个典型的<code>CPS</code>代码转换成更好的结构化和更优雅的代码，如下所示：</p>\n<pre><code class=\"lang-javascript\">asyncOperation(arg)\n  .then(result =&gt; {\n    // 错误处理\n  }, err =&gt; {\n    // 正常结果处理\n  });\n</code></pre>\n<p><code>then()</code>方法的一个关键特征是它同步地返回另一个<code>Promise</code>对象。如果<code>onFulfilled()</code>或<code>onRejected()</code>函数中的任何一个函数返回<code>x</code>，则<code>then()</code>方法返回的<code>Promise</code>对象将如下所示：</p>\n<ul>\n<li>如果<code>x</code>是一个值，则这个<code>Promise</code>对象会正确处理(<code>resolve</code>)<code>x</code></li>\n<li>如果<code>x</code>是一个<code>Promise</code>对象或<code>thenable</code>，则会正确处理(<code>resolve</code>)<code>x</code></li>\n<li>如果<code>x</code>是一个异常，则会捕获异常(<code>reject</code>)<code>x</code></li>\n</ul>\n<blockquote>\n<p>注：thenable是一个具有then方法的类似于Promise的对象(Promise-like)。</p>\n</blockquote>\n<p>这个特点使我们能够链式构建<code>Promise</code>，允许轻松排列组合我们的异步操作。另外，如果我们没有指定一个<code>onFulfilled()</code>或<code>onRejected()</code>处理程序，则正确结果或异常捕获将自动转发到<code>Promise</code>链的下一个<code>Promise</code>。例如，这允许我们在整个链中自动传播错误，直到被<code>onRejected()</code>处理程序捕获。随着<code>Promise</code>链，任务的顺序执行突然变成简单多了：</p>\n<pre><code class=\"lang-javascript\">asyncOperation(arg)\n  .then(result1 =&gt; {\n    // 返回另一个Promise\n    return asyncOperation(arg2);\n  })\n  .then(result2 =&gt; {\n    // 返回一个值\n    return &#39;done&#39;;\n  })\n  .then(undefined, err =&gt; {\n    // 捕获Promise链中的异常\n  });\n</code></pre>\n<p>下图展示了链式<code>Promise</code>如何工作：</p>\n<p><img src=\"http://oczira72b.bkt.clouddn.com/17-10-31/46370382.jpg\" alt=\"\"></p>\n<p><code>Promise</code>的另一个重要特性是<code>onFulfilled()</code>和<code>onRejected()</code>函数是异步调用的，如同上述的例子，在最后那个<code>then</code>函数<code>resolve</code>一个同步的<code>Promise</code>，它也是同步的。这种模式避免了<code>Zalgo</code>（参见<code>Chapter2-Node.js Essential Patterns</code>），使我们的异步代码更加一致和稳健。</p>\n<p>如果在<code>onFulfilled()</code>或<code>onRejected()</code>处理程序中抛出异常（使用<code>throw</code>语句），则<code>then()</code>方法返回的<code>Promise</code>将被自动地<code>reject</code>，抛出异常作为<code>reject</code>的原因。这相对于<code>CPS</code>来说是一个巨大的优势，因为它意味着有了<code>Promise</code>，异常将在整个链中自动传播，并且<code>throw</code>语句终于可以使用。</p>\n<p>在以前，许多不同的库实现了<code>Promise</code>，大多数时候它们之间不兼容，这意味着不可能在使用不同<code>Promise</code>库的<code>thenable</code>链式传播错误。</p>\n<p><code>JavaScript</code>社区非常努力地解决了这个限制，这些努力导致了<code>Promises / A +</code>规范的创建。该规范详细描述了<code>then</code>方法的行为，提供了一个可互兼容的基础，这使得来自不同库的<code>Promise</code>对象能够彼此兼容，开箱即用。</p>\n<p>有关<code>Promises / A +</code>规范的详细说明，可以参考<a href=\"https://promisesaplus.com\">Promises / A + 官方网站</a>。</p>\n<h3 id=\"promise-a-\">Promise / A + 的实施</h3>\n<p>在<code>JavaScript</code>中以及<code>Node.js</code>中，有几个实现<code>Promises / A +</code>规范的库。以下是最受欢迎的：</p>\n<ul>\n<li><a href=\"https://npmjs.org/package/bluebird\">Bluebird</a></li>\n<li><a href=\"https://npmjs.org/package/q\">Q</a></li>\n<li><a href=\"https://npmjs.org/package/rsvp\">RSVP</a></li>\n<li><a href=\"https://npmjs.org/package/vow\">Vow</a></li>\n<li><a href=\"https://npmjs.org/package/when\">When.js</a></li>\n<li>ES2015 promises</li>\n</ul>\n<p>真正区别他们的是在<code>Promises / A +</code>标准之上提供的额外功能。正如我们上述所说的那样，该标准定义了<code>then()</code>方法和<code>Promise</code>解析过程的行为，但它没有指定其他功能，例如，如何从基于回调的异步函数创建<code>Promise</code>。</p>\n<p>在我们的示例中，我们将使用由<code>ES2015</code>的<code>Promise</code>，因为<code>Promise</code>对象自<code>Node.js 4</code>后即可使用，而不需要任何库来实现。</p>\n<p>作为参考，以下是<code>ES2015</code>的<code>Promise</code>提供的API：</p>\n<p><code>constructor</code>(<code>new Promise（function（resolve, reject）{}）</code>)：创建了一个新的<code>Promise</code>，它基于作为传递两个类型为函数的参数来决定<code>resolve</code>或<code>reject</code>。构造函数的参数解释如下：</p>\n<ul>\n<li><code>resolve(obj)</code> ：<code>resolve</code>一个<code>Promise</code>，并带上一个参数<code>obj</code>，如果<code>obj</code>是一个值，这个值就是传递的异步操作成功的结果。如果<code>obj</code>是一个<code>Promise</code>或一个<code>thenable</code>，则会进行正确处理。</li>\n<li><code>reject(err)</code>：<code>reject</code>一个<code>Promise</code>，并带上一个参数<code>err</code>。它是<code>Error</code>对象的一个实例。</li>\n</ul>\n<h4 id=\"promise-\">Promise对象的静态方法</h4>\n<ul>\n<li><code>Promise.resolve(obj)</code>： 将会创建一个<code>resolve</code>的<code>Promise</code>实例</li>\n<li><code>Promise.reject(err)</code>： 将会创建一个<code>reject</code>的<code>Promise</code>实例</li>\n<li><code>Promise.all(iterable)</code>：返回一个新的<code>Promise</code>实例，并且在<code>iterable</code>中所\n有<code>Promise</code>状态为<code>reject</code>时, 返回的<code>Promise</code>实例的状态会被置为<code>reject</code>，如果<code>iterable</code>中至少有一个<code>Promise</code>状态为<code>reject</code>时, 返回的<code>Promise</code>实例状态也会被置为<code>reject</code>，并且<code>reject</code>的原因是第一个被<code>reject</code>的<code>Promise</code>对象的<code>reject</code>原因。</li>\n<li><code>Promise.race(iterable)</code>：返回一个<code>Promise</code>实例，当<code>iterable</code>中任何一个<code>Promise</code>被<code>resolve</code>或被<code>reject</code>时， 返回的<code>Promise</code>实例以同样的原因<code>resolve</code>或<code>reject</code>。</li>\n</ul>\n<h4 id=\"promise-\">Promise实例方法</h4>\n<ul>\n<li><code>Promise.then(onFulfilled, onRejected)</code>：这是<code>Promise</code>的基本方法。它的行为与我们之前描述的<code>Promises / A +</code>标准兼容。</li>\n<li><code>Promise.catch(onRejected)</code>：这只是<code>Promise.then(undefined，onRejected)</code>的语法糖。</li>\n</ul>\n<blockquote>\n<p>值得一提的是，一些Promise实现提供了另一种机制来创建新的Promise，称为deferreds。我们不会在这里描述，因为它不是ES2015标准的一部分，但是如果您想了解更多信息，可以阅读Q文档 (<a href=\"https://github.com/kriskowal/q#using-deferreds\">https://github.com/kriskowal/q#using-deferreds</a>) 或When.js文档 (<a href=\"https://github.com/cujojs/when/wiki/Deferred\">https://github.com/cujojs/when/wiki/Deferred</a>) 。</p>\n</blockquote>\n<h3 id=\"promisifying-node-js-\">Promisifying一个Node.js回调风格的函数</h3>\n<p>在<code>JavaScript</code>中，并不是所有的异步函数和库都支持开箱即用的<code>Promise</code>。大多数情况下，我们必须将一个典型的基于回调的函数转换成一个返回<code>Promise</code>的函数，这个过程也被称为<code>promisification</code>。</p>\n<p>幸运的是，<code>Node.js</code>中使用的回调约定允许我们创建一个可重用的函数，我们通过使用<code>Promise</code>对象的构造函数来简化任何<code>Node.js</code>风格的<code>API</code>。让我们创建一个名为<code>promisify()</code>的新函数，并将其包含到<code>utilities.js</code>模块中（以便稍后在我们的<code>Web爬虫应用程序</code>中使用它）：</p>\n<pre><code class=\"lang-javascript\">module.exports.promisify = function(callbackBasedApi) {\n  return function promisified() {\n    const args = [].slice.call(arguments);\n    return new Promise((resolve, reject) =&gt; {\n      args.push((err, result) =&gt; {\n        if (err) {\n          return reject(err);\n        }\n        if (arguments.length &lt;= 2) {\n          resolve(result);\n        } else {\n          resolve([].slice.call(arguments, 1));\n        }\n      });\n      callbackBasedApi.apply(null, args);\n    });\n  }\n};\n</code></pre>\n<p>前面的函数返回另一个名为<code>promisified()</code>的函数，它表示输入中给出的<code>callbackBasedApi</code>的<code>promisified</code>版本。以下展示它是如何工作的：</p>\n<ol>\n<li><code>promisified()</code>函数使用<code>Promise</code>构造函数创建一个新的<code>Promise</code>对象，并立即将其返回给调用者。</li>\n<li>在传递给<code>Promise</code>构造函数的函数中，我们确保传递给<code>callbackBasedApi</code>，这是一个特殊的回调函数。由于我们知道回调总是最后调用的，我们只需将回调函数附加到提供给<code>promisified()</code>函数的参数列表里（<code>args</code>）。</li>\n<li>在特殊的回调中，如果我们收到错误，我们立即<code>reject</code>这个<code>Promise</code>。</li>\n<li>如果没有收到错误，我们使用一个值或一个数组值来<code>resolve</code>这个<code>Promise</code>，具体取决于传递给回调的结果数量。</li>\n<li>最后，我们只需使用我们构建的参数列表调用<code>callbackBasedApi</code>。</li>\n</ol>\n<blockquote>\n<p>大部分的Promise已经提供了一个开箱即用的接口来将一个Node.js风格的API转换成一个返回Promise的API。例如，Q有Q.denodeify()和Q.nbind()，Bluebird有Promise.promisify()，而When.js有node.lift()。</p>\n</blockquote>\n<h3 id=\"-\">顺序执行</h3>\n<p>在一些必要的理论之后，我们现在准备将我们的<code>Web爬虫应用程序</code>转换为使用<code>Promise</code>的形式。让我们直接从版本2开始，直接下载一个Web网页的链接。</p>\n<p>在<code>spider.js</code>模块中，第一步是加载我们的<code>Promise</code>实现（我们稍后会使用它）和<code>Promisifying</code>我们打算使用的基于回调的函数：</p>\n<pre><code class=\"lang-javascript\">const utilities = require(&#39;./utilities&#39;);\nconst request = utilities.promisify(require(&#39;request&#39;));\nconst mkdirp = utilities.promisify(require(&#39;mkdirp&#39;));\nconst fs = require(&#39;fs&#39;);\nconst readFile = utilities.promisify(fs.readFile);\nconst writeFile = utilities.promisify(fs.writeFile);\n</code></pre>\n<p>现在，我们开始更改我们的<code>download</code>函数：</p>\n<pre><code class=\"lang-javascript\">function download(url, filename) {\n  console.log(`Downloading ${url}`);\n  let body;\n  return request(url)\n    .then(response =&gt; {\n      body = response.body;\n      return mkdirp(path.dirname(filename));\n    })\n    .then(() =&gt; writeFile(filename, body))\n    .then(() =&gt; {\n      console.log(`Downloaded and saved: ${url}`);\n      return body;\n    });\n}\n</code></pre>\n<p>这里要注意的到的最重要的是我们也为<code>readFile()</code>返回的<code>Promise</code>注册\n一个<code>onRejected()</code>函数，用来处理一个网页没有被下载的情况(或文件不存在)。 还有，看我们如何使用<code>throw</code>来传递<code>onRejected()</code>函数中的错误的。</p>\n<p>既然我们已经更改我们的<code>spider()</code>函数，我们这么修改它的调用方式：</p>\n<pre><code class=\"lang-javascript\">spider(process.argv[2], 1)\n  .then(() =&gt; console.log(&#39;Download complete&#39;))\n  .catch(err =&gt; console.log(err));\n</code></pre>\n<p>注意我们是如何第一次使用<code>Promise</code>的语法糖<code>catch</code>来处理源自<code>spider()</code>函数的任何错误情况。如果我们再看看迄今为止我们所写的所有代码，那么我们会惊喜的发现，我们没有包含任何错误传播逻辑，因为我们在使用回调函数时会被迫做这样的事情。这显然是一个巨大的优势，因为它极大地减少了我们代码中的样板文件以及丢失任何异步错误的机会。</p>\n<p>现在，完成我们唯一缺失的<code>Web爬虫应用程序</code>的第二版的<code>spiderLinks()</code>函数，我们将在稍后实现它。</p>\n<h3 id=\"-\">顺序迭代</h3>\n<p>到目前为止，<code>Web爬虫应用程序</code>代码库主要是对<code>Promise</code>是什么以及如何使用的概述，展示了使用<code>Promise</code>实现顺序执行流程的简单性和优雅性。但是，我们现在考虑的代码只涉及到一组已知的异步操作的执行。所以，完成我们对顺序执行流程的探索的缺失部分是看我们如何使用<code>Promise</code>来实现迭代。同样，网络蜘蛛第二版的<code>spiderLinks()</code>函数也是一个很好的例子。</p>\n<p>让我们添加缺少的这一块：</p>\n<pre><code class=\"lang-javascript\">function spiderLinks(currentUrl, body, nesting) {\n  let promise = Promise.resolve();\n  if (nesting === 0) {\n    return promise;\n  }\n  const links = utilities.getPageLinks(currentUrl, body);\n  links.forEach(link =&gt; {\n    promise = promise.then(() =&gt; spider(link, nesting - 1));\n  });\n  return promise;\n}\n</code></pre>\n<p>为了异步迭代一个网页的全部链接，我们必须动态创建一个<code>Promise</code>的迭代链。</p>\n<ol>\n<li>首先，我们定义一个空的<code>Promise</code>，<code>resolve</code>为<code>undefined</code>。这个<code>Promise</code>只是用来作为<code>Promise</code>的迭代链的起始点。 </li>\n<li>然后，我们通过在循环中调用链中前一个<code>Promise</code>的<code>then()</code>方法获得的新的<code>Promise</code>来更新<code>Promise</code>变量。这就是我们使用<code>Promise</code>的异步迭代模式。</li>\n</ol>\n<p>这样，循环的结束，<code>promise</code>变量会包含循环中最后一个<code>then()</code>返回的<code>Promise</code>对象，所以它只有当<code>Promise</code>的迭代链中全部<code>Promise</code>对象被<code>resolve</code>后才能被<code>resolve</code>。</p>\n<blockquote>\n<p>注：在最后调用了这个then方法来resolve这个Promise对象</p>\n</blockquote>\n<p>通过这个，我们已使用<code>Promise</code>对象重写了我们的<code>Web爬虫应用程序</code>。我们现在应该可以运行它了。</p>\n<h3 id=\"-\">顺序迭代模式</h3>\n<p>为了总结这个顺序执行的部分，让我们提取一个模式来依次遍历一组<code>Promise</code>：</p>\n<pre><code class=\"lang-javascript\">let tasks = [ /* ... */ ]\nlet promise = Promise.resolve();\ntasks.forEach(task =&gt; {\n  promise = promise.then(() =&gt; {\n    return task();\n  });\n});\npromise.then(() =&gt; {\n  // 所有任务都完成\n});\n</code></pre>\n<p>使用<code>reduce()</code>方法来替代<code>forEach()</code>方法，允许我们写出更为简洁的代码：</p>\n<pre><code class=\"lang-javascript\">let tasks = [ /* ... */ ]\nlet promise = tasks.reduce((prev, task) =&gt; {\n  return prev.then(() =&gt; {\n    return task();\n  });\n}, Promise.resolve());\n\npromise.then(() =&gt; {\n  //All tasks completed\n});\n</code></pre>\n<p>与往常一样，通过对这种模式的简单调整，我们可以将所有任务的结果收集到一个数组中，我们可以实现一个<code>mapping</code>算法，或者构建一个<code>filter</code>等等。</p>\n<blockquote>\n<p>上述这个模式使用循环动态地建立一个链式的Promise。</p>\n</blockquote>\n<h3 id=\"-\">并行执行</h3>\n<p>另一个适合用<code>Promise</code>的执行流程是并行执行流程。实际上，我们需要做的就是使用内置的<code>Promise.all()</code>。这个方法创造了另一个<code>Promise</code>对象，只有在输入中的所有<code>Promise</code>都<code>resolve</code>时才能<code>resolve</code>。这是一个并行执行，因为在其参数<code>Promise</code>对象的之间没有执行顺序可言。</p>\n<p>为了演示这一点，我们来看我们的<code>Web爬虫应用程序</code>的第三版，它将页面中的所有链接并行下载。让我们再次使用<code>Promise</code>更新<code>spiderLinks()</code>函数来实现并行流程：</p>\n<pre><code class=\"lang-javascript\">function spiderLinks(currentUrl, body, nesting) {\n  if (nesting === 0) {\n    return Promise.resolve();\n  }\n  const links = utilities.getPageLinks(currentUrl, body);\n  const promises = links.map(link =&gt; spider(link, nesting - 1));\n  return Promise.all(promises);\n}\n</code></pre>\n<p>这里的模式在<code>elements.map()</code>迭代中产生一个数组，存放所有异步任务，之后便于同时启动<code>spider()</code>任务。这一次，在循环中，我们不等待以前的下载完成，然后开始一个新的下载任务：所有的下载任务在一个循环中一个接一个地开始。之后，我们利用<code>Promise.all()</code>方法，它返回一个新的<code>Promise</code>对象，当数组中的所有<code>Promise</code>对象都被<code>resolve</code>时，这个<code>Promise</code>对象将被<code>resolve</code>。换句话说，所有的下载任务完成，这正是我们想要的。</p>\n<h3 id=\"-\">限制并行执行</h3>\n<p>不幸的是，<code>ES2015</code>的<code>Promise API</code>并没有提供一种原生的方式来限制并发任务的数量，但是我们总是可以依靠我们所学到的有关用普通<code>JavaScript</code>来限制并发。事实上，我们在<code>TaskQueue</code>类中实现的模式可以很容易地被调整来支持返回承诺的任务。这很容易通过修改<code>next()</code>方法来完成：</p>\n<pre><code class=\"lang-javascript\">class TaskQueue {\n  constructor(concurrency) {\n    this.concurrency = concurrency;\n    this.running = 0;\n    this.queue = [];\n  }\n\n  pushTask(task) {\n    this.queue.push(task);\n    this.next();\n  }\n\n  next() {\n    while (this.running &lt; this.concurrency &amp;&amp; this.queue.length) {\n      const task = this.queue.shift();\n      task().then(() =&gt; {\n        this.running--;\n        this.next();\n      });\n      this.running++;\n    }\n  }\n}\n</code></pre>\n<p>不同于使用一个回调函数来处理任务，我们简单地调用<code>Promise</code>的<code>then()</code>。</p>\n<p>让我们回到<code>spider.js</code>模块，并修改它以支持我们的新版本的<code>TaskQueue</code>类。首先，我们确保定义一个<code>TaskQueue</code>的新实例：</p>\n<pre><code class=\"lang-javascript\">const TaskQueue = require(&#39;./taskQueue&#39;);\nconst downloadQueue = new TaskQueue(2);\n</code></pre>\n<p>然后，是我们的<code>spiderLinks()</code>函数。这里的修改也是很简单：</p>\n<pre><code class=\"lang-javascript\">function spiderLinks(currentUrl, body, nesting) {\n  if (nesting === 0) {\n    return Promise.resolve();\n  }\n  const links = utilities.getPageLinks(currentUrl, body);\n  // 我们需要如下代码，用于创建Promise对象\n  // 如果没有下列代码，当任务数量为0时，将永远不会resolve\n  if (links.length === 0) {\n    return Promise.resolve();\n  }\n  return new Promise((resolve, reject) =&gt; {\n    let completed = 0;\n    let errored = false;\n    links.forEach(link =&gt; {\n      let task = () =&gt; {\n        return spider(link, nesting - 1)\n          .then(() =&gt; {\n            if (++completed === links.length) {\n              resolve();\n            }\n          })\n          .catch(() =&gt; {\n            if (!errored) {\n              errored = true;\n              reject();\n            }\n          });\n      };\n      downloadQueue.pushTask(task);\n    });\n  });\n}\n</code></pre>\n<p>在上述代码中有几点值得我们注意的：</p>\n<ul>\n<li>首先，我们需要返回使用<code>Promise</code>构造函数创建的新的<code>Promise</code>对象。正如我们将看到的，这使我们能够在队列中的所有任务完成时手动<code>resolve</code>我们的<code>Promise</code>对象。</li>\n<li>然后，我们应该看看我们如何定义任务。我们所做的是将一个<code>onFulfilled()</code>回调函数的调用添加到由<code>spider()</code>返回的<code>Promise</code>对象中，所以我们可以计算完成的下载任务的数量。当完成的下载量与当前页面中链接的数量相同时，我们知道任务已经处理完毕，所以我们可以调用外部<code>Promise</code>的<code>resolve()</code>函数。</li>\n</ul>\n<blockquote>\n<p>Promises / A +规范规定，then()方法的onFulfilled()和onRejected()回调函数只能调用一次（仅调用onFulfilled()和onRejected()）。Promise接口的实现确保即使我们多次手动调用resolve或reject，Promise也仅可以被resolve或reject一次。</p>\n</blockquote>\n<p>现在，使用<code>Promise</code>的<code>Web爬虫应用程序</code>的第4版应该已经准备好了。我们可能再次注意到下载任务如何并行运行，并发数量限制为2。</p>\n<h3 id=\"-api-promise\">在公有API中暴露回调函数和Promise</h3>\n<p>正如我们在前面所学到的，<code>Promise</code>可以被用作回调函数的一个很好的替代品。它们使我们的代码更具可读性和易于理解。虽然<code>Promise</code>带来了许多优点，但也要求开发人员理解许多不易于理解的概念，以便正确和熟练地使用。由于这个原因和其他原因，在某些情况下，比起<code>Promise</code>来说，很多开发者更偏向于回调函数。</p>\n<p>现在让我们想象一下，我们想要构建一个执行异步操作的公共库。我们需要做什么？我们是创建了一个基于回调函数的<code>API</code>还是一个面向<code>Promise</code>的<code>API</code>？还是两者均有？</p>\n<p>这是许多知名的库所面临的问题，至少有两种方法值得一提，使我们能够提供一个多功能的<code>API</code>。</p>\n<p>像<code>request</code>，<code>redis</code>和<code>mysql</code>这样的库所使用的第一种方法是提供一个简单的基于回调函数的<code>API</code>，如果需要，开发人员可以选择公开函数。其中一些库提供工具函数来<code>Promise</code>化异步回调，但开发人员仍然需要以某种方式将暴露的<code>API</code>转换为能够使用<code>Promise</code>对象。</p>\n<p>第二种方法更透明。它还提供了一个面向回调的<code>API</code>，但它使回调参数可选。每当回调作为参数传递时，函数将正常运行，在完成时或失败时执行回调。当回调未被传递时，函数将立即返回一个<code>Promise</code>对象。这种方法有效地结合了回调函数和<code>Promise</code>，使得开发者可以在调用时选择采用什么接口，而不需要提前进行<code>Promise</code>化。许多库，如<code>mongoose</code>和<code>sequelize</code>，都支持这种方法。</p>\n<p>我们来看一个简单的例子。假设我们要实现一个异步执行除法的模块：</p>\n<pre><code class=\"lang-javascript\">module.exports = function asyncDivision(dividend, divisor, cb) {\n  return new Promise((resolve, reject) =&gt; { // [1]\n    process.nextTick(() =&gt; {\n      const result = dividend / divisor;\n      if (isNaN(result) || !Number.isFinite(result)) {\n        const error = new Error(&#39;Invalid operands&#39;);\n        if (cb) {\n          cb(error); // [2]\n        }\n        return reject(error);\n      }\n      if (cb) {\n        cb(null, result); // [3]\n      }\n      resolve(result);\n    });\n  });\n};\n</code></pre>\n<p>该模块的代码非常简单，但是有一些值得强调的细节：</p>\n<ul>\n<li>首先，返回使用<code>Promise</code>的构造函数创建的新承诺。我们在构造函数参数函数内定义全部逻辑。</li>\n<li>在发生错误的情况下，我们<code>reject</code>这个<code>Promise</code>，但如果回调函数在被调用时作为参数传递，我们也执行回调来进行错误传播。</li>\n<li>在计算结果之后，我们<code>resolve</code>了这个<code>Promise</code>，但是如果有回调函数，我们也会将结果传播给回调函数。</li>\n</ul>\n<p>我们现在看如何用回调函数和<code>Promise</code>来使用这个模块：</p>\n<pre><code class=\"lang-javascript\">// 回调函数的方式\nasyncDivision(10, 2, (error, result) =&gt; {\n  if (error) {\n    return console.error(error);\n  }\n  console.log(result);\n});\n\n// Promise化的调用方式\nasyncDivision(22, 11)\n  .then(result =&gt; console.log(result))\n  .catch(error =&gt; console.error(error));\n</code></pre>\n<p>应该很清楚的是，即将开始使用类似于上述的新模块的开发人员将很容易地选择最适合自己需求的风格，而无需在希望利用<code>Promise</code>时引入外部<code>promisification</code>功能。</p>\n<h2 id=\"generators\">Generators</h2>\n<p><code>ES2015</code>规范引入了另外一种机制，除了其他新功能外，还可以用来简化<code>Node.js</code>应用程序的异步控制流程。我们正在谈论<code>Generator</code>，也被称为<code>semi-coroutines</code>。它们是子程序的一般化，可以有不同的入口点。在一个正常的函数中，实际上我们只能有一个入口点，这个入口点对应着函数本身的调用。<code>Generator</code>与一般函数类似，但是可以暂停（使用<code>yield</code>语句），然后在稍后继续执行。在实现迭代器时，<code>Generator</code>特别有用，因为我们已经讨论了如何使用迭代器来实现重要的异步控制流模式，如顺序执行和限制并行执行。</p>\n<h3 id=\"generators-\">Generators基础</h3>\n<p>在我们探索使用<code>Generator</code>来实现异步控制流程之前，学习一些基本概念是很重要的。我们从语法开始吧。可以通过在函数关键字之后附加<code>*</code>（星号）运算符来声明<code>Generator</code>函数：</p>\n<pre><code class=\"lang-javascript\">function* makeGenerator() {\n  // body\n}\n</code></pre>\n<p>在<code>makeGenerator()</code>函数内部，我们可以使用关键字<code>yield</code>暂停执行并返回给调用者传递给它的值：</p>\n<pre><code class=\"lang-javascript\">function* makeGenerator() {\n  yield &#39;Hello World&#39;;\n  console.log(&#39;Re-entered&#39;);\n}\n</code></pre>\n<p>在前面的代码中，<code>Generator</code>通过<code>yield</code>一个字符串<code>Hello World</code>暂停当前函数的执行。当<code>Generator</code>恢复时，执行将从下列语句开始：</p>\n<pre><code class=\"lang-javascript\">console.log(&#39;Re-entered&#39;);\n</code></pre>\n<p><code>makeGenerator()</code>函数本质上是一个工厂，它在被调用时返回一个新的<code>Generator</code>对象：</p>\n<pre><code class=\"lang-javascript\">const gen = makeGenerator();\n</code></pre>\n<p>生成器对象的最重要的方法是<code>next()</code>，它用于启动/恢复<code>Generator</code>的执行，并返回如下形式的对象：</p>\n<pre><code>{\n  value: &lt;yielded value&gt;\n  done: &lt;true if the execution reached the end&gt;\n}\n</code></pre><p>这个对象包含<code>Generator</code> <code>yield</code>的值和一个指示<code>Generator</code>是否已经完成执行的符号。</p>\n<h3 id=\"-\">一个简单的例子</h3>\n<p>为了演示<code>Generator</code>，我们来创建一个名为<code>fruitGenerator.js</code>的新模块：</p>\n<pre><code class=\"lang-javascript\">function* fruitGenerator() {\n  yield &#39;apple&#39;;\n  yield &#39;orange&#39;;\n  return &#39;watermelon&#39;;\n}\nconst newFruitGenerator = fruitGenerator();\nconsole.log(newFruitGenerator.next()); // [1]\nconsole.log(newFruitGenerator.next()); // [2]\nconsole.log(newFruitGenerator.next()); // [3]\n</code></pre>\n<p>前面的代码将打印下面的输出：</p>\n<pre><code>{ value: &#39;apple&#39;, done: false }\n{ value: &#39;orange&#39;, done: false }\n{ value: &#39;watermelon&#39;, done: true }\n</code></pre><p>我们可以这么解释上述现象：</p>\n<ul>\n<li>第一次调用<code>newFruitGenerator.next()</code>时，<code>Generator</code>函数开始执行，直到达到第一个<code>yield</code>语句为止，该命令暂停<code>Generator</code>函数执行，并将值<code>apple</code>返回给调用者。</li>\n<li>在第二次调用<code>newFruitGenerator.next()</code>时，<code>Generator</code>函数恢复执行，从第二个<code>yield</code>语句开始，这又使得执行暂停，同时将<code>orange</code>返回给调用者。</li>\n<li><code>newFruitGenerator.next()</code>的最后一次调用导致<code>Generator</code>函数的执行从其最后的<code>yield</code>恢复，一个返回语句，它终止<code>Generator</code>函数，返回<code>watermelon</code>，并将结果对象中的<code>done</code>属性设置为<code>true</code>。</li>\n</ul>\n<h3 id=\"generators-\">Generators作为迭代器</h3>\n<p>为了更好地理解为什么<code>Generator</code>函数对实现迭代器非常有用，我们来构建一个例子。在我们将调用<code>iteratorGenerator.js</code>的新模块中，我们编写下面的代码：</p>\n<pre><code class=\"lang-javascript\">function* iteratorGenerator(arr) {\n  for (let i = 0; i &lt; arr.length; i++) {\n    yield arr[i];\n  }\n}\nconst iterator = iteratorGenerator([&#39;apple&#39;, &#39;orange&#39;, &#39;watermelon&#39;]);\nlet currentItem = iterator.next();\nwhile (!currentItem.done) {\n  console.log(currentItem.value);\n  currentItem = iterator.next();\n}\n</code></pre>\n<p>此代码应按如下所示打印数组中的元素：</p>\n<pre><code>apple\norange\nwatermelon\n</code></pre><p>在这个例子中，每次我们调用<code>iterator.next()</code>时，我们都会恢复<code>Generator</code>函数的<code>for</code>循环，通过<code>yield</code>数组中的下一个项来运行另一个循环。这演示了如何在函数调用过程中维护<code>Generator</code>的状态。当继续执行时，循环和所有变量的值与<code>Generator</code>函数执行暂停时的状态完全相同。</p>\n<h3 id=\"-generators\">传值给Generators</h3>\n<p>现在我们继续研究<code>Generator</code>的基本功能，首先学习如何将值传递回<code>Generator</code>函数。这其实很简单，我们需要做的只是为<code>next()</code>方法提供一个参数，并且该值将作为<code>Generator</code>函数内的<code>yield</code>语句的返回值提供。</p>\n<p>为了展示这一点，我们来创建一个新的简单模块：</p>\n<pre><code class=\"lang-javascript\">function* twoWayGenerator() {\n  const what = yield null;\n  console.log(&#39;Hello &#39; + what);\n}\nconst twoWay = twoWayGenerator();\ntwoWay.next();\ntwoWay.next(&#39;world&#39;);\n</code></pre>\n<p>当执行时，前面的代码会输出<code>Hello world</code>。我们做如下的解释：</p>\n<ul>\n<li>第一次调用<code>next()</code>方法时，<code>Generator</code>函数到达第一个<code>yield</code>语句，然后暂停。</li>\n<li>当<code>next(&#39;world&#39;)</code>被调用时，<code>Generator</code>函数从上次停止的位置，也就是上次的<code>yield</code>语句点恢复，但是这次我们有一个值传递到<code>Generator</code>函数。这个值将被赋值到<code>what</code>变量。生成器然后执行<code>console.log()</code>指令并终止。</li>\n</ul>\n<p>用类似的方式，我们可以强制<code>Generator</code>函数抛出异常。这可以通过使用<code>Generator</code>函数的<code>throw</code>方法来实现，如下例所示：</p>\n<pre><code class=\"lang-javascript\">const twoWay = twoWayGenerator();\ntwoWay.next();\ntwoWay.throw(new Error());\n</code></pre>\n<p>在这个最后这段代码，<code>twoWayGenerator()</code>函数将在<code>yield</code>函数返回的时候抛出异常。这就好像从<code>Generator</code>函数内部抛出了一个异常一样，这意味着它可以像使用<code>try ... catch</code>块一样进行捕获和处理异常。</p>\n<h3 id=\"generator-\">Generator实现异步控制流</h3>\n<p>你一定想知道<code>Generator</code>函数如何帮助我们处理异步操作。我们可以通过创建一个接受<code>Generator</code>函数作为参数的特殊函数来演示这一点，并允许我们在<code>Generator</code>函数内部使用异步代码。这个函数在异步操作完成时要注意恢复<code>Generator</code>函数的执行。我们将调用这个函数<code>asyncFlow()</code>：</p>\n<pre><code class=\"lang-javascript\">function asyncFlow(generatorFunction) {\n  function callback(err) {\n    if (err) {\n      return generator.throw(err);\n    }\n    const results = [].slice.call(arguments, 1);\n    generator.next(results.length &gt; 1 ? results : results[0]);\n  }\n  const generator = generatorFunction(callback);\n  generator.next();\n}\n</code></pre>\n<p>前面的函数取一个<code>Generator</code>函数作为输入，然后立即调用：</p>\n<pre><code class=\"lang-javascript\">const generator = generatorFunction(callback);\ngenerator.next();\n</code></pre>\n<p><code>generatorFunction()</code>接受一个特殊的回调函数作为参数，当<code>generator.throw()</code>如果接收到一个错误，便立即返回。另外，通过将在回调函数中接收的<code>results</code>传值回<code>Generator</code>函数继续<code>Generator</code>函数的执行:</p>\n<pre><code class=\"lang-javascript\">if (err) {\n  return generator.throw(err);\n}\nconst results = [].slice.call(arguments, 1);\ngenerator.next(results.length &gt; 1 ? results : results[0]);\n</code></pre>\n<p>为了说明这个简单的辅助函数的强大，我们创建一个叫做<code>clone.js</code>的新模块，这个模块只是创建它本身的克隆。粘贴我们刚才创建的<code>asyncFlow()</code>函数，核心代码如下：</p>\n<pre><code class=\"lang-javascript\">const fs = require(&#39;fs&#39;);\nconst path = require(&#39;path&#39;);\nasyncFlow(function*(callback) {\n  const fileName = path.basename(__filename);\n  const myself = yield fs.readFile(fileName, &#39;utf8&#39;, callback);\n  yield fs.writeFile(`clone_of_${filename}`, myself, callback);\n  console.log(&#39;Clone created&#39;);\n});\n</code></pre>\n<p>明显地，有了<code>asyncFlow()</code>函数的帮助，我们可以像我们书写同步阻塞函数一样用同步的方式来书写异步代码了。并且这个结果背后的原理显得很清楚。一旦异步操作结束，传递给每个异步函数的回调函数将继续<code>Generator</code>函数的执行。没有什么复杂的，但是结果确实很令人意外。</p>\n<p>这个技术有其他两个变化，一个是<code>Promise</code>的使用，另外一个则是<code>thunks</code>。</p>\n<blockquote>\n<p>在基于Generator的控制流中使用的thunk只是一个简单的函数，它除了回调之外，部分地应用了原始函数的所有参数。返回值是另一个只接受回调作为参数的函数。例如，fs.readFile（）的thunkified版本如下所示：</p>\n</blockquote>\n<pre><code class=\"lang-javascript\">function readFileThunk(filename, options) {\n  return function(callback) {\n    fs.readFile(filename, options, callback);\n  }\n}\n</code></pre>\n<p><code>thunk</code>和<code>Promise</code>都允许我们创建不需要回调的<code>Generator</code>函数作为参数传递，例如，使用<code>thunk</code>的<code>asyncFlow()</code>版本如下：</p>\n<pre><code class=\"lang-javascript\">function asyncFlowWithThunks(generatorFunction) {\n  function callback(err) {\n    if (err) {\n      return generator.throw(err);\n    }\n    const results = [].slice.call(arguments, 1);\n    const thunk = generator.next(results.length &gt; 1 ? results : results[0]).value;\n    thunk &amp;&amp; thunk(callback);\n  }\n  const generator = generatorFunction();\n  const thunk = generator.next().value;\n  thunk &amp;&amp; thunk(callback);\n}\n</code></pre>\n<p>这个技巧是读取<code>generator.next()</code>的返回值，返回值中包含<code>thunk</code>。下一步是通过注入特殊的回调函数调用<code>thunk</code>本身。这允许我们写下面的代码：</p>\n<pre><code class=\"lang-javascript\">asyncFlowWithThunk(function*() {\n  const fileName = path.basename(__filename);\n  const myself = yield readFileThunk(__filename, &#39;utf8&#39;);\n  yield writeFileThunk(`clone_of_${fileName}`, myself);\n  console.log(&quot;Clone created&quot;)\n});\n</code></pre>\n<h3 id=\"-co-gernator-\">使用co的基于Gernator的控制流</h3>\n<p>你应该已经猜到了，<code>Node.js</code>生态系统会借助<code>Generator</code>函数来提供一些处理异步控制流的解决方案，例如，<a href=\"https://npm/js.org/package/suspend\">suspend</a>是其中一个最老的支持<code>Promise</code>、<code>thunks</code>和<code>Node.js</code>风格回调函数和正常风格的回调函数的 库。还有，大部分我们之前分析的<code>Promise</code>库都提供工具函数使得<code>Generator</code>和<code>Promise</code>可以一起使用。</p>\n<p>我们选择<a href=\"https://npmjs.org/package/co\">co</a>作为本章节的例子。它支持很多类型的<code>yieldables</code>，其中一些是：</p>\n<ul>\n<li><code>Thunks</code></li>\n<li><code>Promises</code></li>\n<li><code>Arrays</code>(并行执行)</li>\n<li><code>Objects</code>(并行执行)</li>\n<li><code>Generators</code>(委托)</li>\n<li><code>Generator</code>函数(委托)</li>\n</ul>\n<p>还有很多框架或库是基于<code>co</code>生态系统的，包括以下一些：</p>\n<ul>\n<li><code>Web框架</code>，最流行的是<a href=\"https://npmjs.org/package/koa\">koa</a></li>\n<li>实现特定控制流模式的库</li>\n<li>包装流行的<code>API</code>兼容<code>co</code>的库</li>\n</ul>\n<p>我们使用<code>co</code>重新实现我们的<code>Generator</code>版本的<code>Web爬虫应用程序</code>。</p>\n<p>为了将<code>Node.js</code>风格的函数转换成<code>thunks</code>，我们将会使用一个叫做<a href=\"https://npmjs.org/package/thunkify\">thunkify</a>的库。</p>\n<h3 id=\"-\">顺序执行</h3>\n<p>让我们通过修改<code>Web爬虫应用程序</code>的版本2开始我们对<code>Generator</code>函数和<code>co</code>的实际探索。我们要做的第一件事就是加载我们的依赖包，并生成我们要使用的函数的<code>thunkified</code>版本。这些将在<code>spider.js</code>模块的最开始进行：</p>\n<pre><code class=\"lang-javascript\">const thunkify = require(&#39;thunkify&#39;);\nconst co = require(&#39;co&#39;);\nconst request = thunkify(require(&#39;request&#39;));\nconst fs = require(&#39;fs&#39;);\nconst mkdirp = thunkify(require(&#39;mkdirp&#39;));\nconst readFile = thunkify(fs.readFile);\nconst writeFile = thunkify(fs.writeFile);\nconst nextTick = thunkify(process.nextTick);\n</code></pre>\n<p>看上述代码，我们可以注意到与本章前面<code>promisify</code>化的<code>API</code>的代码的一些相似之处。在这一点上，有意思的是，如果我们使用我们的<code>promisified</code>版本的函数来代替<code>thunkified</code>的版本，代码将保持完全一样，这要归功于<code>co</code>支持<code>thunk</code>和<code>Promise</code>对象作为<code>yieldable</code>对象。事实上，如果我们想，甚至可以在同一个应用程序中使用<code>thunk</code>和<code>Promise</code>，即使在同一个<code>Generator</code>函数中。就灵活性而言，这是一个巨大的优势，因为它使我们能够使用基于<code>Generator</code>函数的控制流来解决我们应用程序中的问题。</p>\n<p>好的，现在让我们开始将<code>download()</code>函数转换为一个<code>Generator</code>函数：</p>\n<pre><code class=\"lang-javascript\">function* download(url, filename) {\n  console.log(`Downloading ${url}`);\n  const response = yield request(url);\n  const body = response[1];\n  yield mkdirp(path.dirname(filename));\n  yield writeFile(filename, body);\n  console.log(`Downloaded and saved ${url}`);\n  return body;\n}\n</code></pre>\n<p>通过使用<code>Generator</code>和<code>co</code>，我们的<code>download()</code>函数变得简单多了。当我们需要做异步操作的时候，我们使用异步的<code>Generator</code>函数作为<code>thunk</code>来把之前的内容转化到<code>Generator</code>函数，并使用<code>yield</code>子句。</p>\n<p>然后我们开始实现我们的<code>spider()</code>函数：</p>\n<pre><code class=\"lang-javascript\">function* spider(url, nesting) {\n  cost filename = utilities.urlToFilename(url);\n  let body;\n  try {\n    body = yield readFile(filename, &#39;utf8&#39;);\n  } catch (err) {\n    if (err.code !== &#39;ENOENT&#39;) {\n      throw err;\n    }\n    body = yield download(url, filename);\n  }\n  yield spiderLinks(url, body, nesting);\n}\n</code></pre>\n<p>从上述代码中一个有趣的细节是我们可以使用<code>try...catch</code>语句块来处理异常。我们还可以使用<code>throw</code>来传播异常。另外一个细节是我们<code>yield</code>我们的<code>download()</code>函数，而这个函数既不是一个<code>thunk</code>，也不是一个<code>promisified</code>函数，只是另外的一个<code>Generator</code>函数。这也毫无问题，由于<code>co</code>也支持其他<code>Generators</code>作为<code>yieldables</code>。</p>\n<p>最后转换<code>spiderLinks()</code>，在这个函数中，我们递归下载一个网页的链接。在这个函数中使用<code>Generators</code>，显得简单多了：</p>\n<pre><code class=\"lang-javascript\">function* spiderLinks(currentUrl, body, nesting) {\n  if (nesting === 0) {\n    return nextTick();\n  }\n  const links = utilities.getPageLinks(currentUrl, body);\n  for (let i = 0; i &lt; links.length; i++) {\n    yield spider(links[i], nesting - 1);\n  }\n}\n</code></pre>\n<p>看上述代码。虽然顺序迭代没有什么模式可以展示。<code>Generator</code>和<code>co</code>辅助我们做了很多，方便了我们可以使用同步方式开书写异步代码。</p>\n<p>看最重要的部分，程序的入口：</p>\n<pre><code class=\"lang-javascript\">co(function*() {\n  try {\n    yield spider(process.argv[2], 1);\n    console.log(`Download complete`);\n  } catch (err) {\n    console.log(err);\n  }\n});\n</code></pre>\n<p>这是唯一一处需要调用<code>co(...)</code>来封装的一个<code>Generator</code>。实际上，一旦我们这么做，<code>co</code>会自动封装我们传递给<code>yield</code>语句的任何<code>Generator</code>函数，并且这个过程是递归的，所以程序的剩余部分与我们是否使用<code>co</code>是完全无关的，虽然是被<code>co</code>封装在里面。</p>\n<p>现在应该可以运行使用<code>Generator</code>函数改写的<code>Web爬虫应用程序</code>了。</p>\n<h3 id=\"-\">并行执行</h3>\n<p>不幸的是，虽然<code>Generator</code>很方便地进行顺序执行，但是不能直接用来并行化执行一组任务，至少不能仅仅使用<code>yield</code>和<code>Generator</code>。之前，在种情况下我们使用的模式只是简单地依赖于一个基于回调或者<code>Promise</code>的函数，但使用了<code>Generator</code>函数后，一切会显得更简单。</p>\n<p>幸运的是，如果不限制并发数的并行执行，<code>co</code>已经可以通过<code>yield</code>一个<code>Promise</code>对象、<code>thunk</code>、<code>Generator</code>函数，甚至包含<code>Generator</code>函数的数组来实现。</p>\n<p>考虑到这一点，我们的<code>Web爬虫应用程序</code>第三版可以通过重写<code>spiderLinks()</code>函数来做如下改动：</p>\n<pre><code class=\"lang-javascript\">function* spiderLinks(currentUrl, body, nesting) {\n  if (nesting === 0) {\n    return nextTick();\n  }\n  const links = utilities.getPageLinks(currentUrl, body);\n  const tasks = links.map(link =&gt; spider(link, nesting - 1));\n  yield tasks;\n}\n</code></pre>\n<p>但是上述函数所做的只是拿到所有的任务，这些任务本质上都是通过<code>Generator</code>函数来实现异步的，如果在<code>co</code>的<code>thunk</code>内对一个包含<code>Generator</code>函数的数组使用<code>yield</code>，这些任务都会并行执行。外层的<code>Generator</code>函数会等到<code>yield</code>子句的所有异步任务并行执行后再继续执行。</p>\n<p>接下来我们看怎么用一个基于回调函数的方式来解决相同的并行流。我们用这种方式重写<code>spiderLinks()</code>函数：</p>\n<pre><code class=\"lang-javascript\">function spiderLinks(currentUrl, body, nesting) {\n  if (nesting === 0) {\n    return nextTick();\n  }\n  // 返回一个thunk\n  return callback =&gt; {\n    let completed = 0,\n      hasErrors = false;\n    const links = utilities.getPageLinks(currentUrl, body);\n    if (links.length === 0) {\n      return process.nextTick(callback);\n    }\n\n    function done(err, result) {\n      if (err &amp;&amp; !hasErrors) {\n        hasErrors = true;\n        return callback(err);\n      }\n      if (++completed === links.length &amp;&amp; !hasErrors) {\n        callback();\n      }\n    }\n    for (let i = 0; i &lt; links.length; i++) {\n      co(spider(links[i], nesting - 1)).then(done);\n    }\n  }\n}\n</code></pre>\n<p>我们使用<code>co</code>并行运行<code>spider()</code>函数，调用<code>Generator</code>函数返回了一个<code>Promise</code>对象。这样，等待<code>Promise</code>完成后调用<code>done()</code>函数。通常，基于<code>Generator</code>控制流的库都有这一功能，因此如果需要，你总是可以将一个<code>Generator</code>转换成一个基于回调或基于<code>Promise</code>的函数。</p>\n<p>为了并行开启多个下载任务，我们只要重用在前面定义的基于回调的并行执行的模式。我们应该也注意到我们将<code>spiderLinks()</code>转换成一个<code>thunk</code>(而不再是一个<code>Generator</code>函数)。这使得当全部并行任务完成时，我们有一个回调函数可以调用。</p>\n<blockquote>\n<p>上面讲到的是将一个Generator函数转换为一个thunk的模式，使之能够支持其他的基于回调或基于Promise的控制流算法，并可以通过同步阻塞的代码风格书写异步代码。</p>\n</blockquote>\n<h3 id=\"-\">限制并行执行</h3>\n<p>现在我们知道如何处理异步执行流程，应该很容易规划我们的<code>Web爬虫应用程序</code>的第四版的实现，这个版本对并发下载任务的数量施加了限制。我们有几个方案可以用来做到这一点。其中一些方案如下：</p>\n<ul>\n<li>使用先前实现的基于回调的<code>TaskQueue</code>类。我们只需要<code>thunkify</code>我们的<code>Generator</code>函数和其提供的回调函数即可。</li>\n<li>使用基于<code>Promise</code>的<code>TaskQueue</code>类，并确保每个作为任务的<code>Generator</code>函数都被转换成一个返回<code>Promise</code>对象的函数。</li>\n<li>使用<code>async</code>，<code>thunkify</code>我们打算使用的工具函数，此外还需要把我们用到的<code>Generator</code>函数转化为基于回调的模式，以便于能够被这个库较好地使用。</li>\n<li>使用基于<code>co</code>的生态系统中的库，特别是专门为这种场景的库，如<a href=\"https://npmjs.org/package/co-limiter\">co-limiter</a>。</li>\n<li>实现基于生产者 - 消费者模型的自定义算法，这与<code>co-limiter</code>的内部实现原理相同。</li>\n</ul>\n<p>为了学习，我们选择最后一个方案，甚至帮助我们可以更好地理解一种经常与协程(也和线程和进程)同步相关的模式。</p>\n<h3 id=\"-\">生产者 - 消费者模式</h3>\n<p>我们的目标是利用队列来提供固定数量的<code>workers</code>，与我们想要设置的并发级别一样多。为了实现这个算法，我们将基于本章前面定义的<code>TaskQueue</code>类改写：</p>\n<pre><code class=\"lang-javascript\">class TaskQueue {\n  constructor(concurrency) {\n    this.concurrency = concurrency;\n    this.running = 0;\n    this.taskQueue = [];\n    this.consumerQueue = [];\n    this.spawnWorkers(concurrency);\n  }\n  pushTask(task) {\n    if (this.consumerQueue.length !== 0) {\n      this.consumerQueue.shift()(null, task);\n    } else {\n      this.taskQueue.push(task);\n    }\n  }\n  spawnWorkers(concurrency) {\n    const self = this;\n    for (let i = 0; i &lt; concurrency; i++) {\n      co(function*() {\n        while (true) {\n          const task = yield self.nextTask();\n          yield task;\n        }\n      });\n    }\n  }\n  nextTask() {\n    return callback =&gt; {\n      if (this.taskQueue.length !== 0) {\n        return callback(null, this.taskQueue.shift());\n      }\n      this.consumerQueue.push(callback);\n    }\n  }\n}\n</code></pre>\n<p>让我们分析这个<code>TaskQueue</code>类的新实现。首先是在构造函数中。需要调用一次<code>this.spawnWorkers()</code>，因为这是启动<code>worker</code>的方法。</p>\n<p>我们的<code>worker</code>很简单，它们只是用<code>co()</code>包装的立即执行的<code>Generator</code>函数，所以每个<code>Generator</code>函数可以并行执行。在内部，每个<code>worker</code>正在运行在一个死循环（<code>while(true){}</code>）中，一直阻塞（<code>yield</code>）到新任务在队列中可用时（<code>yield self.nextTask()</code>），一旦可以执行新任务，<code>yield</code>这个异步任务直到其完成。您可能想知道我们如何能够限制并行执行，并让下一个任务在队列中处于等待状态。答案是在<code>nextTask()</code>方法中。我们来详细地看看在这个方法的原理：</p>\n<pre><code class=\"lang-javascript\">nextTask() {\n  return callback =&gt; {\n    if (this.taskQueue.length !== 0) {\n      return callback(null, this.taskQueue.shift());\n    }\n    this.consumerQueue.push(callback);\n  }\n}\n</code></pre>\n<p>我们看这个函数内部发生了什么，这才是这个模式的核心：</p>\n<ol>\n<li>这个方法返回一个对于<code>co</code>而言是一个合法的<code>yieldable</code>的<code>thunk</code>。</li>\n<li>只要<code>taskQueue</code>类生成的实例中还有下一个任务，<code>thunk</code>的回调函数会被立即调用。回调函数调用时，立马解锁一个<code>worker</code>的阻塞状态，<code>yield</code>这一个任务。</li>\n<li>如果队列中没有任务了，回调函数本身会被放入<code>consumerQueue</code>中。通过这种做法，我们将一个<code>worker</code>置于空闲（<code>idle</code>）的模式。一旦我们有一个新的任务来要处理，在<code>consumerQueue</code>队列中的回调函数会被调用，立马唤醒我们这一<code>worker</code>进行异步处理。</li>\n</ol>\n<p>现在，为了理解<code>consumerQueue</code>队列中的空闲<code>worker</code>是如何恢复工作的，我们需要分析<code>pushTask()</code>方法。如果当前有回调函数可用的话，<code>pushTask()</code>方法将调用<code>consumerQueue</code>队列中的第一个回调函数，从而将取消对<code>worker</code>的锁定。如果没有可用的回调函数，这意味着所有的<code>worker</code>都是工作状态，只需要添加一个新的任务到<code>taskQueue</code>任务队列中。</p>\n<p>在<code>TaskQueue</code>类中，<code>worker</code>充当消费者的角色，而调用<code>pushTask()</code>函数的角色可以被认为是生产者。这个模式向我们展示了一个<code>Generator</code>函数实际上可以跟一个线程或进程类似。实际上，生产者 - 消费者之间问题是研究进程间通信和同步时最常见的问题，但正如我们已经提到的那样，它对于进程和线程来说，也是一个常见的例子。</p>\n<h3 id=\"-\">限制下载任务的并发量</h3>\n<p>既然我们已经使用<code>Generator</code>函数和生产者 - 消费者模型实现一个限制并行算法，并且已经在<code>Web爬虫应用程序</code>第四版应用它来限制中下载任务的并发数。 首先，我们加载和初始化一个<code>TaskQueue</code>对象：</p>\n<pre><code class=\"lang-javascript\">const TaskQueue = require(&#39;./taskQueue&#39;);\nconst downloadQueue = new TaskQueue(2);\n</code></pre>\n<p>然后，修改<code>spiderLinks()</code>函数。和之前不限制并发的版本类似，所以这里我们只展示修改的部分，主要是通过调用新版本的<code>TaskQueue</code>类生成的实例的<code>pushTask()</code>方法来限制并行执行：</p>\n<pre><code class=\"lang-javascript\">function spiderLinks(currentUrl, body, nesting) {\n  //...\n  return (callback) =&gt; {\n    //...\n    function done(err, result) {\n      //...\n    }\n    links.forEach(function(link) {\n      downloadQueue.pushTask(function*() {\n        yield spider(link, nesting - 1);\n        done();\n      });\n    });\n  }\n}\n</code></pre>\n<p>在每个任务中，我们在下载完成后立即调用<code>done()</code>函数，因此我们可以计算下载了多少个链接，然后在完成下载时通知<code>thunk</code>的回调函数执行。</p>\n<h2 id=\"-babel-async-await-\">配合Babel使用Async await新语法</h2>\n<p>回调函数、<code>Promise</code>和<code>Generator</code>函数都是用于处理<code>JavaScript</code>和<code>Node.js</code>异步问题的方式。正如我们所看到的，<code>Generator</code>的真正意义在于它提供了一种方式来暂停一个函数的执行，然后等待前面的任务完成后再继续执行。我们可以使用这样的特性来书写异步代码，并且让开发者用同步阻塞的代码风格来书写异步代码。等到异步操作的结果返回后才恢复当前函数的执行。</p>\n<p>但<code>Generator</code>函数是更多的是用来处理迭代器，然而迭代器在异步代码的使用显得有点笨重。代码可能难以理解，导致代码易读性和可维护性差。</p>\n<p>但在不远的将来会有一种更加简洁的语法。实际上，这个提议即将引入到<code>ESMASCript 2017</code>的规范中，这项规范定义了<code>async</code>函数语法。</p>\n<p><code>async</code>函数规范引入两个关键字(<code>async</code>和<code>await</code>)到原生的<code>JavaScript</code>语言中，改进我们书写异步代码的方式。</p>\n<p>为了理解这项语法的用法和优势为，我们看一个简单的例子：</p>\n<pre><code class=\"lang-javascript\">const request = require(&#39;request&#39;);\n\nfunction getPageHtml(url) {\n  return new Promise(function(resolve, reject) {\n    request(url, function(error, response, body) {\n      resolve(body);\n    });\n  });\n}\nasync function main() {\n  const html = await getPageHtml(&#39;http://google.com&#39;);\n  console.log(html);\n}\n\nmain();\nconsole.log(&#39;Loading...&#39;);\n</code></pre>\n<p>在上述代码中，有两个函数：<code>getPageHtml</code>和<code>main</code>。第一个函数的作用是提取给定<code>URL</code>的一个远程网页的<code>HTML</code>文档代码。值得注意的是，这个函数返回一个<code>Promise</code>对象。</p>\n<p>重点在于<code>main</code>函数，因为在这里使用了<code>async</code>和<code>await</code>关键字。首先要注意的是函数要以<code>async</code>关键字为前缀。意思是这个函数执行的是异步代码并且允许它在函数体内使用<code>await</code>关键字。<code>await</code>关键字在<code>getPageHtml</code>调用之前，告诉<code>JavaScript</code>解释器在继续执行下一条指令之前，等待<code>getPageHtml</code>返回的<code>Promise</code>对象的结果。这样，<code>main</code>函数内部哪部分代码是异步的，它会等待异步代码的完成再继续执行后续操作，并且不会阻塞这段程序其余部分的正常执行。实际上，控制台会打印字符串<code>Loading...</code>，随后是Google主页的<code>HTML</code>代码。</p>\n<p>是不是这种方法的可读性更好并且更容易理解呢? 不幸地是，这个提议尚未定案，即使通过这个提议，我们需要等下一个版本\n的<code>ECMAScript</code>规范出来并把它集成到<code>Node.js</code>后，才能使用这个新语法。 所以我们今天做了什么?只是漫无目的地等待?不是，当然不是！我们已经可以在我们的代码中使用<code>async await</code>语法，只要我们使用<code>Babel</code>。</p>\n<h3 id=\"-babel\">安装与运行Babel</h3>\n<p><code>Babel</code>是一个<code>JavaScript</code>编译器(或翻译器)，能够使用语法转换器将高版本的<code>JavaScript</code>代码转换成其他<code>JavaScript</code>代码。语法转换器允许例如我们书写并使用<code>ES2015</code>，<code>ES2016</code>，<code>JSX</code>和其它的新语法，来翻译成往后兼容的代码，在<code>JavaScript</code>运行环境如浏览器或<code>Node.js</code>中都可以使用<code>Babel</code>。</p>\n<p>在项目中使用<code>npm</code>安装<code>Babel</code>，命令如下：</p>\n<pre><code>npm install --save-dev babel-cli\n</code></pre><p>我们还需要安装插件以支持<code>async await</code>语法的解释或翻译：</p>\n<pre><code>npm install --save-dev babel-plugin-syntax-async-functions babel-plugin-tranform-async-to-generator\n</code></pre><p>现在假设我们想运行我们之前的例子（称为<code>index.js</code>）。我们需要通过以下命令启动：</p>\n<pre><code>node_modules/.bin/babel-node --plugins &quot;syntax-async-functions,transform-async-to-generator&quot; index.js\n</code></pre><p>这样，我们使用支持<code>async await</code>的转换器动态地转换源代码。<code>Node.js</code>运行的实际是保存在内存中的往后兼容的代码。</p>\n<p><code>Babel</code>也能被配置为一个代码构建工具，保存翻译或解释后的代码到本地文件系统中，便于我们部署和运行生成的代码。</p>\n<blockquote>\n<p>关于如何安装和配置Babel，可以到官方网站 <a href=\"https://babeljs.io\">https://babeljs.io</a> 查阅相关文档。</p>\n</blockquote>\n<h2 id=\"-\">几种方式的比较</h2>\n<p>现在，我们应该对于怎么处理<code>JavaScript</code>的异步问题有了一个更好的认识和总结。在下面的表格中总结几大机制的优势和劣势：</p>\n<p><img src=\"http://oczira72b.bkt.clouddn.com/17-11-7/55293366.jpg\" alt=\"\"></p>\n<blockquote>\n<p>值得一提的是，我们选择在本章中仅介绍处理异步控制流程的最受欢迎的解决方案，或者是广泛使用的解决方案，但是例如Fibers（ <a href=\"https://npmjs.org/package/fibers\">https://npmjs.org/package/fibers</a> ）和Streamline（ <a href=\"https://npmjs.org/p\">https://npmjs.org/p</a> ackage/streamline ）也是值得一看的。</p>\n</blockquote>\n<h2 id=\"-\">总结</h2>\n<p>在本章中，我们分析了一些处理异步控制流的方法，分析了<code>Promise</code>、<code>Generator</code>函数和即将到来的<code>async await</code>语法。</p>\n<p>我们学习了如何使用这些方法编写更简洁，更具有可读性的异步代码。我们讨论了这些方法的一些最重要的优点和缺点，并认识到即使它们非常有用，也需要一些时间来掌握。这就是这几种方式也没有完全取代在许多情况下仍然非常有用的回调的原因。作为一名开发人员，应该按照实际情况分析决定使用哪种解决方案。如果您正在构建执行异步操作的公共库，则应该提供易于使用的<code>API</code>，即使对于只想使用回调的开发人员也是如此。</p>\n<p>在下一章中，我们将探讨另一个与异步代码执行相关的机制，这也是整个<code>Node.js</code>生态系统中的另一个基本构建块：<code>streams</code>。</p>\n","id":"5a0e8b7949b148371be1f96e","token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxNTc2LCJleHAiOjE1MTIxNDQ3NzZ9.uKBuLKHhVqQEXpCm68cxufPp3HqLhF25sI_3iT0rBmI"}
response time: 56
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"回复成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-12-01T04:16:24.253Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"# Asynchronous Control Flow Patterns with ES2015 and Beyond\\n在上一章中，我们学习了如何使用回调处理异步代码，以及如何解决如回调地狱代码等异步问题。回调是`JavaScript`和`Node.js`中的异步编程的基础，但是现在，其他替代方案已经出现。这些替代方案更复杂，以便能够以更方便的方式处理异步代码。\\n\\n在本章中，我们将探讨一些代表性的替代方案，`Promise`和`Generator`。以及`async await`，这是一种创新的语法，可在高版本的`JavaScript`中提供，其也作为`ECMAScript 2017`发行版的一部分。\\n\\n我们将看到这些替代方案如何简化处理异步控制流的方式。最后，我们将比较所有这些方法，以了解所有这些方法的所有优点和缺点，并能够明智地选择最适合我们下一个`Node.js`项目要求的方法。\\n\\n## Promise\\n我们在前面的章节中提到，`CPS风格`不是编写异步代码的唯一方法。事实上，`JavaScript`生态系统为传统的回调模式提供了有趣的替代方案。最着名的选择之一是`Promise`，特别是现在它是`ECMAScript 2015`的一部分，并且现在可以在`Node.js`中可用。\\n\\n### 什么是Promise？\\n`Promise`是一种抽象的对象，我们通常允许函数返回一个名为`Promise`的对象，它表示异步操作的最终结果。通常情况下，我们说当异步操作尚未完成时，我们说`Promise`对象处于`pending`状态，当操作成功完成时，我们说`Promise`对象处于`resolve`状态，当操作错误终止时，我们说`Promise`对象处于`reject`状态。一旦`Promise`处于`resolve`或`reject`，我们认为当前异步操作结束。\\n\\n为了接收到异步操作的正确结果或错误捕获，我们可以使用`Promise`的`then`方法：\\n\\n```javascript\\npromise.then([onFulfilled], [onRejected])\\n```\\n\\n在前面的代码中，`onFulfilled()`是一个函数，最终会收到`Promise`的正确结果，而`onRejected()`是另一个函数，它将接收产生异常的原因（如果有的话）。两个参数都是可选的。\\n\\n要了解`Promise`如何转换我们的代码，让我们考虑以下几点：\\n\\n```javascript\\nasyncOperation(arg, (err, result) => {\\n  if (err) {\\n    // 错误处理\\n  }\\n  // 正常结果处理\\n});\\n```\\n\\n`Promise`允许我们将这个典型的`CPS`代码转换成更好的结构化和更优雅的代码，如下所示：\\n\\n```javascript\\nasyncOperation(arg)\\n  .then(result => {\\n    // 错误处理\\n  }, err => {\\n    // 正常结果处理\\n  });\\n```\\n\\n`then()`方法的一个关键特征是它同步地返回另一个`Promise`对象。如果`onFulfilled()`或`onRejected()`函数中的任何一个函数返回`x`，则`then()`方法返回的`Promise`对象将如下所示：\\n\\n* 如果`x`是一个值，则这个`Promise`对象会正确处理(`resolve`)`x`\\n* 如果`x`是一个`Promise`对象或`thenable`，则会正确处理(`resolve`)`x`\\n* 如果`x`是一个异常，则会捕获异常(`reject`)`x`\\n\\n> 注：thenable是一个具有then方法的类似于Promise的对象(Promise-like)。\\n\\n这个特点使我们能够链式构建`Promise`，允许轻松排列组合我们的异步操作。另外，如果我们没有指定一个`onFulfilled()`或`onRejected()`处理程序，则正确结果或异常捕获将自动转发到`Promise`链的下一个`Promise`。例如，这允许我们在整个链中自动传播错误，直到被`onRejected()`处理程序捕获。随着`Promise`链，任务的顺序执行突然变成简单多了：\\n\\n```javascript\\nasyncOperation(arg)\\n  .then(result1 => {\\n    // 返回另一个Promise\\n    return asyncOperation(arg2);\\n  })\\n  .then(result2 => {\\n    // 返回一个值\\n    return 'done';\\n  })\\n  .then(undefined, err => {\\n    // 捕获Promise链中的异常\\n  });\\n```\\n\\n下图展示了链式`Promise`如何工作：\\n\\n![](http://oczira72b.bkt.clouddn.com/17-10-31/46370382.jpg)\\n\\n`Promise`的另一个重要特性是`onFulfilled()`和`onRejected()`函数是异步调用的，如同上述的例子，在最后那个`then`函数`resolve`一个同步的`Promise`，它也是同步的。这种模式避免了`Zalgo`（参见`Chapter2-Node.js Essential Patterns`），使我们的异步代码更加一致和稳健。\\n\\n如果在`onFulfilled()`或`onRejected()`处理程序中抛出异常（使用`throw`语句），则`then()`方法返回的`Promise`将被自动地`reject`，抛出异常作为`reject`的原因。这相对于`CPS`来说是一个巨大的优势，因为它意味着有了`Promise`，异常将在整个链中自动传播，并且`throw`语句终于可以使用。\\n\\n在以前，许多不同的库实现了`Promise`，大多数时候它们之间不兼容，这意味着不可能在使用不同`Promise`库的`thenable`链式传播错误。\\n\\n`JavaScript`社区非常努力地解决了这个限制，这些努力导致了`Promises / A +`规范的创建。该规范详细描述了`then`方法的行为，提供了一个可互兼容的基础，这使得来自不同库的`Promise`对象能够彼此兼容，开箱即用。\\n\\n有关`Promises / A +`规范的详细说明，可以参考[Promises / A + 官方网站](https://promisesaplus.com)。\\n\\n### Promise / A + 的实施\\n在`JavaScript`中以及`Node.js`中，有几个实现`Promises / A +`规范的库。以下是最受欢迎的：\\n\\n* [Bluebird](https://npmjs.org/package/bluebird)\\n* [Q](https://npmjs.org/package/q)\\n* [RSVP](https://npmjs.org/package/rsvp)\\n* [Vow](https://npmjs.org/package/vow)\\n* [When.js](https://npmjs.org/package/when)\\n* ES2015 promises\\n\\n真正区别他们的是在`Promises / A +`标准之上提供的额外功能。正如我们上述所说的那样，该标准定义了`then()`方法和`Promise`解析过程的行为，但它没有指定其他功能，例如，如何从基于回调的异步函数创建`Promise`。\\n\\n在我们的示例中，我们将使用由`ES2015`的`Promise`，因为`Promise`对象自`Node.js 4`后即可使用，而不需要任何库来实现。\\n\\n作为参考，以下是`ES2015`的`Promise`提供的API：\\n\\n`constructor`(`new Promise（function（resolve, reject）{}）`)：创建了一个新的`Promise`，它基于作为传递两个类型为函数的参数来决定`resolve`或`reject`。构造函数的参数解释如下：\\n\\n* `resolve(obj)` ：`resolve`一个`Promise`，并带上一个参数`obj`，如果`obj`是一个值，这个值就是传递的异步操作成功的结果。如果`obj`是一个`Promise`或一个`thenable`，则会进行正确处理。\\n* `reject(err)`：`reject`一个`Promise`，并带上一个参数`err`。它是`Error`对象的一个实例。\\n\\n#### Promise对象的静态方法\\n* `Promise.resolve(obj)`： 将会创建一个`resolve`的`Promise`实例\\n* `Promise.reject(err)`： 将会创建一个`reject`的`Promise`实例\\n* `Promise.all(iterable)`：返回一个新的`Promise`实例，并且在`iterable`中所\\n有`Promise`状态为`reject`时, 返回的`Promise`实例的状态会被置为`reject`，如果`iterable`中至少有一个`Promise`状态为`reject`时, 返回的`Promise`实例状态也会被置为`reject`，并且`reject`的原因是第一个被`reject`的`Promise`对象的`reject`原因。\\n* `Promise.race(iterable)`：返回一个`Promise`实例，当`iterable`中任何一个`Promise`被`resolve`或被`reject`时， 返回的`Promise`实例以同样的原因`resolve`或`reject`。\\n\\n#### Promise实例方法\\n* `Promise.then(onFulfilled, onRejected)`：这是`Promise`的基本方法。它的行为与我们之前描述的`Promises / A +`标准兼容。\\n* `Promise.catch(onRejected)`：这只是`Promise.then(undefined，onRejected)`的语法糖。\\n\\n> 值得一提的是，一些Promise实现提供了另一种机制来创建新的Promise，称为deferreds。我们不会在这里描述，因为它不是ES2015标准的一部分，但是如果您想了解更多信息，可以阅读Q文档 (https://github.com/kriskowal/q#using-deferreds) 或When.js文档 (https://github.com/cujojs/when/wiki/Deferred) 。\\n\\n### Promisifying一个Node.js回调风格的函数\\n在`JavaScript`中，并不是所有的异步函数和库都支持开箱即用的`Promise`。大多数情况下，我们必须将一个典型的基于回调的函数转换成一个返回`Promise`的函数，这个过程也被称为`promisification`。\\n\\n幸运的是，`Node.js`中使用的回调约定允许我们创建一个可重用的函数，我们通过使用`Promise`对象的构造函数来简化任何`Node.js`风格的`API`。让我们创建一个名为`promisify()`的新函数，并将其包含到`utilities.js`模块中（以便稍后在我们的`Web爬虫应用程序`中使用它）：\\n\\n```javascript\\nmodule.exports.promisify = function(callbackBasedApi) {\\n  return function promisified() {\\n    const args = [].slice.call(arguments);\\n    return new Promise((resolve, reject) => {\\n      args.push((err, result) => {\\n        if (err) {\\n          return reject(err);\\n        }\\n        if (arguments.length <= 2) {\\n          resolve(result);\\n        } else {\\n          resolve([].slice.call(arguments, 1));\\n        }\\n      });\\n      callbackBasedApi.apply(null, args);\\n    });\\n  }\\n};\\n```\\n\\n前面的函数返回另一个名为`promisified()`的函数，它表示输入中给出的`callbackBasedApi`的`promisified`版本。以下展示它是如何工作的：\\n\\n1. `promisified()`函数使用`Promise`构造函数创建一个新的`Promise`对象，并立即将其返回给调用者。\\n2. 在传递给`Promise`构造函数的函数中，我们确保传递给`callbackBasedApi`，这是一个特殊的回调函数。由于我们知道回调总是最后调用的，我们只需将回调函数附加到提供给`promisified()`函数的参数列表里（`args`）。\\n3. 在特殊的回调中，如果我们收到错误，我们立即`reject`这个`Promise`。\\n4. 如果没有收到错误，我们使用一个值或一个数组值来`resolve`这个`Promise`，具体取决于传递给回调的结果数量。\\n5. 最后，我们只需使用我们构建的参数列表调用`callbackBasedApi`。\\n\\n> 大部分的Promise已经提供了一个开箱即用的接口来将一个Node.js风格的API转换成一个返回Promise的API。例如，Q有Q.denodeify()和Q.nbind()，Bluebird有Promise.promisify()，而When.js有node.lift()。\\n\\n### 顺序执行\\n在一些必要的理论之后，我们现在准备将我们的`Web爬虫应用程序`转换为使用`Promise`的形式。让我们直接从版本2开始，直接下载一个Web网页的链接。\\n\\n在`spider.js`模块中，第一步是加载我们的`Promise`实现（我们稍后会使用它）和`Promisifying`我们打算使用的基于回调的函数：\\n\\n```javascript\\nconst utilities = require('./utilities');\\nconst request = utilities.promisify(require('request'));\\nconst mkdirp = utilities.promisify(require('mkdirp'));\\nconst fs = require('fs');\\nconst readFile = utilities.promisify(fs.readFile);\\nconst writeFile = utilities.promisify(fs.writeFile);\\n```\\n\\n现在，我们开始更改我们的`download`函数：\\n\\n```javascript\\nfunction download(url, filename) {\\n  console.log(`Downloading ${url}`);\\n  let body;\\n  return request(url)\\n    .then(response => {\\n      body = response.body;\\n      return mkdirp(path.dirname(filename));\\n    })\\n    .then(() => writeFile(filename, body))\\n    .then(() => {\\n      console.log(`Downloaded and saved: ${url}`);\\n      return body;\\n    });\\n}\\n```\\n\\n这里要注意的到的最重要的是我们也为`readFile()`返回的`Promise`注册\\n一个`onRejected()`函数，用来处理一个网页没有被下载的情况(或文件不存在)。 还有，看我们如何使用`throw`来传递`onRejected()`函数中的错误的。\\n\\n既然我们已经更改我们的`spider()`函数，我们这么修改它的调用方式：\\n\\n```javascript\\nspider(process.argv[2], 1)\\n  .then(() => console.log('Download complete'))\\n  .catch(err => console.log(err));\\n```\\n\\n注意我们是如何第一次使用`Promise`的语法糖`catch`来处理源自`spider()`函数的任何错误情况。如果我们再看看迄今为止我们所写的所有代码，那么我们会惊喜的发现，我们没有包含任何错误传播逻辑，因为我们在使用回调函数时会被迫做这样的事情。这显然是一个巨大的优势，因为它极大地减少了我们代码中的样板文件以及丢失任何异步错误的机会。\\n\\n现在，完成我们唯一缺失的`Web爬虫应用程序`的第二版的`spiderLinks()`函数，我们将在稍后实现它。\\n\\n### 顺序迭代\\n到目前为止，`Web爬虫应用程序`代码库主要是对`Promise`是什么以及如何使用的概述，展示了使用`Promise`实现顺序执行流程的简单性和优雅性。但是，我们现在考虑的代码只涉及到一组已知的异步操作的执行。所以，完成我们对顺序执行流程的探索的缺失部分是看我们如何使用`Promise`来实现迭代。同样，网络蜘蛛第二版的`spiderLinks()`函数也是一个很好的例子。\\n\\n让我们添加缺少的这一块：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  let promise = Promise.resolve();\\n  if (nesting === 0) {\\n    return promise;\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  links.forEach(link => {\\n    promise = promise.then(() => spider(link, nesting - 1));\\n  });\\n  return promise;\\n}\\n```\\n\\n为了异步迭代一个网页的全部链接，我们必须动态创建一个`Promise`的迭代链。\\n\\n1. 首先，我们定义一个空的`Promise`，`resolve`为`undefined`。这个`Promise`只是用来作为`Promise`的迭代链的起始点。 \\n2. 然后，我们通过在循环中调用链中前一个`Promise`的`then()`方法获得的新的`Promise`来更新`Promise`变量。这就是我们使用`Promise`的异步迭代模式。\\n\\n这样，循环的结束，`promise`变量会包含循环中最后一个`then()`返回的`Promise`对象，所以它只有当`Promise`的迭代链中全部`Promise`对象被`resolve`后才能被`resolve`。\\n\\n> 注：在最后调用了这个then方法来resolve这个Promise对象\\n\\n通过这个，我们已使用`Promise`对象重写了我们的`Web爬虫应用程序`。我们现在应该可以运行它了。\\n\\n### 顺序迭代模式\\n为了总结这个顺序执行的部分，让我们提取一个模式来依次遍历一组`Promise`：\\n\\n```javascript\\nlet tasks = [ /* ... */ ]\\nlet promise = Promise.resolve();\\ntasks.forEach(task => {\\n  promise = promise.then(() => {\\n    return task();\\n  });\\n});\\npromise.then(() => {\\n  // 所有任务都完成\\n});\\n```\\n\\n使用`reduce()`方法来替代`forEach()`方法，允许我们写出更为简洁的代码：\\n\\n```javascript\\nlet tasks = [ /* ... */ ]\\nlet promise = tasks.reduce((prev, task) => {\\n  return prev.then(() => {\\n    return task();\\n  });\\n}, Promise.resolve());\\n\\npromise.then(() => {\\n  //All tasks completed\\n});\\n```\\n\\n与往常一样，通过对这种模式的简单调整，我们可以将所有任务的结果收集到一个数组中，我们可以实现一个`mapping`算法，或者构建一个`filter`等等。\\n\\n> 上述这个模式使用循环动态地建立一个链式的Promise。\\n\\n### 并行执行\\n另一个适合用`Promise`的执行流程是并行执行流程。实际上，我们需要做的就是使用内置的`Promise.all()`。这个方法创造了另一个`Promise`对象，只有在输入中的所有`Promise`都`resolve`时才能`resolve`。这是一个并行执行，因为在其参数`Promise`对象的之间没有执行顺序可言。\\n\\n为了演示这一点，我们来看我们的`Web爬虫应用程序`的第三版，它将页面中的所有链接并行下载。让我们再次使用`Promise`更新`spiderLinks()`函数来实现并行流程：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return Promise.resolve();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  const promises = links.map(link => spider(link, nesting - 1));\\n  return Promise.all(promises);\\n}\\n```\\n\\n这里的模式在`elements.map()`迭代中产生一个数组，存放所有异步任务，之后便于同时启动`spider()`任务。这一次，在循环中，我们不等待以前的下载完成，然后开始一个新的下载任务：所有的下载任务在一个循环中一个接一个地开始。之后，我们利用`Promise.all()`方法，它返回一个新的`Promise`对象，当数组中的所有`Promise`对象都被`resolve`时，这个`Promise`对象将被`resolve`。换句话说，所有的下载任务完成，这正是我们想要的。\\n\\n### 限制并行执行\\n不幸的是，`ES2015`的`Promise API`并没有提供一种原生的方式来限制并发任务的数量，但是我们总是可以依靠我们所学到的有关用普通`JavaScript`来限制并发。事实上，我们在`TaskQueue`类中实现的模式可以很容易地被调整来支持返回承诺的任务。这很容易通过修改`next()`方法来完成：\\n\\n```javascript\\nclass TaskQueue {\\n  constructor(concurrency) {\\n    this.concurrency = concurrency;\\n    this.running = 0;\\n    this.queue = [];\\n  }\\n\\n  pushTask(task) {\\n    this.queue.push(task);\\n    this.next();\\n  }\\n\\n  next() {\\n    while (this.running < this.concurrency && this.queue.length) {\\n      const task = this.queue.shift();\\n      task().then(() => {\\n        this.running--;\\n        this.next();\\n      });\\n      this.running++;\\n    }\\n  }\\n}\\n```\\n\\n不同于使用一个回调函数来处理任务，我们简单地调用`Promise`的`then()`。\\n\\n让我们回到`spider.js`模块，并修改它以支持我们的新版本的`TaskQueue`类。首先，我们确保定义一个`TaskQueue`的新实例：\\n\\n```javascript\\nconst TaskQueue = require('./taskQueue');\\nconst downloadQueue = new TaskQueue(2);\\n```\\n\\n然后，是我们的`spiderLinks()`函数。这里的修改也是很简单：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return Promise.resolve();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  // 我们需要如下代码，用于创建Promise对象\\n  // 如果没有下列代码，当任务数量为0时，将永远不会resolve\\n  if (links.length === 0) {\\n    return Promise.resolve();\\n  }\\n  return new Promise((resolve, reject) => {\\n    let completed = 0;\\n    let errored = false;\\n    links.forEach(link => {\\n      let task = () => {\\n        return spider(link, nesting - 1)\\n          .then(() => {\\n            if (++completed === links.length) {\\n              resolve();\\n            }\\n          })\\n          .catch(() => {\\n            if (!errored) {\\n              errored = true;\\n              reject();\\n            }\\n          });\\n      };\\n      downloadQueue.pushTask(task);\\n    });\\n  });\\n}\\n```\\n\\n在上述代码中有几点值得我们注意的：\\n\\n* 首先，我们需要返回使用`Promise`构造函数创建的新的`Promise`对象。正如我们将看到的，这使我们能够在队列中的所有任务完成时手动`resolve`我们的`Promise`对象。\\n* 然后，我们应该看看我们如何定义任务。我们所做的是将一个`onFulfilled()`回调函数的调用添加到由`spider()`返回的`Promise`对象中，所以我们可以计算完成的下载任务的数量。当完成的下载量与当前页面中链接的数量相同时，我们知道任务已经处理完毕，所以我们可以调用外部`Promise`的`resolve()`函数。\\n\\n> Promises / A +规范规定，then()方法的onFulfilled()和onRejected()回调函数只能调用一次（仅调用onFulfilled()和onRejected()）。Promise接口的实现确保即使我们多次手动调用resolve或reject，Promise也仅可以被resolve或reject一次。\\n\\n现在，使用`Promise`的`Web爬虫应用程序`的第4版应该已经准备好了。我们可能再次注意到下载任务如何并行运行，并发数量限制为2。\\n\\n### 在公有API中暴露回调函数和Promise\\n正如我们在前面所学到的，`Promise`可以被用作回调函数的一个很好的替代品。它们使我们的代码更具可读性和易于理解。虽然`Promise`带来了许多优点，但也要求开发人员理解许多不易于理解的概念，以便正确和熟练地使用。由于这个原因和其他原因，在某些情况下，比起`Promise`来说，很多开发者更偏向于回调函数。\\n\\n现在让我们想象一下，我们想要构建一个执行异步操作的公共库。我们需要做什么？我们是创建了一个基于回调函数的`API`还是一个面向`Promise`的`API`？还是两者均有？\\n\\n这是许多知名的库所面临的问题，至少有两种方法值得一提，使我们能够提供一个多功能的`API`。\\n\\n像`request`，`redis`和`mysql`这样的库所使用的第一种方法是提供一个简单的基于回调函数的`API`，如果需要，开发人员可以选择公开函数。其中一些库提供工具函数来`Promise`化异步回调，但开发人员仍然需要以某种方式将暴露的`API`转换为能够使用`Promise`对象。\\n\\n第二种方法更透明。它还提供了一个面向回调的`API`，但它使回调参数可选。每当回调作为参数传递时，函数将正常运行，在完成时或失败时执行回调。当回调未被传递时，函数将立即返回一个`Promise`对象。这种方法有效地结合了回调函数和`Promise`，使得开发者可以在调用时选择采用什么接口，而不需要提前进行`Promise`化。许多库，如`mongoose`和`sequelize`，都支持这种方法。\\n\\n我们来看一个简单的例子。假设我们要实现一个异步执行除法的模块：\\n\\n```javascript\\nmodule.exports = function asyncDivision(dividend, divisor, cb) {\\n  return new Promise((resolve, reject) => { // [1]\\n    process.nextTick(() => {\\n      const result = dividend / divisor;\\n      if (isNaN(result) || !Number.isFinite(result)) {\\n        const error = new Error('Invalid operands');\\n        if (cb) {\\n          cb(error); // [2]\\n        }\\n        return reject(error);\\n      }\\n      if (cb) {\\n        cb(null, result); // [3]\\n      }\\n      resolve(result);\\n    });\\n  });\\n};\\n```\\n\\n该模块的代码非常简单，但是有一些值得强调的细节：\\n\\n* 首先，返回使用`Promise`的构造函数创建的新承诺。我们在构造函数参数函数内定义全部逻辑。\\n* 在发生错误的情况下，我们`reject`这个`Promise`，但如果回调函数在被调用时作为参数传递，我们也执行回调来进行错误传播。\\n* 在计算结果之后，我们`resolve`了这个`Promise`，但是如果有回调函数，我们也会将结果传播给回调函数。\\n\\n我们现在看如何用回调函数和`Promise`来使用这个模块：\\n\\n```javascript\\n// 回调函数的方式\\nasyncDivision(10, 2, (error, result) => {\\n  if (error) {\\n    return console.error(error);\\n  }\\n  console.log(result);\\n});\\n\\n// Promise化的调用方式\\nasyncDivision(22, 11)\\n  .then(result => console.log(result))\\n  .catch(error => console.error(error));\\n```\\n\\n应该很清楚的是，即将开始使用类似于上述的新模块的开发人员将很容易地选择最适合自己需求的风格，而无需在希望利用`Promise`时引入外部`promisification`功能。\\n\\n## Generators\\n`ES2015`规范引入了另外一种机制，除了其他新功能外，还可以用来简化`Node.js`应用程序的异步控制流程。我们正在谈论`Generator`，也被称为`semi-coroutines`。它们是子程序的一般化，可以有不同的入口点。在一个正常的函数中，实际上我们只能有一个入口点，这个入口点对应着函数本身的调用。`Generator`与一般函数类似，但是可以暂停（使用`yield`语句），然后在稍后继续执行。在实现迭代器时，`Generator`特别有用，因为我们已经讨论了如何使用迭代器来实现重要的异步控制流模式，如顺序执行和限制并行执行。\\n\\n### Generators基础\\n在我们探索使用`Generator`来实现异步控制流程之前，学习一些基本概念是很重要的。我们从语法开始吧。可以通过在函数关键字之后附加`*`（星号）运算符来声明`Generator`函数：\\n\\n```javascript\\nfunction* makeGenerator() {\\n  // body\\n}\\n```\\n\\n在`makeGenerator()`函数内部，我们可以使用关键字`yield`暂停执行并返回给调用者传递给它的值：\\n\\n```javascript\\nfunction* makeGenerator() {\\n  yield 'Hello World';\\n  console.log('Re-entered');\\n}\\n```\\n\\n在前面的代码中，`Generator`通过`yield`一个字符串`Hello World`暂停当前函数的执行。当`Generator`恢复时，执行将从下列语句开始：\\n\\n```javascript\\nconsole.log('Re-entered');\\n```\\n\\n`makeGenerator()`函数本质上是一个工厂，它在被调用时返回一个新的`Generator`对象：\\n\\n```javascript\\nconst gen = makeGenerator();\\n```\\n\\n生成器对象的最重要的方法是`next()`，它用于启动/恢复`Generator`的执行，并返回如下形式的对象：\\n\\n```\\n{\\n  value: <yielded value>\\n  done: <true if the execution reached the end>\\n}\\n```\\n\\n这个对象包含`Generator` `yield`的值和一个指示`Generator`是否已经完成执行的符号。\\n\\n### 一个简单的例子\\n为了演示`Generator`，我们来创建一个名为`fruitGenerator.js`的新模块：\\n\\n```javascript\\nfunction* fruitGenerator() {\\n  yield 'apple';\\n  yield 'orange';\\n  return 'watermelon';\\n}\\nconst newFruitGenerator = fruitGenerator();\\nconsole.log(newFruitGenerator.next()); // [1]\\nconsole.log(newFruitGenerator.next()); // [2]\\nconsole.log(newFruitGenerator.next()); // [3]\\n```\\n\\n前面的代码将打印下面的输出：\\n\\n```\\n{ value: 'apple', done: false }\\n{ value: 'orange', done: false }\\n{ value: 'watermelon', done: true }\\n```\\n\\n我们可以这么解释上述现象：\\n\\n* 第一次调用`newFruitGenerator.next()`时，`Generator`函数开始执行，直到达到第一个`yield`语句为止，该命令暂停`Generator`函数执行，并将值`apple`返回给调用者。\\n* 在第二次调用`newFruitGenerator.next()`时，`Generator`函数恢复执行，从第二个`yield`语句开始，这又使得执行暂停，同时将`orange`返回给调用者。\\n* `newFruitGenerator.next()`的最后一次调用导致`Generator`函数的执行从其最后的`yield`恢复，一个返回语句，它终止`Generator`函数，返回`watermelon`，并将结果对象中的`done`属性设置为`true`。\\n\\n### Generators作为迭代器\\n为了更好地理解为什么`Generator`函数对实现迭代器非常有用，我们来构建一个例子。在我们将调用`iteratorGenerator.js`的新模块中，我们编写下面的代码：\\n\\n```javascript\\nfunction* iteratorGenerator(arr) {\\n  for (let i = 0; i < arr.length; i++) {\\n    yield arr[i];\\n  }\\n}\\nconst iterator = iteratorGenerator(['apple', 'orange', 'watermelon']);\\nlet currentItem = iterator.next();\\nwhile (!currentItem.done) {\\n  console.log(currentItem.value);\\n  currentItem = iterator.next();\\n}\\n```\\n\\n此代码应按如下所示打印数组中的元素：\\n\\n```\\napple\\norange\\nwatermelon\\n```\\n\\n在这个例子中，每次我们调用`iterator.next()`时，我们都会恢复`Generator`函数的`for`循环，通过`yield`数组中的下一个项来运行另一个循环。这演示了如何在函数调用过程中维护`Generator`的状态。当继续执行时，循环和所有变量的值与`Generator`函数执行暂停时的状态完全相同。\\n\\n### 传值给Generators\\n现在我们继续研究`Generator`的基本功能，首先学习如何将值传递回`Generator`函数。这其实很简单，我们需要做的只是为`next()`方法提供一个参数，并且该值将作为`Generator`函数内的`yield`语句的返回值提供。\\n\\n为了展示这一点，我们来创建一个新的简单模块：\\n\\n```javascript\\nfunction* twoWayGenerator() {\\n  const what = yield null;\\n  console.log('Hello ' + what);\\n}\\nconst twoWay = twoWayGenerator();\\ntwoWay.next();\\ntwoWay.next('world');\\n```\\n\\n当执行时，前面的代码会输出`Hello world`。我们做如下的解释：\\n\\n* 第一次调用`next()`方法时，`Generator`函数到达第一个`yield`语句，然后暂停。\\n* 当`next('world')`被调用时，`Generator`函数从上次停止的位置，也就是上次的`yield`语句点恢复，但是这次我们有一个值传递到`Generator`函数。这个值将被赋值到`what`变量。生成器然后执行`console.log()`指令并终止。\\n\\n用类似的方式，我们可以强制`Generator`函数抛出异常。这可以通过使用`Generator`函数的`throw`方法来实现，如下例所示：\\n\\n```javascript\\nconst twoWay = twoWayGenerator();\\ntwoWay.next();\\ntwoWay.throw(new Error());\\n```\\n\\n在这个最后这段代码，`twoWayGenerator()`函数将在`yield`函数返回的时候抛出异常。这就好像从`Generator`函数内部抛出了一个异常一样，这意味着它可以像使用`try ... catch`块一样进行捕获和处理异常。\\n\\n### Generator实现异步控制流\\n你一定想知道`Generator`函数如何帮助我们处理异步操作。我们可以通过创建一个接受`Generator`函数作为参数的特殊函数来演示这一点，并允许我们在`Generator`函数内部使用异步代码。这个函数在异步操作完成时要注意恢复`Generator`函数的执行。我们将调用这个函数`asyncFlow()`：\\n\\n```javascript\\nfunction asyncFlow(generatorFunction) {\\n  function callback(err) {\\n    if (err) {\\n      return generator.throw(err);\\n    }\\n    const results = [].slice.call(arguments, 1);\\n    generator.next(results.length > 1 ? results : results[0]);\\n  }\\n  const generator = generatorFunction(callback);\\n  generator.next();\\n}\\n```\\n\\n前面的函数取一个`Generator`函数作为输入，然后立即调用：\\n\\n```javascript\\nconst generator = generatorFunction(callback);\\ngenerator.next();\\n```\\n\\n`generatorFunction()`接受一个特殊的回调函数作为参数，当`generator.throw()`如果接收到一个错误，便立即返回。另外，通过将在回调函数中接收的`results`传值回`Generator`函数继续`Generator`函数的执行:\\n\\n```javascript\\nif (err) {\\n  return generator.throw(err);\\n}\\nconst results = [].slice.call(arguments, 1);\\ngenerator.next(results.length > 1 ? results : results[0]);\\n```\\n\\n为了说明这个简单的辅助函数的强大，我们创建一个叫做`clone.js`的新模块，这个模块只是创建它本身的克隆。粘贴我们刚才创建的`asyncFlow()`函数，核心代码如下：\\n\\n```javascript\\nconst fs = require('fs');\\nconst path = require('path');\\nasyncFlow(function*(callback) {\\n  const fileName = path.basename(__filename);\\n  const myself = yield fs.readFile(fileName, 'utf8', callback);\\n  yield fs.writeFile(`clone_of_${filename}`, myself, callback);\\n  console.log('Clone created');\\n});\\n```\\n\\n明显地，有了`asyncFlow()`函数的帮助，我们可以像我们书写同步阻塞函数一样用同步的方式来书写异步代码了。并且这个结果背后的原理显得很清楚。一旦异步操作结束，传递给每个异步函数的回调函数将继续`Generator`函数的执行。没有什么复杂的，但是结果确实很令人意外。\\n\\n这个技术有其他两个变化，一个是`Promise`的使用，另外一个则是`thunks`。\\n\\n> 在基于Generator的控制流中使用的thunk只是一个简单的函数，它除了回调之外，部分地应用了原始函数的所有参数。返回值是另一个只接受回调作为参数的函数。例如，fs.readFile（）的thunkified版本如下所示：\\n\\n```javascript\\nfunction readFileThunk(filename, options) {\\n  return function(callback) {\\n    fs.readFile(filename, options, callback);\\n  }\\n}\\n```\\n\\n`thunk`和`Promise`都允许我们创建不需要回调的`Generator`函数作为参数传递，例如，使用`thunk`的`asyncFlow()`版本如下：\\n\\n```javascript\\nfunction asyncFlowWithThunks(generatorFunction) {\\n  function callback(err) {\\n    if (err) {\\n      return generator.throw(err);\\n    }\\n    const results = [].slice.call(arguments, 1);\\n    const thunk = generator.next(results.length > 1 ? results : results[0]).value;\\n    thunk && thunk(callback);\\n  }\\n  const generator = generatorFunction();\\n  const thunk = generator.next().value;\\n  thunk && thunk(callback);\\n}\\n```\\n\\n这个技巧是读取`generator.next()`的返回值，返回值中包含`thunk`。下一步是通过注入特殊的回调函数调用`thunk`本身。这允许我们写下面的代码：\\n\\n```javascript\\nasyncFlowWithThunk(function*() {\\n  const fileName = path.basename(__filename);\\n  const myself = yield readFileThunk(__filename, 'utf8');\\n  yield writeFileThunk(`clone_of_${fileName}`, myself);\\n  console.log(\\\"Clone created\\\")\\n});\\n```\\n\\n### 使用co的基于Gernator的控制流\\n你应该已经猜到了，`Node.js`生态系统会借助`Generator`函数来提供一些处理异步控制流的解决方案，例如，[suspend](https://npm/js.org/package/suspend)是其中一个最老的支持`Promise`、`thunks`和`Node.js`风格回调函数和正常风格的回调函数的 库。还有，大部分我们之前分析的`Promise`库都提供工具函数使得`Generator`和`Promise`可以一起使用。\\n\\n我们选择[co](https://npmjs.org/package/co)作为本章节的例子。它支持很多类型的`yieldables`，其中一些是：\\n\\n* `Thunks`\\n* `Promises`\\n* `Arrays`(并行执行)\\n* `Objects`(并行执行)\\n* `Generators`(委托)\\n* `Generator`函数(委托)\\n\\n还有很多框架或库是基于`co`生态系统的，包括以下一些：\\n\\n* `Web框架`，最流行的是[koa](https://npmjs.org/package/koa)\\n* 实现特定控制流模式的库\\n* 包装流行的`API`兼容`co`的库\\n\\n我们使用`co`重新实现我们的`Generator`版本的`Web爬虫应用程序`。\\n\\n为了将`Node.js`风格的函数转换成`thunks`，我们将会使用一个叫做[thunkify](https://npmjs.org/package/thunkify)的库。\\n\\n### 顺序执行\\n让我们通过修改`Web爬虫应用程序`的版本2开始我们对`Generator`函数和`co`的实际探索。我们要做的第一件事就是加载我们的依赖包，并生成我们要使用的函数的`thunkified`版本。这些将在`spider.js`模块的最开始进行：\\n\\n```javascript\\nconst thunkify = require('thunkify');\\nconst co = require('co');\\nconst request = thunkify(require('request'));\\nconst fs = require('fs');\\nconst mkdirp = thunkify(require('mkdirp'));\\nconst readFile = thunkify(fs.readFile);\\nconst writeFile = thunkify(fs.writeFile);\\nconst nextTick = thunkify(process.nextTick);\\n```\\n\\n看上述代码，我们可以注意到与本章前面`promisify`化的`API`的代码的一些相似之处。在这一点上，有意思的是，如果我们使用我们的`promisified`版本的函数来代替`thunkified`的版本，代码将保持完全一样，这要归功于`co`支持`thunk`和`Promise`对象作为`yieldable`对象。事实上，如果我们想，甚至可以在同一个应用程序中使用`thunk`和`Promise`，即使在同一个`Generator`函数中。就灵活性而言，这是一个巨大的优势，因为它使我们能够使用基于`Generator`函数的控制流来解决我们应用程序中的问题。\\n\\n好的，现在让我们开始将`download()`函数转换为一个`Generator`函数：\\n\\n```javascript\\nfunction* download(url, filename) {\\n  console.log(`Downloading ${url}`);\\n  const response = yield request(url);\\n  const body = response[1];\\n  yield mkdirp(path.dirname(filename));\\n  yield writeFile(filename, body);\\n  console.log(`Downloaded and saved ${url}`);\\n  return body;\\n}\\n```\\n\\n通过使用`Generator`和`co`，我们的`download()`函数变得简单多了。当我们需要做异步操作的时候，我们使用异步的`Generator`函数作为`thunk`来把之前的内容转化到`Generator`函数，并使用`yield`子句。\\n\\n然后我们开始实现我们的`spider()`函数：\\n\\n```javascript\\nfunction* spider(url, nesting) {\\n  cost filename = utilities.urlToFilename(url);\\n  let body;\\n  try {\\n    body = yield readFile(filename, 'utf8');\\n  } catch (err) {\\n    if (err.code !== 'ENOENT') {\\n      throw err;\\n    }\\n    body = yield download(url, filename);\\n  }\\n  yield spiderLinks(url, body, nesting);\\n}\\n```\\n\\n从上述代码中一个有趣的细节是我们可以使用`try...catch`语句块来处理异常。我们还可以使用`throw`来传播异常。另外一个细节是我们`yield`我们的`download()`函数，而这个函数既不是一个`thunk`，也不是一个`promisified`函数，只是另外的一个`Generator`函数。这也毫无问题，由于`co`也支持其他`Generators`作为`yieldables`。\\n\\n最后转换`spiderLinks()`，在这个函数中，我们递归下载一个网页的链接。在这个函数中使用`Generators`，显得简单多了：\\n\\n```javascript\\nfunction* spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return nextTick();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  for (let i = 0; i < links.length; i++) {\\n    yield spider(links[i], nesting - 1);\\n  }\\n}\\n```\\n\\n看上述代码。虽然顺序迭代没有什么模式可以展示。`Generator`和`co`辅助我们做了很多，方便了我们可以使用同步方式开书写异步代码。\\n\\n看最重要的部分，程序的入口：\\n\\n```javascript\\nco(function*() {\\n  try {\\n    yield spider(process.argv[2], 1);\\n    console.log(`Download complete`);\\n  } catch (err) {\\n    console.log(err);\\n  }\\n});\\n```\\n\\n这是唯一一处需要调用`co(...)`来封装的一个`Generator`。实际上，一旦我们这么做，`co`会自动封装我们传递给`yield`语句的任何`Generator`函数，并且这个过程是递归的，所以程序的剩余部分与我们是否使用`co`是完全无关的，虽然是被`co`封装在里面。\\n\\n现在应该可以运行使用`Generator`函数改写的`Web爬虫应用程序`了。\\n\\n### 并行执行\\n不幸的是，虽然`Generator`很方便地进行顺序执行，但是不能直接用来并行化执行一组任务，至少不能仅仅使用`yield`和`Generator`。之前，在种情况下我们使用的模式只是简单地依赖于一个基于回调或者`Promise`的函数，但使用了`Generator`函数后，一切会显得更简单。\\n\\n幸运的是，如果不限制并发数的并行执行，`co`已经可以通过`yield`一个`Promise`对象、`thunk`、`Generator`函数，甚至包含`Generator`函数的数组来实现。\\n\\n考虑到这一点，我们的`Web爬虫应用程序`第三版可以通过重写`spiderLinks()`函数来做如下改动：\\n\\n```javascript\\nfunction* spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return nextTick();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  const tasks = links.map(link => spider(link, nesting - 1));\\n  yield tasks;\\n}\\n```\\n\\n但是上述函数所做的只是拿到所有的任务，这些任务本质上都是通过`Generator`函数来实现异步的，如果在`co`的`thunk`内对一个包含`Generator`函数的数组使用`yield`，这些任务都会并行执行。外层的`Generator`函数会等到`yield`子句的所有异步任务并行执行后再继续执行。\\n\\n接下来我们看怎么用一个基于回调函数的方式来解决相同的并行流。我们用这种方式重写`spiderLinks()`函数：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return nextTick();\\n  }\\n  // 返回一个thunk\\n  return callback => {\\n    let completed = 0,\\n      hasErrors = false;\\n    const links = utilities.getPageLinks(currentUrl, body);\\n    if (links.length === 0) {\\n      return process.nextTick(callback);\\n    }\\n\\n    function done(err, result) {\\n      if (err && !hasErrors) {\\n        hasErrors = true;\\n        return callback(err);\\n      }\\n      if (++completed === links.length && !hasErrors) {\\n        callback();\\n      }\\n    }\\n    for (let i = 0; i < links.length; i++) {\\n      co(spider(links[i], nesting - 1)).then(done);\\n    }\\n  }\\n}\\n```\\n\\n我们使用`co`并行运行`spider()`函数，调用`Generator`函数返回了一个`Promise`对象。这样，等待`Promise`完成后调用`done()`函数。通常，基于`Generator`控制流的库都有这一功能，因此如果需要，你总是可以将一个`Generator`转换成一个基于回调或基于`Promise`的函数。\\n\\n为了并行开启多个下载任务，我们只要重用在前面定义的基于回调的并行执行的模式。我们应该也注意到我们将`spiderLinks()`转换成一个`thunk`(而不再是一个`Generator`函数)。这使得当全部并行任务完成时，我们有一个回调函数可以调用。\\n\\n> 上面讲到的是将一个Generator函数转换为一个thunk的模式，使之能够支持其他的基于回调或基于Promise的控制流算法，并可以通过同步阻塞的代码风格书写异步代码。\\n\\n### 限制并行执行\\n现在我们知道如何处理异步执行流程，应该很容易规划我们的`Web爬虫应用程序`的第四版的实现，这个版本对并发下载任务的数量施加了限制。我们有几个方案可以用来做到这一点。其中一些方案如下：\\n\\n* 使用先前实现的基于回调的`TaskQueue`类。我们只需要`thunkify`我们的`Generator`函数和其提供的回调函数即可。\\n* 使用基于`Promise`的`TaskQueue`类，并确保每个作为任务的`Generator`函数都被转换成一个返回`Promise`对象的函数。\\n* 使用`async`，`thunkify`我们打算使用的工具函数，此外还需要把我们用到的`Generator`函数转化为基于回调的模式，以便于能够被这个库较好地使用。\\n* 使用基于`co`的生态系统中的库，特别是专门为这种场景的库，如[co-limiter](https://npmjs.org/package/co-limiter)。\\n* 实现基于生产者 - 消费者模型的自定义算法，这与`co-limiter`的内部实现原理相同。\\n\\n为了学习，我们选择最后一个方案，甚至帮助我们可以更好地理解一种经常与协程(也和线程和进程)同步相关的模式。\\n\\n### 生产者 - 消费者模式\\n我们的目标是利用队列来提供固定数量的`workers`，与我们想要设置的并发级别一样多。为了实现这个算法，我们将基于本章前面定义的`TaskQueue`类改写：\\n\\n```javascript\\nclass TaskQueue {\\n  constructor(concurrency) {\\n    this.concurrency = concurrency;\\n    this.running = 0;\\n    this.taskQueue = [];\\n    this.consumerQueue = [];\\n    this.spawnWorkers(concurrency);\\n  }\\n  pushTask(task) {\\n    if (this.consumerQueue.length !== 0) {\\n      this.consumerQueue.shift()(null, task);\\n    } else {\\n      this.taskQueue.push(task);\\n    }\\n  }\\n  spawnWorkers(concurrency) {\\n    const self = this;\\n    for (let i = 0; i < concurrency; i++) {\\n      co(function*() {\\n        while (true) {\\n          const task = yield self.nextTask();\\n          yield task;\\n        }\\n      });\\n    }\\n  }\\n  nextTask() {\\n    return callback => {\\n      if (this.taskQueue.length !== 0) {\\n        return callback(null, this.taskQueue.shift());\\n      }\\n      this.consumerQueue.push(callback);\\n    }\\n  }\\n}\\n```\\n\\n让我们分析这个`TaskQueue`类的新实现。首先是在构造函数中。需要调用一次`this.spawnWorkers()`，因为这是启动`worker`的方法。\\n\\n我们的`worker`很简单，它们只是用`co()`包装的立即执行的`Generator`函数，所以每个`Generator`函数可以并行执行。在内部，每个`worker`正在运行在一个死循环（`while(true){}`）中，一直阻塞（`yield`）到新任务在队列中可用时（`yield self.nextTask()`），一旦可以执行新任务，`yield`这个异步任务直到其完成。您可能想知道我们如何能够限制并行执行，并让下一个任务在队列中处于等待状态。答案是在`nextTask()`方法中。我们来详细地看看在这个方法的原理：\\n\\n```javascript\\nnextTask() {\\n  return callback => {\\n    if (this.taskQueue.length !== 0) {\\n      return callback(null, this.taskQueue.shift());\\n    }\\n    this.consumerQueue.push(callback);\\n  }\\n}\\n```\\n\\n我们看这个函数内部发生了什么，这才是这个模式的核心：\\n\\n1. 这个方法返回一个对于`co`而言是一个合法的`yieldable`的`thunk`。\\n2. 只要`taskQueue`类生成的实例中还有下一个任务，`thunk`的回调函数会被立即调用。回调函数调用时，立马解锁一个`worker`的阻塞状态，`yield`这一个任务。\\n3. 如果队列中没有任务了，回调函数本身会被放入`consumerQueue`中。通过这种做法，我们将一个`worker`置于空闲（`idle`）的模式。一旦我们有一个新的任务来要处理，在`consumerQueue`队列中的回调函数会被调用，立马唤醒我们这一`worker`进行异步处理。\\n\\n现在，为了理解`consumerQueue`队列中的空闲`worker`是如何恢复工作的，我们需要分析`pushTask()`方法。如果当前有回调函数可用的话，`pushTask()`方法将调用`consumerQueue`队列中的第一个回调函数，从而将取消对`worker`的锁定。如果没有可用的回调函数，这意味着所有的`worker`都是工作状态，只需要添加一个新的任务到`taskQueue`任务队列中。\\n\\n在`TaskQueue`类中，`worker`充当消费者的角色，而调用`pushTask()`函数的角色可以被认为是生产者。这个模式向我们展示了一个`Generator`函数实际上可以跟一个线程或进程类似。实际上，生产者 - 消费者之间问题是研究进程间通信和同步时最常见的问题，但正如我们已经提到的那样，它对于进程和线程来说，也是一个常见的例子。\\n\\n### 限制下载任务的并发量\\n既然我们已经使用`Generator`函数和生产者 - 消费者模型实现一个限制并行算法，并且已经在`Web爬虫应用程序`第四版应用它来限制中下载任务的并发数。 首先，我们加载和初始化一个`TaskQueue`对象：\\n\\n```javascript\\nconst TaskQueue = require('./taskQueue');\\nconst downloadQueue = new TaskQueue(2);\\n```\\n\\n然后，修改`spiderLinks()`函数。和之前不限制并发的版本类似，所以这里我们只展示修改的部分，主要是通过调用新版本的`TaskQueue`类生成的实例的`pushTask()`方法来限制并行执行：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  //...\\n  return (callback) => {\\n    //...\\n    function done(err, result) {\\n      //...\\n    }\\n    links.forEach(function(link) {\\n      downloadQueue.pushTask(function*() {\\n        yield spider(link, nesting - 1);\\n        done();\\n      });\\n    });\\n  }\\n}\\n```\\n\\n在每个任务中，我们在下载完成后立即调用`done()`函数，因此我们可以计算下载了多少个链接，然后在完成下载时通知`thunk`的回调函数执行。\\n\\n## 配合Babel使用Async await新语法\\n回调函数、`Promise`和`Generator`函数都是用于处理`JavaScript`和`Node.js`异步问题的方式。正如我们所看到的，`Generator`的真正意义在于它提供了一种方式来暂停一个函数的执行，然后等待前面的任务完成后再继续执行。我们可以使用这样的特性来书写异步代码，并且让开发者用同步阻塞的代码风格来书写异步代码。等到异步操作的结果返回后才恢复当前函数的执行。\\n\\n但`Generator`函数是更多的是用来处理迭代器，然而迭代器在异步代码的使用显得有点笨重。代码可能难以理解，导致代码易读性和可维护性差。\\n\\n但在不远的将来会有一种更加简洁的语法。实际上，这个提议即将引入到`ESMASCript 2017`的规范中，这项规范定义了`async`函数语法。\\n\\n`async`函数规范引入两个关键字(`async`和`await`)到原生的`JavaScript`语言中，改进我们书写异步代码的方式。\\n\\n为了理解这项语法的用法和优势为，我们看一个简单的例子：\\n\\n```javascript\\nconst request = require('request');\\n\\nfunction getPageHtml(url) {\\n  return new Promise(function(resolve, reject) {\\n    request(url, function(error, response, body) {\\n      resolve(body);\\n    });\\n  });\\n}\\nasync function main() {\\n  const html = await getPageHtml('http://google.com');\\n  console.log(html);\\n}\\n\\nmain();\\nconsole.log('Loading...');\\n```\\n\\n在上述代码中，有两个函数：`getPageHtml`和`main`。第一个函数的作用是提取给定`URL`的一个远程网页的`HTML`文档代码。值得注意的是，这个函数返回一个`Promise`对象。\\n\\n重点在于`main`函数，因为在这里使用了`async`和`await`关键字。首先要注意的是函数要以`async`关键字为前缀。意思是这个函数执行的是异步代码并且允许它在函数体内使用`await`关键字。`await`关键字在`getPageHtml`调用之前，告诉`JavaScript`解释器在继续执行下一条指令之前，等待`getPageHtml`返回的`Promise`对象的结果。这样，`main`函数内部哪部分代码是异步的，它会等待异步代码的完成再继续执行后续操作，并且不会阻塞这段程序其余部分的正常执行。实际上，控制台会打印字符串`Loading...`，随后是Google主页的`HTML`代码。\\n\\n是不是这种方法的可读性更好并且更容易理解呢? 不幸地是，这个提议尚未定案，即使通过这个提议，我们需要等下一个版本\\n的`ECMAScript`规范出来并把它集成到`Node.js`后，才能使用这个新语法。 所以我们今天做了什么?只是漫无目的地等待?不是，当然不是！我们已经可以在我们的代码中使用`async await`语法，只要我们使用`Babel`。\\n\\n### 安装与运行Babel\\n`Babel`是一个`JavaScript`编译器(或翻译器)，能够使用语法转换器将高版本的`JavaScript`代码转换成其他`JavaScript`代码。语法转换器允许例如我们书写并使用`ES2015`，`ES2016`，`JSX`和其它的新语法，来翻译成往后兼容的代码，在`JavaScript`运行环境如浏览器或`Node.js`中都可以使用`Babel`。\\n\\n在项目中使用`npm`安装`Babel`，命令如下：\\n\\n```\\nnpm install --save-dev babel-cli\\n```\\n\\n我们还需要安装插件以支持`async await`语法的解释或翻译：\\n\\n```\\nnpm install --save-dev babel-plugin-syntax-async-functions babel-plugin-tranform-async-to-generator\\n```\\n\\n现在假设我们想运行我们之前的例子（称为`index.js`）。我们需要通过以下命令启动：\\n\\n```\\nnode_modules/.bin/babel-node --plugins \\\"syntax-async-functions,transform-async-to-generator\\\" index.js\\n```\\n\\n这样，我们使用支持`async await`的转换器动态地转换源代码。`Node.js`运行的实际是保存在内存中的往后兼容的代码。\\n\\n`Babel`也能被配置为一个代码构建工具，保存翻译或解释后的代码到本地文件系统中，便于我们部署和运行生成的代码。\\n\\n> 关于如何安装和配置Babel，可以到官方网站 https://babeljs.io 查阅相关文档。\\n\\n## 几种方式的比较\\n现在，我们应该对于怎么处理`JavaScript`的异步问题有了一个更好的认识和总结。在下面的表格中总结几大机制的优势和劣势：\\n\\n![](http://oczira72b.bkt.clouddn.com/17-11-7/55293366.jpg)\\n\\n> 值得一提的是，我们选择在本章中仅介绍处理异步控制流程的最受欢迎的解决方案，或者是广泛使用的解决方案，但是例如Fibers（ https://npmjs.org/package/fibers ）和Streamline（ https://npmjs.org/p ackage/streamline ）也是值得一看的。\\n\\n## 总结\\n在本章中，我们分析了一些处理异步控制流的方法，分析了`Promise`、`Generator`函数和即将到来的`async await`语法。\\n\\n我们学习了如何使用这些方法编写更简洁，更具有可读性的异步代码。我们讨论了这些方法的一些最重要的优点和缺点，并认识到即使它们非常有用，也需要一些时间来掌握。这就是这几种方式也没有完全取代在许多情况下仍然非常有用的回调的原因。作为一名开发人员，应该按照实际情况分析决定使用哪种解决方案。如果您正在构建执行异步操作的公共库，则应该提供易于使用的`API`，即使对于只想使用回调的开发人员也是如此。\\n\\n在下一章中，我们将探讨另一个与异步代码执行相关的机制，这也是整个`Node.js`生态系统中的另一个基本构建块：`streams`。\",\n        \"_id\": \"5a20d798b564820d22f6910a\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-12-01T04:16:24.262Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 5,\n    \"viewed\": 49,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:16:24.341] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/art/getArticleDetail?id=5a0e8b7949b148371be1f96e
request client ip:  ::1
request query:  {"id":"5a0e8b7949b148371be1f96e"}
response time: 3
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-12-01T04:16:24.253Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"# Asynchronous Control Flow Patterns with ES2015 and Beyond\\n在上一章中，我们学习了如何使用回调处理异步代码，以及如何解决如回调地狱代码等异步问题。回调是`JavaScript`和`Node.js`中的异步编程的基础，但是现在，其他替代方案已经出现。这些替代方案更复杂，以便能够以更方便的方式处理异步代码。\\n\\n在本章中，我们将探讨一些代表性的替代方案，`Promise`和`Generator`。以及`async await`，这是一种创新的语法，可在高版本的`JavaScript`中提供，其也作为`ECMAScript 2017`发行版的一部分。\\n\\n我们将看到这些替代方案如何简化处理异步控制流的方式。最后，我们将比较所有这些方法，以了解所有这些方法的所有优点和缺点，并能够明智地选择最适合我们下一个`Node.js`项目要求的方法。\\n\\n## Promise\\n我们在前面的章节中提到，`CPS风格`不是编写异步代码的唯一方法。事实上，`JavaScript`生态系统为传统的回调模式提供了有趣的替代方案。最着名的选择之一是`Promise`，特别是现在它是`ECMAScript 2015`的一部分，并且现在可以在`Node.js`中可用。\\n\\n### 什么是Promise？\\n`Promise`是一种抽象的对象，我们通常允许函数返回一个名为`Promise`的对象，它表示异步操作的最终结果。通常情况下，我们说当异步操作尚未完成时，我们说`Promise`对象处于`pending`状态，当操作成功完成时，我们说`Promise`对象处于`resolve`状态，当操作错误终止时，我们说`Promise`对象处于`reject`状态。一旦`Promise`处于`resolve`或`reject`，我们认为当前异步操作结束。\\n\\n为了接收到异步操作的正确结果或错误捕获，我们可以使用`Promise`的`then`方法：\\n\\n```javascript\\npromise.then([onFulfilled], [onRejected])\\n```\\n\\n在前面的代码中，`onFulfilled()`是一个函数，最终会收到`Promise`的正确结果，而`onRejected()`是另一个函数，它将接收产生异常的原因（如果有的话）。两个参数都是可选的。\\n\\n要了解`Promise`如何转换我们的代码，让我们考虑以下几点：\\n\\n```javascript\\nasyncOperation(arg, (err, result) => {\\n  if (err) {\\n    // 错误处理\\n  }\\n  // 正常结果处理\\n});\\n```\\n\\n`Promise`允许我们将这个典型的`CPS`代码转换成更好的结构化和更优雅的代码，如下所示：\\n\\n```javascript\\nasyncOperation(arg)\\n  .then(result => {\\n    // 错误处理\\n  }, err => {\\n    // 正常结果处理\\n  });\\n```\\n\\n`then()`方法的一个关键特征是它同步地返回另一个`Promise`对象。如果`onFulfilled()`或`onRejected()`函数中的任何一个函数返回`x`，则`then()`方法返回的`Promise`对象将如下所示：\\n\\n* 如果`x`是一个值，则这个`Promise`对象会正确处理(`resolve`)`x`\\n* 如果`x`是一个`Promise`对象或`thenable`，则会正确处理(`resolve`)`x`\\n* 如果`x`是一个异常，则会捕获异常(`reject`)`x`\\n\\n> 注：thenable是一个具有then方法的类似于Promise的对象(Promise-like)。\\n\\n这个特点使我们能够链式构建`Promise`，允许轻松排列组合我们的异步操作。另外，如果我们没有指定一个`onFulfilled()`或`onRejected()`处理程序，则正确结果或异常捕获将自动转发到`Promise`链的下一个`Promise`。例如，这允许我们在整个链中自动传播错误，直到被`onRejected()`处理程序捕获。随着`Promise`链，任务的顺序执行突然变成简单多了：\\n\\n```javascript\\nasyncOperation(arg)\\n  .then(result1 => {\\n    // 返回另一个Promise\\n    return asyncOperation(arg2);\\n  })\\n  .then(result2 => {\\n    // 返回一个值\\n    return 'done';\\n  })\\n  .then(undefined, err => {\\n    // 捕获Promise链中的异常\\n  });\\n```\\n\\n下图展示了链式`Promise`如何工作：\\n\\n![](http://oczira72b.bkt.clouddn.com/17-10-31/46370382.jpg)\\n\\n`Promise`的另一个重要特性是`onFulfilled()`和`onRejected()`函数是异步调用的，如同上述的例子，在最后那个`then`函数`resolve`一个同步的`Promise`，它也是同步的。这种模式避免了`Zalgo`（参见`Chapter2-Node.js Essential Patterns`），使我们的异步代码更加一致和稳健。\\n\\n如果在`onFulfilled()`或`onRejected()`处理程序中抛出异常（使用`throw`语句），则`then()`方法返回的`Promise`将被自动地`reject`，抛出异常作为`reject`的原因。这相对于`CPS`来说是一个巨大的优势，因为它意味着有了`Promise`，异常将在整个链中自动传播，并且`throw`语句终于可以使用。\\n\\n在以前，许多不同的库实现了`Promise`，大多数时候它们之间不兼容，这意味着不可能在使用不同`Promise`库的`thenable`链式传播错误。\\n\\n`JavaScript`社区非常努力地解决了这个限制，这些努力导致了`Promises / A +`规范的创建。该规范详细描述了`then`方法的行为，提供了一个可互兼容的基础，这使得来自不同库的`Promise`对象能够彼此兼容，开箱即用。\\n\\n有关`Promises / A +`规范的详细说明，可以参考[Promises / A + 官方网站](https://promisesaplus.com)。\\n\\n### Promise / A + 的实施\\n在`JavaScript`中以及`Node.js`中，有几个实现`Promises / A +`规范的库。以下是最受欢迎的：\\n\\n* [Bluebird](https://npmjs.org/package/bluebird)\\n* [Q](https://npmjs.org/package/q)\\n* [RSVP](https://npmjs.org/package/rsvp)\\n* [Vow](https://npmjs.org/package/vow)\\n* [When.js](https://npmjs.org/package/when)\\n* ES2015 promises\\n\\n真正区别他们的是在`Promises / A +`标准之上提供的额外功能。正如我们上述所说的那样，该标准定义了`then()`方法和`Promise`解析过程的行为，但它没有指定其他功能，例如，如何从基于回调的异步函数创建`Promise`。\\n\\n在我们的示例中，我们将使用由`ES2015`的`Promise`，因为`Promise`对象自`Node.js 4`后即可使用，而不需要任何库来实现。\\n\\n作为参考，以下是`ES2015`的`Promise`提供的API：\\n\\n`constructor`(`new Promise（function（resolve, reject）{}）`)：创建了一个新的`Promise`，它基于作为传递两个类型为函数的参数来决定`resolve`或`reject`。构造函数的参数解释如下：\\n\\n* `resolve(obj)` ：`resolve`一个`Promise`，并带上一个参数`obj`，如果`obj`是一个值，这个值就是传递的异步操作成功的结果。如果`obj`是一个`Promise`或一个`thenable`，则会进行正确处理。\\n* `reject(err)`：`reject`一个`Promise`，并带上一个参数`err`。它是`Error`对象的一个实例。\\n\\n#### Promise对象的静态方法\\n* `Promise.resolve(obj)`： 将会创建一个`resolve`的`Promise`实例\\n* `Promise.reject(err)`： 将会创建一个`reject`的`Promise`实例\\n* `Promise.all(iterable)`：返回一个新的`Promise`实例，并且在`iterable`中所\\n有`Promise`状态为`reject`时, 返回的`Promise`实例的状态会被置为`reject`，如果`iterable`中至少有一个`Promise`状态为`reject`时, 返回的`Promise`实例状态也会被置为`reject`，并且`reject`的原因是第一个被`reject`的`Promise`对象的`reject`原因。\\n* `Promise.race(iterable)`：返回一个`Promise`实例，当`iterable`中任何一个`Promise`被`resolve`或被`reject`时， 返回的`Promise`实例以同样的原因`resolve`或`reject`。\\n\\n#### Promise实例方法\\n* `Promise.then(onFulfilled, onRejected)`：这是`Promise`的基本方法。它的行为与我们之前描述的`Promises / A +`标准兼容。\\n* `Promise.catch(onRejected)`：这只是`Promise.then(undefined，onRejected)`的语法糖。\\n\\n> 值得一提的是，一些Promise实现提供了另一种机制来创建新的Promise，称为deferreds。我们不会在这里描述，因为它不是ES2015标准的一部分，但是如果您想了解更多信息，可以阅读Q文档 (https://github.com/kriskowal/q#using-deferreds) 或When.js文档 (https://github.com/cujojs/when/wiki/Deferred) 。\\n\\n### Promisifying一个Node.js回调风格的函数\\n在`JavaScript`中，并不是所有的异步函数和库都支持开箱即用的`Promise`。大多数情况下，我们必须将一个典型的基于回调的函数转换成一个返回`Promise`的函数，这个过程也被称为`promisification`。\\n\\n幸运的是，`Node.js`中使用的回调约定允许我们创建一个可重用的函数，我们通过使用`Promise`对象的构造函数来简化任何`Node.js`风格的`API`。让我们创建一个名为`promisify()`的新函数，并将其包含到`utilities.js`模块中（以便稍后在我们的`Web爬虫应用程序`中使用它）：\\n\\n```javascript\\nmodule.exports.promisify = function(callbackBasedApi) {\\n  return function promisified() {\\n    const args = [].slice.call(arguments);\\n    return new Promise((resolve, reject) => {\\n      args.push((err, result) => {\\n        if (err) {\\n          return reject(err);\\n        }\\n        if (arguments.length <= 2) {\\n          resolve(result);\\n        } else {\\n          resolve([].slice.call(arguments, 1));\\n        }\\n      });\\n      callbackBasedApi.apply(null, args);\\n    });\\n  }\\n};\\n```\\n\\n前面的函数返回另一个名为`promisified()`的函数，它表示输入中给出的`callbackBasedApi`的`promisified`版本。以下展示它是如何工作的：\\n\\n1. `promisified()`函数使用`Promise`构造函数创建一个新的`Promise`对象，并立即将其返回给调用者。\\n2. 在传递给`Promise`构造函数的函数中，我们确保传递给`callbackBasedApi`，这是一个特殊的回调函数。由于我们知道回调总是最后调用的，我们只需将回调函数附加到提供给`promisified()`函数的参数列表里（`args`）。\\n3. 在特殊的回调中，如果我们收到错误，我们立即`reject`这个`Promise`。\\n4. 如果没有收到错误，我们使用一个值或一个数组值来`resolve`这个`Promise`，具体取决于传递给回调的结果数量。\\n5. 最后，我们只需使用我们构建的参数列表调用`callbackBasedApi`。\\n\\n> 大部分的Promise已经提供了一个开箱即用的接口来将一个Node.js风格的API转换成一个返回Promise的API。例如，Q有Q.denodeify()和Q.nbind()，Bluebird有Promise.promisify()，而When.js有node.lift()。\\n\\n### 顺序执行\\n在一些必要的理论之后，我们现在准备将我们的`Web爬虫应用程序`转换为使用`Promise`的形式。让我们直接从版本2开始，直接下载一个Web网页的链接。\\n\\n在`spider.js`模块中，第一步是加载我们的`Promise`实现（我们稍后会使用它）和`Promisifying`我们打算使用的基于回调的函数：\\n\\n```javascript\\nconst utilities = require('./utilities');\\nconst request = utilities.promisify(require('request'));\\nconst mkdirp = utilities.promisify(require('mkdirp'));\\nconst fs = require('fs');\\nconst readFile = utilities.promisify(fs.readFile);\\nconst writeFile = utilities.promisify(fs.writeFile);\\n```\\n\\n现在，我们开始更改我们的`download`函数：\\n\\n```javascript\\nfunction download(url, filename) {\\n  console.log(`Downloading ${url}`);\\n  let body;\\n  return request(url)\\n    .then(response => {\\n      body = response.body;\\n      return mkdirp(path.dirname(filename));\\n    })\\n    .then(() => writeFile(filename, body))\\n    .then(() => {\\n      console.log(`Downloaded and saved: ${url}`);\\n      return body;\\n    });\\n}\\n```\\n\\n这里要注意的到的最重要的是我们也为`readFile()`返回的`Promise`注册\\n一个`onRejected()`函数，用来处理一个网页没有被下载的情况(或文件不存在)。 还有，看我们如何使用`throw`来传递`onRejected()`函数中的错误的。\\n\\n既然我们已经更改我们的`spider()`函数，我们这么修改它的调用方式：\\n\\n```javascript\\nspider(process.argv[2], 1)\\n  .then(() => console.log('Download complete'))\\n  .catch(err => console.log(err));\\n```\\n\\n注意我们是如何第一次使用`Promise`的语法糖`catch`来处理源自`spider()`函数的任何错误情况。如果我们再看看迄今为止我们所写的所有代码，那么我们会惊喜的发现，我们没有包含任何错误传播逻辑，因为我们在使用回调函数时会被迫做这样的事情。这显然是一个巨大的优势，因为它极大地减少了我们代码中的样板文件以及丢失任何异步错误的机会。\\n\\n现在，完成我们唯一缺失的`Web爬虫应用程序`的第二版的`spiderLinks()`函数，我们将在稍后实现它。\\n\\n### 顺序迭代\\n到目前为止，`Web爬虫应用程序`代码库主要是对`Promise`是什么以及如何使用的概述，展示了使用`Promise`实现顺序执行流程的简单性和优雅性。但是，我们现在考虑的代码只涉及到一组已知的异步操作的执行。所以，完成我们对顺序执行流程的探索的缺失部分是看我们如何使用`Promise`来实现迭代。同样，网络蜘蛛第二版的`spiderLinks()`函数也是一个很好的例子。\\n\\n让我们添加缺少的这一块：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  let promise = Promise.resolve();\\n  if (nesting === 0) {\\n    return promise;\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  links.forEach(link => {\\n    promise = promise.then(() => spider(link, nesting - 1));\\n  });\\n  return promise;\\n}\\n```\\n\\n为了异步迭代一个网页的全部链接，我们必须动态创建一个`Promise`的迭代链。\\n\\n1. 首先，我们定义一个空的`Promise`，`resolve`为`undefined`。这个`Promise`只是用来作为`Promise`的迭代链的起始点。 \\n2. 然后，我们通过在循环中调用链中前一个`Promise`的`then()`方法获得的新的`Promise`来更新`Promise`变量。这就是我们使用`Promise`的异步迭代模式。\\n\\n这样，循环的结束，`promise`变量会包含循环中最后一个`then()`返回的`Promise`对象，所以它只有当`Promise`的迭代链中全部`Promise`对象被`resolve`后才能被`resolve`。\\n\\n> 注：在最后调用了这个then方法来resolve这个Promise对象\\n\\n通过这个，我们已使用`Promise`对象重写了我们的`Web爬虫应用程序`。我们现在应该可以运行它了。\\n\\n### 顺序迭代模式\\n为了总结这个顺序执行的部分，让我们提取一个模式来依次遍历一组`Promise`：\\n\\n```javascript\\nlet tasks = [ /* ... */ ]\\nlet promise = Promise.resolve();\\ntasks.forEach(task => {\\n  promise = promise.then(() => {\\n    return task();\\n  });\\n});\\npromise.then(() => {\\n  // 所有任务都完成\\n});\\n```\\n\\n使用`reduce()`方法来替代`forEach()`方法，允许我们写出更为简洁的代码：\\n\\n```javascript\\nlet tasks = [ /* ... */ ]\\nlet promise = tasks.reduce((prev, task) => {\\n  return prev.then(() => {\\n    return task();\\n  });\\n}, Promise.resolve());\\n\\npromise.then(() => {\\n  //All tasks completed\\n});\\n```\\n\\n与往常一样，通过对这种模式的简单调整，我们可以将所有任务的结果收集到一个数组中，我们可以实现一个`mapping`算法，或者构建一个`filter`等等。\\n\\n> 上述这个模式使用循环动态地建立一个链式的Promise。\\n\\n### 并行执行\\n另一个适合用`Promise`的执行流程是并行执行流程。实际上，我们需要做的就是使用内置的`Promise.all()`。这个方法创造了另一个`Promise`对象，只有在输入中的所有`Promise`都`resolve`时才能`resolve`。这是一个并行执行，因为在其参数`Promise`对象的之间没有执行顺序可言。\\n\\n为了演示这一点，我们来看我们的`Web爬虫应用程序`的第三版，它将页面中的所有链接并行下载。让我们再次使用`Promise`更新`spiderLinks()`函数来实现并行流程：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return Promise.resolve();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  const promises = links.map(link => spider(link, nesting - 1));\\n  return Promise.all(promises);\\n}\\n```\\n\\n这里的模式在`elements.map()`迭代中产生一个数组，存放所有异步任务，之后便于同时启动`spider()`任务。这一次，在循环中，我们不等待以前的下载完成，然后开始一个新的下载任务：所有的下载任务在一个循环中一个接一个地开始。之后，我们利用`Promise.all()`方法，它返回一个新的`Promise`对象，当数组中的所有`Promise`对象都被`resolve`时，这个`Promise`对象将被`resolve`。换句话说，所有的下载任务完成，这正是我们想要的。\\n\\n### 限制并行执行\\n不幸的是，`ES2015`的`Promise API`并没有提供一种原生的方式来限制并发任务的数量，但是我们总是可以依靠我们所学到的有关用普通`JavaScript`来限制并发。事实上，我们在`TaskQueue`类中实现的模式可以很容易地被调整来支持返回承诺的任务。这很容易通过修改`next()`方法来完成：\\n\\n```javascript\\nclass TaskQueue {\\n  constructor(concurrency) {\\n    this.concurrency = concurrency;\\n    this.running = 0;\\n    this.queue = [];\\n  }\\n\\n  pushTask(task) {\\n    this.queue.push(task);\\n    this.next();\\n  }\\n\\n  next() {\\n    while (this.running < this.concurrency && this.queue.length) {\\n      const task = this.queue.shift();\\n      task().then(() => {\\n        this.running--;\\n        this.next();\\n      });\\n      this.running++;\\n    }\\n  }\\n}\\n```\\n\\n不同于使用一个回调函数来处理任务，我们简单地调用`Promise`的`then()`。\\n\\n让我们回到`spider.js`模块，并修改它以支持我们的新版本的`TaskQueue`类。首先，我们确保定义一个`TaskQueue`的新实例：\\n\\n```javascript\\nconst TaskQueue = require('./taskQueue');\\nconst downloadQueue = new TaskQueue(2);\\n```\\n\\n然后，是我们的`spiderLinks()`函数。这里的修改也是很简单：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return Promise.resolve();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  // 我们需要如下代码，用于创建Promise对象\\n  // 如果没有下列代码，当任务数量为0时，将永远不会resolve\\n  if (links.length === 0) {\\n    return Promise.resolve();\\n  }\\n  return new Promise((resolve, reject) => {\\n    let completed = 0;\\n    let errored = false;\\n    links.forEach(link => {\\n      let task = () => {\\n        return spider(link, nesting - 1)\\n          .then(() => {\\n            if (++completed === links.length) {\\n              resolve();\\n            }\\n          })\\n          .catch(() => {\\n            if (!errored) {\\n              errored = true;\\n              reject();\\n            }\\n          });\\n      };\\n      downloadQueue.pushTask(task);\\n    });\\n  });\\n}\\n```\\n\\n在上述代码中有几点值得我们注意的：\\n\\n* 首先，我们需要返回使用`Promise`构造函数创建的新的`Promise`对象。正如我们将看到的，这使我们能够在队列中的所有任务完成时手动`resolve`我们的`Promise`对象。\\n* 然后，我们应该看看我们如何定义任务。我们所做的是将一个`onFulfilled()`回调函数的调用添加到由`spider()`返回的`Promise`对象中，所以我们可以计算完成的下载任务的数量。当完成的下载量与当前页面中链接的数量相同时，我们知道任务已经处理完毕，所以我们可以调用外部`Promise`的`resolve()`函数。\\n\\n> Promises / A +规范规定，then()方法的onFulfilled()和onRejected()回调函数只能调用一次（仅调用onFulfilled()和onRejected()）。Promise接口的实现确保即使我们多次手动调用resolve或reject，Promise也仅可以被resolve或reject一次。\\n\\n现在，使用`Promise`的`Web爬虫应用程序`的第4版应该已经准备好了。我们可能再次注意到下载任务如何并行运行，并发数量限制为2。\\n\\n### 在公有API中暴露回调函数和Promise\\n正如我们在前面所学到的，`Promise`可以被用作回调函数的一个很好的替代品。它们使我们的代码更具可读性和易于理解。虽然`Promise`带来了许多优点，但也要求开发人员理解许多不易于理解的概念，以便正确和熟练地使用。由于这个原因和其他原因，在某些情况下，比起`Promise`来说，很多开发者更偏向于回调函数。\\n\\n现在让我们想象一下，我们想要构建一个执行异步操作的公共库。我们需要做什么？我们是创建了一个基于回调函数的`API`还是一个面向`Promise`的`API`？还是两者均有？\\n\\n这是许多知名的库所面临的问题，至少有两种方法值得一提，使我们能够提供一个多功能的`API`。\\n\\n像`request`，`redis`和`mysql`这样的库所使用的第一种方法是提供一个简单的基于回调函数的`API`，如果需要，开发人员可以选择公开函数。其中一些库提供工具函数来`Promise`化异步回调，但开发人员仍然需要以某种方式将暴露的`API`转换为能够使用`Promise`对象。\\n\\n第二种方法更透明。它还提供了一个面向回调的`API`，但它使回调参数可选。每当回调作为参数传递时，函数将正常运行，在完成时或失败时执行回调。当回调未被传递时，函数将立即返回一个`Promise`对象。这种方法有效地结合了回调函数和`Promise`，使得开发者可以在调用时选择采用什么接口，而不需要提前进行`Promise`化。许多库，如`mongoose`和`sequelize`，都支持这种方法。\\n\\n我们来看一个简单的例子。假设我们要实现一个异步执行除法的模块：\\n\\n```javascript\\nmodule.exports = function asyncDivision(dividend, divisor, cb) {\\n  return new Promise((resolve, reject) => { // [1]\\n    process.nextTick(() => {\\n      const result = dividend / divisor;\\n      if (isNaN(result) || !Number.isFinite(result)) {\\n        const error = new Error('Invalid operands');\\n        if (cb) {\\n          cb(error); // [2]\\n        }\\n        return reject(error);\\n      }\\n      if (cb) {\\n        cb(null, result); // [3]\\n      }\\n      resolve(result);\\n    });\\n  });\\n};\\n```\\n\\n该模块的代码非常简单，但是有一些值得强调的细节：\\n\\n* 首先，返回使用`Promise`的构造函数创建的新承诺。我们在构造函数参数函数内定义全部逻辑。\\n* 在发生错误的情况下，我们`reject`这个`Promise`，但如果回调函数在被调用时作为参数传递，我们也执行回调来进行错误传播。\\n* 在计算结果之后，我们`resolve`了这个`Promise`，但是如果有回调函数，我们也会将结果传播给回调函数。\\n\\n我们现在看如何用回调函数和`Promise`来使用这个模块：\\n\\n```javascript\\n// 回调函数的方式\\nasyncDivision(10, 2, (error, result) => {\\n  if (error) {\\n    return console.error(error);\\n  }\\n  console.log(result);\\n});\\n\\n// Promise化的调用方式\\nasyncDivision(22, 11)\\n  .then(result => console.log(result))\\n  .catch(error => console.error(error));\\n```\\n\\n应该很清楚的是，即将开始使用类似于上述的新模块的开发人员将很容易地选择最适合自己需求的风格，而无需在希望利用`Promise`时引入外部`promisification`功能。\\n\\n## Generators\\n`ES2015`规范引入了另外一种机制，除了其他新功能外，还可以用来简化`Node.js`应用程序的异步控制流程。我们正在谈论`Generator`，也被称为`semi-coroutines`。它们是子程序的一般化，可以有不同的入口点。在一个正常的函数中，实际上我们只能有一个入口点，这个入口点对应着函数本身的调用。`Generator`与一般函数类似，但是可以暂停（使用`yield`语句），然后在稍后继续执行。在实现迭代器时，`Generator`特别有用，因为我们已经讨论了如何使用迭代器来实现重要的异步控制流模式，如顺序执行和限制并行执行。\\n\\n### Generators基础\\n在我们探索使用`Generator`来实现异步控制流程之前，学习一些基本概念是很重要的。我们从语法开始吧。可以通过在函数关键字之后附加`*`（星号）运算符来声明`Generator`函数：\\n\\n```javascript\\nfunction* makeGenerator() {\\n  // body\\n}\\n```\\n\\n在`makeGenerator()`函数内部，我们可以使用关键字`yield`暂停执行并返回给调用者传递给它的值：\\n\\n```javascript\\nfunction* makeGenerator() {\\n  yield 'Hello World';\\n  console.log('Re-entered');\\n}\\n```\\n\\n在前面的代码中，`Generator`通过`yield`一个字符串`Hello World`暂停当前函数的执行。当`Generator`恢复时，执行将从下列语句开始：\\n\\n```javascript\\nconsole.log('Re-entered');\\n```\\n\\n`makeGenerator()`函数本质上是一个工厂，它在被调用时返回一个新的`Generator`对象：\\n\\n```javascript\\nconst gen = makeGenerator();\\n```\\n\\n生成器对象的最重要的方法是`next()`，它用于启动/恢复`Generator`的执行，并返回如下形式的对象：\\n\\n```\\n{\\n  value: <yielded value>\\n  done: <true if the execution reached the end>\\n}\\n```\\n\\n这个对象包含`Generator` `yield`的值和一个指示`Generator`是否已经完成执行的符号。\\n\\n### 一个简单的例子\\n为了演示`Generator`，我们来创建一个名为`fruitGenerator.js`的新模块：\\n\\n```javascript\\nfunction* fruitGenerator() {\\n  yield 'apple';\\n  yield 'orange';\\n  return 'watermelon';\\n}\\nconst newFruitGenerator = fruitGenerator();\\nconsole.log(newFruitGenerator.next()); // [1]\\nconsole.log(newFruitGenerator.next()); // [2]\\nconsole.log(newFruitGenerator.next()); // [3]\\n```\\n\\n前面的代码将打印下面的输出：\\n\\n```\\n{ value: 'apple', done: false }\\n{ value: 'orange', done: false }\\n{ value: 'watermelon', done: true }\\n```\\n\\n我们可以这么解释上述现象：\\n\\n* 第一次调用`newFruitGenerator.next()`时，`Generator`函数开始执行，直到达到第一个`yield`语句为止，该命令暂停`Generator`函数执行，并将值`apple`返回给调用者。\\n* 在第二次调用`newFruitGenerator.next()`时，`Generator`函数恢复执行，从第二个`yield`语句开始，这又使得执行暂停，同时将`orange`返回给调用者。\\n* `newFruitGenerator.next()`的最后一次调用导致`Generator`函数的执行从其最后的`yield`恢复，一个返回语句，它终止`Generator`函数，返回`watermelon`，并将结果对象中的`done`属性设置为`true`。\\n\\n### Generators作为迭代器\\n为了更好地理解为什么`Generator`函数对实现迭代器非常有用，我们来构建一个例子。在我们将调用`iteratorGenerator.js`的新模块中，我们编写下面的代码：\\n\\n```javascript\\nfunction* iteratorGenerator(arr) {\\n  for (let i = 0; i < arr.length; i++) {\\n    yield arr[i];\\n  }\\n}\\nconst iterator = iteratorGenerator(['apple', 'orange', 'watermelon']);\\nlet currentItem = iterator.next();\\nwhile (!currentItem.done) {\\n  console.log(currentItem.value);\\n  currentItem = iterator.next();\\n}\\n```\\n\\n此代码应按如下所示打印数组中的元素：\\n\\n```\\napple\\norange\\nwatermelon\\n```\\n\\n在这个例子中，每次我们调用`iterator.next()`时，我们都会恢复`Generator`函数的`for`循环，通过`yield`数组中的下一个项来运行另一个循环。这演示了如何在函数调用过程中维护`Generator`的状态。当继续执行时，循环和所有变量的值与`Generator`函数执行暂停时的状态完全相同。\\n\\n### 传值给Generators\\n现在我们继续研究`Generator`的基本功能，首先学习如何将值传递回`Generator`函数。这其实很简单，我们需要做的只是为`next()`方法提供一个参数，并且该值将作为`Generator`函数内的`yield`语句的返回值提供。\\n\\n为了展示这一点，我们来创建一个新的简单模块：\\n\\n```javascript\\nfunction* twoWayGenerator() {\\n  const what = yield null;\\n  console.log('Hello ' + what);\\n}\\nconst twoWay = twoWayGenerator();\\ntwoWay.next();\\ntwoWay.next('world');\\n```\\n\\n当执行时，前面的代码会输出`Hello world`。我们做如下的解释：\\n\\n* 第一次调用`next()`方法时，`Generator`函数到达第一个`yield`语句，然后暂停。\\n* 当`next('world')`被调用时，`Generator`函数从上次停止的位置，也就是上次的`yield`语句点恢复，但是这次我们有一个值传递到`Generator`函数。这个值将被赋值到`what`变量。生成器然后执行`console.log()`指令并终止。\\n\\n用类似的方式，我们可以强制`Generator`函数抛出异常。这可以通过使用`Generator`函数的`throw`方法来实现，如下例所示：\\n\\n```javascript\\nconst twoWay = twoWayGenerator();\\ntwoWay.next();\\ntwoWay.throw(new Error());\\n```\\n\\n在这个最后这段代码，`twoWayGenerator()`函数将在`yield`函数返回的时候抛出异常。这就好像从`Generator`函数内部抛出了一个异常一样，这意味着它可以像使用`try ... catch`块一样进行捕获和处理异常。\\n\\n### Generator实现异步控制流\\n你一定想知道`Generator`函数如何帮助我们处理异步操作。我们可以通过创建一个接受`Generator`函数作为参数的特殊函数来演示这一点，并允许我们在`Generator`函数内部使用异步代码。这个函数在异步操作完成时要注意恢复`Generator`函数的执行。我们将调用这个函数`asyncFlow()`：\\n\\n```javascript\\nfunction asyncFlow(generatorFunction) {\\n  function callback(err) {\\n    if (err) {\\n      return generator.throw(err);\\n    }\\n    const results = [].slice.call(arguments, 1);\\n    generator.next(results.length > 1 ? results : results[0]);\\n  }\\n  const generator = generatorFunction(callback);\\n  generator.next();\\n}\\n```\\n\\n前面的函数取一个`Generator`函数作为输入，然后立即调用：\\n\\n```javascript\\nconst generator = generatorFunction(callback);\\ngenerator.next();\\n```\\n\\n`generatorFunction()`接受一个特殊的回调函数作为参数，当`generator.throw()`如果接收到一个错误，便立即返回。另外，通过将在回调函数中接收的`results`传值回`Generator`函数继续`Generator`函数的执行:\\n\\n```javascript\\nif (err) {\\n  return generator.throw(err);\\n}\\nconst results = [].slice.call(arguments, 1);\\ngenerator.next(results.length > 1 ? results : results[0]);\\n```\\n\\n为了说明这个简单的辅助函数的强大，我们创建一个叫做`clone.js`的新模块，这个模块只是创建它本身的克隆。粘贴我们刚才创建的`asyncFlow()`函数，核心代码如下：\\n\\n```javascript\\nconst fs = require('fs');\\nconst path = require('path');\\nasyncFlow(function*(callback) {\\n  const fileName = path.basename(__filename);\\n  const myself = yield fs.readFile(fileName, 'utf8', callback);\\n  yield fs.writeFile(`clone_of_${filename}`, myself, callback);\\n  console.log('Clone created');\\n});\\n```\\n\\n明显地，有了`asyncFlow()`函数的帮助，我们可以像我们书写同步阻塞函数一样用同步的方式来书写异步代码了。并且这个结果背后的原理显得很清楚。一旦异步操作结束，传递给每个异步函数的回调函数将继续`Generator`函数的执行。没有什么复杂的，但是结果确实很令人意外。\\n\\n这个技术有其他两个变化，一个是`Promise`的使用，另外一个则是`thunks`。\\n\\n> 在基于Generator的控制流中使用的thunk只是一个简单的函数，它除了回调之外，部分地应用了原始函数的所有参数。返回值是另一个只接受回调作为参数的函数。例如，fs.readFile（）的thunkified版本如下所示：\\n\\n```javascript\\nfunction readFileThunk(filename, options) {\\n  return function(callback) {\\n    fs.readFile(filename, options, callback);\\n  }\\n}\\n```\\n\\n`thunk`和`Promise`都允许我们创建不需要回调的`Generator`函数作为参数传递，例如，使用`thunk`的`asyncFlow()`版本如下：\\n\\n```javascript\\nfunction asyncFlowWithThunks(generatorFunction) {\\n  function callback(err) {\\n    if (err) {\\n      return generator.throw(err);\\n    }\\n    const results = [].slice.call(arguments, 1);\\n    const thunk = generator.next(results.length > 1 ? results : results[0]).value;\\n    thunk && thunk(callback);\\n  }\\n  const generator = generatorFunction();\\n  const thunk = generator.next().value;\\n  thunk && thunk(callback);\\n}\\n```\\n\\n这个技巧是读取`generator.next()`的返回值，返回值中包含`thunk`。下一步是通过注入特殊的回调函数调用`thunk`本身。这允许我们写下面的代码：\\n\\n```javascript\\nasyncFlowWithThunk(function*() {\\n  const fileName = path.basename(__filename);\\n  const myself = yield readFileThunk(__filename, 'utf8');\\n  yield writeFileThunk(`clone_of_${fileName}`, myself);\\n  console.log(\\\"Clone created\\\")\\n});\\n```\\n\\n### 使用co的基于Gernator的控制流\\n你应该已经猜到了，`Node.js`生态系统会借助`Generator`函数来提供一些处理异步控制流的解决方案，例如，[suspend](https://npm/js.org/package/suspend)是其中一个最老的支持`Promise`、`thunks`和`Node.js`风格回调函数和正常风格的回调函数的 库。还有，大部分我们之前分析的`Promise`库都提供工具函数使得`Generator`和`Promise`可以一起使用。\\n\\n我们选择[co](https://npmjs.org/package/co)作为本章节的例子。它支持很多类型的`yieldables`，其中一些是：\\n\\n* `Thunks`\\n* `Promises`\\n* `Arrays`(并行执行)\\n* `Objects`(并行执行)\\n* `Generators`(委托)\\n* `Generator`函数(委托)\\n\\n还有很多框架或库是基于`co`生态系统的，包括以下一些：\\n\\n* `Web框架`，最流行的是[koa](https://npmjs.org/package/koa)\\n* 实现特定控制流模式的库\\n* 包装流行的`API`兼容`co`的库\\n\\n我们使用`co`重新实现我们的`Generator`版本的`Web爬虫应用程序`。\\n\\n为了将`Node.js`风格的函数转换成`thunks`，我们将会使用一个叫做[thunkify](https://npmjs.org/package/thunkify)的库。\\n\\n### 顺序执行\\n让我们通过修改`Web爬虫应用程序`的版本2开始我们对`Generator`函数和`co`的实际探索。我们要做的第一件事就是加载我们的依赖包，并生成我们要使用的函数的`thunkified`版本。这些将在`spider.js`模块的最开始进行：\\n\\n```javascript\\nconst thunkify = require('thunkify');\\nconst co = require('co');\\nconst request = thunkify(require('request'));\\nconst fs = require('fs');\\nconst mkdirp = thunkify(require('mkdirp'));\\nconst readFile = thunkify(fs.readFile);\\nconst writeFile = thunkify(fs.writeFile);\\nconst nextTick = thunkify(process.nextTick);\\n```\\n\\n看上述代码，我们可以注意到与本章前面`promisify`化的`API`的代码的一些相似之处。在这一点上，有意思的是，如果我们使用我们的`promisified`版本的函数来代替`thunkified`的版本，代码将保持完全一样，这要归功于`co`支持`thunk`和`Promise`对象作为`yieldable`对象。事实上，如果我们想，甚至可以在同一个应用程序中使用`thunk`和`Promise`，即使在同一个`Generator`函数中。就灵活性而言，这是一个巨大的优势，因为它使我们能够使用基于`Generator`函数的控制流来解决我们应用程序中的问题。\\n\\n好的，现在让我们开始将`download()`函数转换为一个`Generator`函数：\\n\\n```javascript\\nfunction* download(url, filename) {\\n  console.log(`Downloading ${url}`);\\n  const response = yield request(url);\\n  const body = response[1];\\n  yield mkdirp(path.dirname(filename));\\n  yield writeFile(filename, body);\\n  console.log(`Downloaded and saved ${url}`);\\n  return body;\\n}\\n```\\n\\n通过使用`Generator`和`co`，我们的`download()`函数变得简单多了。当我们需要做异步操作的时候，我们使用异步的`Generator`函数作为`thunk`来把之前的内容转化到`Generator`函数，并使用`yield`子句。\\n\\n然后我们开始实现我们的`spider()`函数：\\n\\n```javascript\\nfunction* spider(url, nesting) {\\n  cost filename = utilities.urlToFilename(url);\\n  let body;\\n  try {\\n    body = yield readFile(filename, 'utf8');\\n  } catch (err) {\\n    if (err.code !== 'ENOENT') {\\n      throw err;\\n    }\\n    body = yield download(url, filename);\\n  }\\n  yield spiderLinks(url, body, nesting);\\n}\\n```\\n\\n从上述代码中一个有趣的细节是我们可以使用`try...catch`语句块来处理异常。我们还可以使用`throw`来传播异常。另外一个细节是我们`yield`我们的`download()`函数，而这个函数既不是一个`thunk`，也不是一个`promisified`函数，只是另外的一个`Generator`函数。这也毫无问题，由于`co`也支持其他`Generators`作为`yieldables`。\\n\\n最后转换`spiderLinks()`，在这个函数中，我们递归下载一个网页的链接。在这个函数中使用`Generators`，显得简单多了：\\n\\n```javascript\\nfunction* spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return nextTick();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  for (let i = 0; i < links.length; i++) {\\n    yield spider(links[i], nesting - 1);\\n  }\\n}\\n```\\n\\n看上述代码。虽然顺序迭代没有什么模式可以展示。`Generator`和`co`辅助我们做了很多，方便了我们可以使用同步方式开书写异步代码。\\n\\n看最重要的部分，程序的入口：\\n\\n```javascript\\nco(function*() {\\n  try {\\n    yield spider(process.argv[2], 1);\\n    console.log(`Download complete`);\\n  } catch (err) {\\n    console.log(err);\\n  }\\n});\\n```\\n\\n这是唯一一处需要调用`co(...)`来封装的一个`Generator`。实际上，一旦我们这么做，`co`会自动封装我们传递给`yield`语句的任何`Generator`函数，并且这个过程是递归的，所以程序的剩余部分与我们是否使用`co`是完全无关的，虽然是被`co`封装在里面。\\n\\n现在应该可以运行使用`Generator`函数改写的`Web爬虫应用程序`了。\\n\\n### 并行执行\\n不幸的是，虽然`Generator`很方便地进行顺序执行，但是不能直接用来并行化执行一组任务，至少不能仅仅使用`yield`和`Generator`。之前，在种情况下我们使用的模式只是简单地依赖于一个基于回调或者`Promise`的函数，但使用了`Generator`函数后，一切会显得更简单。\\n\\n幸运的是，如果不限制并发数的并行执行，`co`已经可以通过`yield`一个`Promise`对象、`thunk`、`Generator`函数，甚至包含`Generator`函数的数组来实现。\\n\\n考虑到这一点，我们的`Web爬虫应用程序`第三版可以通过重写`spiderLinks()`函数来做如下改动：\\n\\n```javascript\\nfunction* spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return nextTick();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  const tasks = links.map(link => spider(link, nesting - 1));\\n  yield tasks;\\n}\\n```\\n\\n但是上述函数所做的只是拿到所有的任务，这些任务本质上都是通过`Generator`函数来实现异步的，如果在`co`的`thunk`内对一个包含`Generator`函数的数组使用`yield`，这些任务都会并行执行。外层的`Generator`函数会等到`yield`子句的所有异步任务并行执行后再继续执行。\\n\\n接下来我们看怎么用一个基于回调函数的方式来解决相同的并行流。我们用这种方式重写`spiderLinks()`函数：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return nextTick();\\n  }\\n  // 返回一个thunk\\n  return callback => {\\n    let completed = 0,\\n      hasErrors = false;\\n    const links = utilities.getPageLinks(currentUrl, body);\\n    if (links.length === 0) {\\n      return process.nextTick(callback);\\n    }\\n\\n    function done(err, result) {\\n      if (err && !hasErrors) {\\n        hasErrors = true;\\n        return callback(err);\\n      }\\n      if (++completed === links.length && !hasErrors) {\\n        callback();\\n      }\\n    }\\n    for (let i = 0; i < links.length; i++) {\\n      co(spider(links[i], nesting - 1)).then(done);\\n    }\\n  }\\n}\\n```\\n\\n我们使用`co`并行运行`spider()`函数，调用`Generator`函数返回了一个`Promise`对象。这样，等待`Promise`完成后调用`done()`函数。通常，基于`Generator`控制流的库都有这一功能，因此如果需要，你总是可以将一个`Generator`转换成一个基于回调或基于`Promise`的函数。\\n\\n为了并行开启多个下载任务，我们只要重用在前面定义的基于回调的并行执行的模式。我们应该也注意到我们将`spiderLinks()`转换成一个`thunk`(而不再是一个`Generator`函数)。这使得当全部并行任务完成时，我们有一个回调函数可以调用。\\n\\n> 上面讲到的是将一个Generator函数转换为一个thunk的模式，使之能够支持其他的基于回调或基于Promise的控制流算法，并可以通过同步阻塞的代码风格书写异步代码。\\n\\n### 限制并行执行\\n现在我们知道如何处理异步执行流程，应该很容易规划我们的`Web爬虫应用程序`的第四版的实现，这个版本对并发下载任务的数量施加了限制。我们有几个方案可以用来做到这一点。其中一些方案如下：\\n\\n* 使用先前实现的基于回调的`TaskQueue`类。我们只需要`thunkify`我们的`Generator`函数和其提供的回调函数即可。\\n* 使用基于`Promise`的`TaskQueue`类，并确保每个作为任务的`Generator`函数都被转换成一个返回`Promise`对象的函数。\\n* 使用`async`，`thunkify`我们打算使用的工具函数，此外还需要把我们用到的`Generator`函数转化为基于回调的模式，以便于能够被这个库较好地使用。\\n* 使用基于`co`的生态系统中的库，特别是专门为这种场景的库，如[co-limiter](https://npmjs.org/package/co-limiter)。\\n* 实现基于生产者 - 消费者模型的自定义算法，这与`co-limiter`的内部实现原理相同。\\n\\n为了学习，我们选择最后一个方案，甚至帮助我们可以更好地理解一种经常与协程(也和线程和进程)同步相关的模式。\\n\\n### 生产者 - 消费者模式\\n我们的目标是利用队列来提供固定数量的`workers`，与我们想要设置的并发级别一样多。为了实现这个算法，我们将基于本章前面定义的`TaskQueue`类改写：\\n\\n```javascript\\nclass TaskQueue {\\n  constructor(concurrency) {\\n    this.concurrency = concurrency;\\n    this.running = 0;\\n    this.taskQueue = [];\\n    this.consumerQueue = [];\\n    this.spawnWorkers(concurrency);\\n  }\\n  pushTask(task) {\\n    if (this.consumerQueue.length !== 0) {\\n      this.consumerQueue.shift()(null, task);\\n    } else {\\n      this.taskQueue.push(task);\\n    }\\n  }\\n  spawnWorkers(concurrency) {\\n    const self = this;\\n    for (let i = 0; i < concurrency; i++) {\\n      co(function*() {\\n        while (true) {\\n          const task = yield self.nextTask();\\n          yield task;\\n        }\\n      });\\n    }\\n  }\\n  nextTask() {\\n    return callback => {\\n      if (this.taskQueue.length !== 0) {\\n        return callback(null, this.taskQueue.shift());\\n      }\\n      this.consumerQueue.push(callback);\\n    }\\n  }\\n}\\n```\\n\\n让我们分析这个`TaskQueue`类的新实现。首先是在构造函数中。需要调用一次`this.spawnWorkers()`，因为这是启动`worker`的方法。\\n\\n我们的`worker`很简单，它们只是用`co()`包装的立即执行的`Generator`函数，所以每个`Generator`函数可以并行执行。在内部，每个`worker`正在运行在一个死循环（`while(true){}`）中，一直阻塞（`yield`）到新任务在队列中可用时（`yield self.nextTask()`），一旦可以执行新任务，`yield`这个异步任务直到其完成。您可能想知道我们如何能够限制并行执行，并让下一个任务在队列中处于等待状态。答案是在`nextTask()`方法中。我们来详细地看看在这个方法的原理：\\n\\n```javascript\\nnextTask() {\\n  return callback => {\\n    if (this.taskQueue.length !== 0) {\\n      return callback(null, this.taskQueue.shift());\\n    }\\n    this.consumerQueue.push(callback);\\n  }\\n}\\n```\\n\\n我们看这个函数内部发生了什么，这才是这个模式的核心：\\n\\n1. 这个方法返回一个对于`co`而言是一个合法的`yieldable`的`thunk`。\\n2. 只要`taskQueue`类生成的实例中还有下一个任务，`thunk`的回调函数会被立即调用。回调函数调用时，立马解锁一个`worker`的阻塞状态，`yield`这一个任务。\\n3. 如果队列中没有任务了，回调函数本身会被放入`consumerQueue`中。通过这种做法，我们将一个`worker`置于空闲（`idle`）的模式。一旦我们有一个新的任务来要处理，在`consumerQueue`队列中的回调函数会被调用，立马唤醒我们这一`worker`进行异步处理。\\n\\n现在，为了理解`consumerQueue`队列中的空闲`worker`是如何恢复工作的，我们需要分析`pushTask()`方法。如果当前有回调函数可用的话，`pushTask()`方法将调用`consumerQueue`队列中的第一个回调函数，从而将取消对`worker`的锁定。如果没有可用的回调函数，这意味着所有的`worker`都是工作状态，只需要添加一个新的任务到`taskQueue`任务队列中。\\n\\n在`TaskQueue`类中，`worker`充当消费者的角色，而调用`pushTask()`函数的角色可以被认为是生产者。这个模式向我们展示了一个`Generator`函数实际上可以跟一个线程或进程类似。实际上，生产者 - 消费者之间问题是研究进程间通信和同步时最常见的问题，但正如我们已经提到的那样，它对于进程和线程来说，也是一个常见的例子。\\n\\n### 限制下载任务的并发量\\n既然我们已经使用`Generator`函数和生产者 - 消费者模型实现一个限制并行算法，并且已经在`Web爬虫应用程序`第四版应用它来限制中下载任务的并发数。 首先，我们加载和初始化一个`TaskQueue`对象：\\n\\n```javascript\\nconst TaskQueue = require('./taskQueue');\\nconst downloadQueue = new TaskQueue(2);\\n```\\n\\n然后，修改`spiderLinks()`函数。和之前不限制并发的版本类似，所以这里我们只展示修改的部分，主要是通过调用新版本的`TaskQueue`类生成的实例的`pushTask()`方法来限制并行执行：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  //...\\n  return (callback) => {\\n    //...\\n    function done(err, result) {\\n      //...\\n    }\\n    links.forEach(function(link) {\\n      downloadQueue.pushTask(function*() {\\n        yield spider(link, nesting - 1);\\n        done();\\n      });\\n    });\\n  }\\n}\\n```\\n\\n在每个任务中，我们在下载完成后立即调用`done()`函数，因此我们可以计算下载了多少个链接，然后在完成下载时通知`thunk`的回调函数执行。\\n\\n## 配合Babel使用Async await新语法\\n回调函数、`Promise`和`Generator`函数都是用于处理`JavaScript`和`Node.js`异步问题的方式。正如我们所看到的，`Generator`的真正意义在于它提供了一种方式来暂停一个函数的执行，然后等待前面的任务完成后再继续执行。我们可以使用这样的特性来书写异步代码，并且让开发者用同步阻塞的代码风格来书写异步代码。等到异步操作的结果返回后才恢复当前函数的执行。\\n\\n但`Generator`函数是更多的是用来处理迭代器，然而迭代器在异步代码的使用显得有点笨重。代码可能难以理解，导致代码易读性和可维护性差。\\n\\n但在不远的将来会有一种更加简洁的语法。实际上，这个提议即将引入到`ESMASCript 2017`的规范中，这项规范定义了`async`函数语法。\\n\\n`async`函数规范引入两个关键字(`async`和`await`)到原生的`JavaScript`语言中，改进我们书写异步代码的方式。\\n\\n为了理解这项语法的用法和优势为，我们看一个简单的例子：\\n\\n```javascript\\nconst request = require('request');\\n\\nfunction getPageHtml(url) {\\n  return new Promise(function(resolve, reject) {\\n    request(url, function(error, response, body) {\\n      resolve(body);\\n    });\\n  });\\n}\\nasync function main() {\\n  const html = await getPageHtml('http://google.com');\\n  console.log(html);\\n}\\n\\nmain();\\nconsole.log('Loading...');\\n```\\n\\n在上述代码中，有两个函数：`getPageHtml`和`main`。第一个函数的作用是提取给定`URL`的一个远程网页的`HTML`文档代码。值得注意的是，这个函数返回一个`Promise`对象。\\n\\n重点在于`main`函数，因为在这里使用了`async`和`await`关键字。首先要注意的是函数要以`async`关键字为前缀。意思是这个函数执行的是异步代码并且允许它在函数体内使用`await`关键字。`await`关键字在`getPageHtml`调用之前，告诉`JavaScript`解释器在继续执行下一条指令之前，等待`getPageHtml`返回的`Promise`对象的结果。这样，`main`函数内部哪部分代码是异步的，它会等待异步代码的完成再继续执行后续操作，并且不会阻塞这段程序其余部分的正常执行。实际上，控制台会打印字符串`Loading...`，随后是Google主页的`HTML`代码。\\n\\n是不是这种方法的可读性更好并且更容易理解呢? 不幸地是，这个提议尚未定案，即使通过这个提议，我们需要等下一个版本\\n的`ECMAScript`规范出来并把它集成到`Node.js`后，才能使用这个新语法。 所以我们今天做了什么?只是漫无目的地等待?不是，当然不是！我们已经可以在我们的代码中使用`async await`语法，只要我们使用`Babel`。\\n\\n### 安装与运行Babel\\n`Babel`是一个`JavaScript`编译器(或翻译器)，能够使用语法转换器将高版本的`JavaScript`代码转换成其他`JavaScript`代码。语法转换器允许例如我们书写并使用`ES2015`，`ES2016`，`JSX`和其它的新语法，来翻译成往后兼容的代码，在`JavaScript`运行环境如浏览器或`Node.js`中都可以使用`Babel`。\\n\\n在项目中使用`npm`安装`Babel`，命令如下：\\n\\n```\\nnpm install --save-dev babel-cli\\n```\\n\\n我们还需要安装插件以支持`async await`语法的解释或翻译：\\n\\n```\\nnpm install --save-dev babel-plugin-syntax-async-functions babel-plugin-tranform-async-to-generator\\n```\\n\\n现在假设我们想运行我们之前的例子（称为`index.js`）。我们需要通过以下命令启动：\\n\\n```\\nnode_modules/.bin/babel-node --plugins \\\"syntax-async-functions,transform-async-to-generator\\\" index.js\\n```\\n\\n这样，我们使用支持`async await`的转换器动态地转换源代码。`Node.js`运行的实际是保存在内存中的往后兼容的代码。\\n\\n`Babel`也能被配置为一个代码构建工具，保存翻译或解释后的代码到本地文件系统中，便于我们部署和运行生成的代码。\\n\\n> 关于如何安装和配置Babel，可以到官方网站 https://babeljs.io 查阅相关文档。\\n\\n## 几种方式的比较\\n现在，我们应该对于怎么处理`JavaScript`的异步问题有了一个更好的认识和总结。在下面的表格中总结几大机制的优势和劣势：\\n\\n![](http://oczira72b.bkt.clouddn.com/17-11-7/55293366.jpg)\\n\\n> 值得一提的是，我们选择在本章中仅介绍处理异步控制流程的最受欢迎的解决方案，或者是广泛使用的解决方案，但是例如Fibers（ https://npmjs.org/package/fibers ）和Streamline（ https://npmjs.org/p ackage/streamline ）也是值得一看的。\\n\\n## 总结\\n在本章中，我们分析了一些处理异步控制流的方法，分析了`Promise`、`Generator`函数和即将到来的`async await`语法。\\n\\n我们学习了如何使用这些方法编写更简洁，更具有可读性的异步代码。我们讨论了这些方法的一些最重要的优点和缺点，并认识到即使它们非常有用，也需要一些时间来掌握。这就是这几种方式也没有完全取代在许多情况下仍然非常有用的回调的原因。作为一名开发人员，应该按照实际情况分析决定使用哪种解决方案。如果您正在构建执行异步操作的公共库，则应该提供易于使用的`API`，即使对于只想使用回调的开发人员也是如此。\\n\\n在下一章中，我们将探讨另一个与异步代码执行相关的机制，这也是整个`Node.js`生态系统中的另一个基本构建块：`streams`。\",\n        \"_id\": \"5a20d798b564820d22f6910a\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-12-01T04:16:24.262Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 5,\n    \"viewed\": 49,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:17:06.230] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/users/getUserInfo?userName=admin
request client ip:  ::1
request query:  {"userName":"admin"}
response time: 2
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"回复成功\",\n  \"data\": {\n    \"userName\": \"admin\",\n    \"registerTime\": \"2017-11-23T07:36:51.931Z\",\n    \"message\": []\n  }\n}"
*************** response log end ***************

[2017-12-01 12:17:06.245] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/art/updateCheckTimes
request client ip:  ::1
request body: 
{"id":"5a0e8b7949b148371be1f96e","token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxNTc2LCJleHAiOjE1MTIxNDQ3NzZ9.uKBuLKHhVqQEXpCm68cxufPp3HqLhF25sI_3iT0rBmI"}
response time: 6
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-12-01T04:16:24.253Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"# Asynchronous Control Flow Patterns with ES2015 and Beyond\\n在上一章中，我们学习了如何使用回调处理异步代码，以及如何解决如回调地狱代码等异步问题。回调是`JavaScript`和`Node.js`中的异步编程的基础，但是现在，其他替代方案已经出现。这些替代方案更复杂，以便能够以更方便的方式处理异步代码。\\n\\n在本章中，我们将探讨一些代表性的替代方案，`Promise`和`Generator`。以及`async await`，这是一种创新的语法，可在高版本的`JavaScript`中提供，其也作为`ECMAScript 2017`发行版的一部分。\\n\\n我们将看到这些替代方案如何简化处理异步控制流的方式。最后，我们将比较所有这些方法，以了解所有这些方法的所有优点和缺点，并能够明智地选择最适合我们下一个`Node.js`项目要求的方法。\\n\\n## Promise\\n我们在前面的章节中提到，`CPS风格`不是编写异步代码的唯一方法。事实上，`JavaScript`生态系统为传统的回调模式提供了有趣的替代方案。最着名的选择之一是`Promise`，特别是现在它是`ECMAScript 2015`的一部分，并且现在可以在`Node.js`中可用。\\n\\n### 什么是Promise？\\n`Promise`是一种抽象的对象，我们通常允许函数返回一个名为`Promise`的对象，它表示异步操作的最终结果。通常情况下，我们说当异步操作尚未完成时，我们说`Promise`对象处于`pending`状态，当操作成功完成时，我们说`Promise`对象处于`resolve`状态，当操作错误终止时，我们说`Promise`对象处于`reject`状态。一旦`Promise`处于`resolve`或`reject`，我们认为当前异步操作结束。\\n\\n为了接收到异步操作的正确结果或错误捕获，我们可以使用`Promise`的`then`方法：\\n\\n```javascript\\npromise.then([onFulfilled], [onRejected])\\n```\\n\\n在前面的代码中，`onFulfilled()`是一个函数，最终会收到`Promise`的正确结果，而`onRejected()`是另一个函数，它将接收产生异常的原因（如果有的话）。两个参数都是可选的。\\n\\n要了解`Promise`如何转换我们的代码，让我们考虑以下几点：\\n\\n```javascript\\nasyncOperation(arg, (err, result) => {\\n  if (err) {\\n    // 错误处理\\n  }\\n  // 正常结果处理\\n});\\n```\\n\\n`Promise`允许我们将这个典型的`CPS`代码转换成更好的结构化和更优雅的代码，如下所示：\\n\\n```javascript\\nasyncOperation(arg)\\n  .then(result => {\\n    // 错误处理\\n  }, err => {\\n    // 正常结果处理\\n  });\\n```\\n\\n`then()`方法的一个关键特征是它同步地返回另一个`Promise`对象。如果`onFulfilled()`或`onRejected()`函数中的任何一个函数返回`x`，则`then()`方法返回的`Promise`对象将如下所示：\\n\\n* 如果`x`是一个值，则这个`Promise`对象会正确处理(`resolve`)`x`\\n* 如果`x`是一个`Promise`对象或`thenable`，则会正确处理(`resolve`)`x`\\n* 如果`x`是一个异常，则会捕获异常(`reject`)`x`\\n\\n> 注：thenable是一个具有then方法的类似于Promise的对象(Promise-like)。\\n\\n这个特点使我们能够链式构建`Promise`，允许轻松排列组合我们的异步操作。另外，如果我们没有指定一个`onFulfilled()`或`onRejected()`处理程序，则正确结果或异常捕获将自动转发到`Promise`链的下一个`Promise`。例如，这允许我们在整个链中自动传播错误，直到被`onRejected()`处理程序捕获。随着`Promise`链，任务的顺序执行突然变成简单多了：\\n\\n```javascript\\nasyncOperation(arg)\\n  .then(result1 => {\\n    // 返回另一个Promise\\n    return asyncOperation(arg2);\\n  })\\n  .then(result2 => {\\n    // 返回一个值\\n    return 'done';\\n  })\\n  .then(undefined, err => {\\n    // 捕获Promise链中的异常\\n  });\\n```\\n\\n下图展示了链式`Promise`如何工作：\\n\\n![](http://oczira72b.bkt.clouddn.com/17-10-31/46370382.jpg)\\n\\n`Promise`的另一个重要特性是`onFulfilled()`和`onRejected()`函数是异步调用的，如同上述的例子，在最后那个`then`函数`resolve`一个同步的`Promise`，它也是同步的。这种模式避免了`Zalgo`（参见`Chapter2-Node.js Essential Patterns`），使我们的异步代码更加一致和稳健。\\n\\n如果在`onFulfilled()`或`onRejected()`处理程序中抛出异常（使用`throw`语句），则`then()`方法返回的`Promise`将被自动地`reject`，抛出异常作为`reject`的原因。这相对于`CPS`来说是一个巨大的优势，因为它意味着有了`Promise`，异常将在整个链中自动传播，并且`throw`语句终于可以使用。\\n\\n在以前，许多不同的库实现了`Promise`，大多数时候它们之间不兼容，这意味着不可能在使用不同`Promise`库的`thenable`链式传播错误。\\n\\n`JavaScript`社区非常努力地解决了这个限制，这些努力导致了`Promises / A +`规范的创建。该规范详细描述了`then`方法的行为，提供了一个可互兼容的基础，这使得来自不同库的`Promise`对象能够彼此兼容，开箱即用。\\n\\n有关`Promises / A +`规范的详细说明，可以参考[Promises / A + 官方网站](https://promisesaplus.com)。\\n\\n### Promise / A + 的实施\\n在`JavaScript`中以及`Node.js`中，有几个实现`Promises / A +`规范的库。以下是最受欢迎的：\\n\\n* [Bluebird](https://npmjs.org/package/bluebird)\\n* [Q](https://npmjs.org/package/q)\\n* [RSVP](https://npmjs.org/package/rsvp)\\n* [Vow](https://npmjs.org/package/vow)\\n* [When.js](https://npmjs.org/package/when)\\n* ES2015 promises\\n\\n真正区别他们的是在`Promises / A +`标准之上提供的额外功能。正如我们上述所说的那样，该标准定义了`then()`方法和`Promise`解析过程的行为，但它没有指定其他功能，例如，如何从基于回调的异步函数创建`Promise`。\\n\\n在我们的示例中，我们将使用由`ES2015`的`Promise`，因为`Promise`对象自`Node.js 4`后即可使用，而不需要任何库来实现。\\n\\n作为参考，以下是`ES2015`的`Promise`提供的API：\\n\\n`constructor`(`new Promise（function（resolve, reject）{}）`)：创建了一个新的`Promise`，它基于作为传递两个类型为函数的参数来决定`resolve`或`reject`。构造函数的参数解释如下：\\n\\n* `resolve(obj)` ：`resolve`一个`Promise`，并带上一个参数`obj`，如果`obj`是一个值，这个值就是传递的异步操作成功的结果。如果`obj`是一个`Promise`或一个`thenable`，则会进行正确处理。\\n* `reject(err)`：`reject`一个`Promise`，并带上一个参数`err`。它是`Error`对象的一个实例。\\n\\n#### Promise对象的静态方法\\n* `Promise.resolve(obj)`： 将会创建一个`resolve`的`Promise`实例\\n* `Promise.reject(err)`： 将会创建一个`reject`的`Promise`实例\\n* `Promise.all(iterable)`：返回一个新的`Promise`实例，并且在`iterable`中所\\n有`Promise`状态为`reject`时, 返回的`Promise`实例的状态会被置为`reject`，如果`iterable`中至少有一个`Promise`状态为`reject`时, 返回的`Promise`实例状态也会被置为`reject`，并且`reject`的原因是第一个被`reject`的`Promise`对象的`reject`原因。\\n* `Promise.race(iterable)`：返回一个`Promise`实例，当`iterable`中任何一个`Promise`被`resolve`或被`reject`时， 返回的`Promise`实例以同样的原因`resolve`或`reject`。\\n\\n#### Promise实例方法\\n* `Promise.then(onFulfilled, onRejected)`：这是`Promise`的基本方法。它的行为与我们之前描述的`Promises / A +`标准兼容。\\n* `Promise.catch(onRejected)`：这只是`Promise.then(undefined，onRejected)`的语法糖。\\n\\n> 值得一提的是，一些Promise实现提供了另一种机制来创建新的Promise，称为deferreds。我们不会在这里描述，因为它不是ES2015标准的一部分，但是如果您想了解更多信息，可以阅读Q文档 (https://github.com/kriskowal/q#using-deferreds) 或When.js文档 (https://github.com/cujojs/when/wiki/Deferred) 。\\n\\n### Promisifying一个Node.js回调风格的函数\\n在`JavaScript`中，并不是所有的异步函数和库都支持开箱即用的`Promise`。大多数情况下，我们必须将一个典型的基于回调的函数转换成一个返回`Promise`的函数，这个过程也被称为`promisification`。\\n\\n幸运的是，`Node.js`中使用的回调约定允许我们创建一个可重用的函数，我们通过使用`Promise`对象的构造函数来简化任何`Node.js`风格的`API`。让我们创建一个名为`promisify()`的新函数，并将其包含到`utilities.js`模块中（以便稍后在我们的`Web爬虫应用程序`中使用它）：\\n\\n```javascript\\nmodule.exports.promisify = function(callbackBasedApi) {\\n  return function promisified() {\\n    const args = [].slice.call(arguments);\\n    return new Promise((resolve, reject) => {\\n      args.push((err, result) => {\\n        if (err) {\\n          return reject(err);\\n        }\\n        if (arguments.length <= 2) {\\n          resolve(result);\\n        } else {\\n          resolve([].slice.call(arguments, 1));\\n        }\\n      });\\n      callbackBasedApi.apply(null, args);\\n    });\\n  }\\n};\\n```\\n\\n前面的函数返回另一个名为`promisified()`的函数，它表示输入中给出的`callbackBasedApi`的`promisified`版本。以下展示它是如何工作的：\\n\\n1. `promisified()`函数使用`Promise`构造函数创建一个新的`Promise`对象，并立即将其返回给调用者。\\n2. 在传递给`Promise`构造函数的函数中，我们确保传递给`callbackBasedApi`，这是一个特殊的回调函数。由于我们知道回调总是最后调用的，我们只需将回调函数附加到提供给`promisified()`函数的参数列表里（`args`）。\\n3. 在特殊的回调中，如果我们收到错误，我们立即`reject`这个`Promise`。\\n4. 如果没有收到错误，我们使用一个值或一个数组值来`resolve`这个`Promise`，具体取决于传递给回调的结果数量。\\n5. 最后，我们只需使用我们构建的参数列表调用`callbackBasedApi`。\\n\\n> 大部分的Promise已经提供了一个开箱即用的接口来将一个Node.js风格的API转换成一个返回Promise的API。例如，Q有Q.denodeify()和Q.nbind()，Bluebird有Promise.promisify()，而When.js有node.lift()。\\n\\n### 顺序执行\\n在一些必要的理论之后，我们现在准备将我们的`Web爬虫应用程序`转换为使用`Promise`的形式。让我们直接从版本2开始，直接下载一个Web网页的链接。\\n\\n在`spider.js`模块中，第一步是加载我们的`Promise`实现（我们稍后会使用它）和`Promisifying`我们打算使用的基于回调的函数：\\n\\n```javascript\\nconst utilities = require('./utilities');\\nconst request = utilities.promisify(require('request'));\\nconst mkdirp = utilities.promisify(require('mkdirp'));\\nconst fs = require('fs');\\nconst readFile = utilities.promisify(fs.readFile);\\nconst writeFile = utilities.promisify(fs.writeFile);\\n```\\n\\n现在，我们开始更改我们的`download`函数：\\n\\n```javascript\\nfunction download(url, filename) {\\n  console.log(`Downloading ${url}`);\\n  let body;\\n  return request(url)\\n    .then(response => {\\n      body = response.body;\\n      return mkdirp(path.dirname(filename));\\n    })\\n    .then(() => writeFile(filename, body))\\n    .then(() => {\\n      console.log(`Downloaded and saved: ${url}`);\\n      return body;\\n    });\\n}\\n```\\n\\n这里要注意的到的最重要的是我们也为`readFile()`返回的`Promise`注册\\n一个`onRejected()`函数，用来处理一个网页没有被下载的情况(或文件不存在)。 还有，看我们如何使用`throw`来传递`onRejected()`函数中的错误的。\\n\\n既然我们已经更改我们的`spider()`函数，我们这么修改它的调用方式：\\n\\n```javascript\\nspider(process.argv[2], 1)\\n  .then(() => console.log('Download complete'))\\n  .catch(err => console.log(err));\\n```\\n\\n注意我们是如何第一次使用`Promise`的语法糖`catch`来处理源自`spider()`函数的任何错误情况。如果我们再看看迄今为止我们所写的所有代码，那么我们会惊喜的发现，我们没有包含任何错误传播逻辑，因为我们在使用回调函数时会被迫做这样的事情。这显然是一个巨大的优势，因为它极大地减少了我们代码中的样板文件以及丢失任何异步错误的机会。\\n\\n现在，完成我们唯一缺失的`Web爬虫应用程序`的第二版的`spiderLinks()`函数，我们将在稍后实现它。\\n\\n### 顺序迭代\\n到目前为止，`Web爬虫应用程序`代码库主要是对`Promise`是什么以及如何使用的概述，展示了使用`Promise`实现顺序执行流程的简单性和优雅性。但是，我们现在考虑的代码只涉及到一组已知的异步操作的执行。所以，完成我们对顺序执行流程的探索的缺失部分是看我们如何使用`Promise`来实现迭代。同样，网络蜘蛛第二版的`spiderLinks()`函数也是一个很好的例子。\\n\\n让我们添加缺少的这一块：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  let promise = Promise.resolve();\\n  if (nesting === 0) {\\n    return promise;\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  links.forEach(link => {\\n    promise = promise.then(() => spider(link, nesting - 1));\\n  });\\n  return promise;\\n}\\n```\\n\\n为了异步迭代一个网页的全部链接，我们必须动态创建一个`Promise`的迭代链。\\n\\n1. 首先，我们定义一个空的`Promise`，`resolve`为`undefined`。这个`Promise`只是用来作为`Promise`的迭代链的起始点。 \\n2. 然后，我们通过在循环中调用链中前一个`Promise`的`then()`方法获得的新的`Promise`来更新`Promise`变量。这就是我们使用`Promise`的异步迭代模式。\\n\\n这样，循环的结束，`promise`变量会包含循环中最后一个`then()`返回的`Promise`对象，所以它只有当`Promise`的迭代链中全部`Promise`对象被`resolve`后才能被`resolve`。\\n\\n> 注：在最后调用了这个then方法来resolve这个Promise对象\\n\\n通过这个，我们已使用`Promise`对象重写了我们的`Web爬虫应用程序`。我们现在应该可以运行它了。\\n\\n### 顺序迭代模式\\n为了总结这个顺序执行的部分，让我们提取一个模式来依次遍历一组`Promise`：\\n\\n```javascript\\nlet tasks = [ /* ... */ ]\\nlet promise = Promise.resolve();\\ntasks.forEach(task => {\\n  promise = promise.then(() => {\\n    return task();\\n  });\\n});\\npromise.then(() => {\\n  // 所有任务都完成\\n});\\n```\\n\\n使用`reduce()`方法来替代`forEach()`方法，允许我们写出更为简洁的代码：\\n\\n```javascript\\nlet tasks = [ /* ... */ ]\\nlet promise = tasks.reduce((prev, task) => {\\n  return prev.then(() => {\\n    return task();\\n  });\\n}, Promise.resolve());\\n\\npromise.then(() => {\\n  //All tasks completed\\n});\\n```\\n\\n与往常一样，通过对这种模式的简单调整，我们可以将所有任务的结果收集到一个数组中，我们可以实现一个`mapping`算法，或者构建一个`filter`等等。\\n\\n> 上述这个模式使用循环动态地建立一个链式的Promise。\\n\\n### 并行执行\\n另一个适合用`Promise`的执行流程是并行执行流程。实际上，我们需要做的就是使用内置的`Promise.all()`。这个方法创造了另一个`Promise`对象，只有在输入中的所有`Promise`都`resolve`时才能`resolve`。这是一个并行执行，因为在其参数`Promise`对象的之间没有执行顺序可言。\\n\\n为了演示这一点，我们来看我们的`Web爬虫应用程序`的第三版，它将页面中的所有链接并行下载。让我们再次使用`Promise`更新`spiderLinks()`函数来实现并行流程：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return Promise.resolve();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  const promises = links.map(link => spider(link, nesting - 1));\\n  return Promise.all(promises);\\n}\\n```\\n\\n这里的模式在`elements.map()`迭代中产生一个数组，存放所有异步任务，之后便于同时启动`spider()`任务。这一次，在循环中，我们不等待以前的下载完成，然后开始一个新的下载任务：所有的下载任务在一个循环中一个接一个地开始。之后，我们利用`Promise.all()`方法，它返回一个新的`Promise`对象，当数组中的所有`Promise`对象都被`resolve`时，这个`Promise`对象将被`resolve`。换句话说，所有的下载任务完成，这正是我们想要的。\\n\\n### 限制并行执行\\n不幸的是，`ES2015`的`Promise API`并没有提供一种原生的方式来限制并发任务的数量，但是我们总是可以依靠我们所学到的有关用普通`JavaScript`来限制并发。事实上，我们在`TaskQueue`类中实现的模式可以很容易地被调整来支持返回承诺的任务。这很容易通过修改`next()`方法来完成：\\n\\n```javascript\\nclass TaskQueue {\\n  constructor(concurrency) {\\n    this.concurrency = concurrency;\\n    this.running = 0;\\n    this.queue = [];\\n  }\\n\\n  pushTask(task) {\\n    this.queue.push(task);\\n    this.next();\\n  }\\n\\n  next() {\\n    while (this.running < this.concurrency && this.queue.length) {\\n      const task = this.queue.shift();\\n      task().then(() => {\\n        this.running--;\\n        this.next();\\n      });\\n      this.running++;\\n    }\\n  }\\n}\\n```\\n\\n不同于使用一个回调函数来处理任务，我们简单地调用`Promise`的`then()`。\\n\\n让我们回到`spider.js`模块，并修改它以支持我们的新版本的`TaskQueue`类。首先，我们确保定义一个`TaskQueue`的新实例：\\n\\n```javascript\\nconst TaskQueue = require('./taskQueue');\\nconst downloadQueue = new TaskQueue(2);\\n```\\n\\n然后，是我们的`spiderLinks()`函数。这里的修改也是很简单：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return Promise.resolve();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  // 我们需要如下代码，用于创建Promise对象\\n  // 如果没有下列代码，当任务数量为0时，将永远不会resolve\\n  if (links.length === 0) {\\n    return Promise.resolve();\\n  }\\n  return new Promise((resolve, reject) => {\\n    let completed = 0;\\n    let errored = false;\\n    links.forEach(link => {\\n      let task = () => {\\n        return spider(link, nesting - 1)\\n          .then(() => {\\n            if (++completed === links.length) {\\n              resolve();\\n            }\\n          })\\n          .catch(() => {\\n            if (!errored) {\\n              errored = true;\\n              reject();\\n            }\\n          });\\n      };\\n      downloadQueue.pushTask(task);\\n    });\\n  });\\n}\\n```\\n\\n在上述代码中有几点值得我们注意的：\\n\\n* 首先，我们需要返回使用`Promise`构造函数创建的新的`Promise`对象。正如我们将看到的，这使我们能够在队列中的所有任务完成时手动`resolve`我们的`Promise`对象。\\n* 然后，我们应该看看我们如何定义任务。我们所做的是将一个`onFulfilled()`回调函数的调用添加到由`spider()`返回的`Promise`对象中，所以我们可以计算完成的下载任务的数量。当完成的下载量与当前页面中链接的数量相同时，我们知道任务已经处理完毕，所以我们可以调用外部`Promise`的`resolve()`函数。\\n\\n> Promises / A +规范规定，then()方法的onFulfilled()和onRejected()回调函数只能调用一次（仅调用onFulfilled()和onRejected()）。Promise接口的实现确保即使我们多次手动调用resolve或reject，Promise也仅可以被resolve或reject一次。\\n\\n现在，使用`Promise`的`Web爬虫应用程序`的第4版应该已经准备好了。我们可能再次注意到下载任务如何并行运行，并发数量限制为2。\\n\\n### 在公有API中暴露回调函数和Promise\\n正如我们在前面所学到的，`Promise`可以被用作回调函数的一个很好的替代品。它们使我们的代码更具可读性和易于理解。虽然`Promise`带来了许多优点，但也要求开发人员理解许多不易于理解的概念，以便正确和熟练地使用。由于这个原因和其他原因，在某些情况下，比起`Promise`来说，很多开发者更偏向于回调函数。\\n\\n现在让我们想象一下，我们想要构建一个执行异步操作的公共库。我们需要做什么？我们是创建了一个基于回调函数的`API`还是一个面向`Promise`的`API`？还是两者均有？\\n\\n这是许多知名的库所面临的问题，至少有两种方法值得一提，使我们能够提供一个多功能的`API`。\\n\\n像`request`，`redis`和`mysql`这样的库所使用的第一种方法是提供一个简单的基于回调函数的`API`，如果需要，开发人员可以选择公开函数。其中一些库提供工具函数来`Promise`化异步回调，但开发人员仍然需要以某种方式将暴露的`API`转换为能够使用`Promise`对象。\\n\\n第二种方法更透明。它还提供了一个面向回调的`API`，但它使回调参数可选。每当回调作为参数传递时，函数将正常运行，在完成时或失败时执行回调。当回调未被传递时，函数将立即返回一个`Promise`对象。这种方法有效地结合了回调函数和`Promise`，使得开发者可以在调用时选择采用什么接口，而不需要提前进行`Promise`化。许多库，如`mongoose`和`sequelize`，都支持这种方法。\\n\\n我们来看一个简单的例子。假设我们要实现一个异步执行除法的模块：\\n\\n```javascript\\nmodule.exports = function asyncDivision(dividend, divisor, cb) {\\n  return new Promise((resolve, reject) => { // [1]\\n    process.nextTick(() => {\\n      const result = dividend / divisor;\\n      if (isNaN(result) || !Number.isFinite(result)) {\\n        const error = new Error('Invalid operands');\\n        if (cb) {\\n          cb(error); // [2]\\n        }\\n        return reject(error);\\n      }\\n      if (cb) {\\n        cb(null, result); // [3]\\n      }\\n      resolve(result);\\n    });\\n  });\\n};\\n```\\n\\n该模块的代码非常简单，但是有一些值得强调的细节：\\n\\n* 首先，返回使用`Promise`的构造函数创建的新承诺。我们在构造函数参数函数内定义全部逻辑。\\n* 在发生错误的情况下，我们`reject`这个`Promise`，但如果回调函数在被调用时作为参数传递，我们也执行回调来进行错误传播。\\n* 在计算结果之后，我们`resolve`了这个`Promise`，但是如果有回调函数，我们也会将结果传播给回调函数。\\n\\n我们现在看如何用回调函数和`Promise`来使用这个模块：\\n\\n```javascript\\n// 回调函数的方式\\nasyncDivision(10, 2, (error, result) => {\\n  if (error) {\\n    return console.error(error);\\n  }\\n  console.log(result);\\n});\\n\\n// Promise化的调用方式\\nasyncDivision(22, 11)\\n  .then(result => console.log(result))\\n  .catch(error => console.error(error));\\n```\\n\\n应该很清楚的是，即将开始使用类似于上述的新模块的开发人员将很容易地选择最适合自己需求的风格，而无需在希望利用`Promise`时引入外部`promisification`功能。\\n\\n## Generators\\n`ES2015`规范引入了另外一种机制，除了其他新功能外，还可以用来简化`Node.js`应用程序的异步控制流程。我们正在谈论`Generator`，也被称为`semi-coroutines`。它们是子程序的一般化，可以有不同的入口点。在一个正常的函数中，实际上我们只能有一个入口点，这个入口点对应着函数本身的调用。`Generator`与一般函数类似，但是可以暂停（使用`yield`语句），然后在稍后继续执行。在实现迭代器时，`Generator`特别有用，因为我们已经讨论了如何使用迭代器来实现重要的异步控制流模式，如顺序执行和限制并行执行。\\n\\n### Generators基础\\n在我们探索使用`Generator`来实现异步控制流程之前，学习一些基本概念是很重要的。我们从语法开始吧。可以通过在函数关键字之后附加`*`（星号）运算符来声明`Generator`函数：\\n\\n```javascript\\nfunction* makeGenerator() {\\n  // body\\n}\\n```\\n\\n在`makeGenerator()`函数内部，我们可以使用关键字`yield`暂停执行并返回给调用者传递给它的值：\\n\\n```javascript\\nfunction* makeGenerator() {\\n  yield 'Hello World';\\n  console.log('Re-entered');\\n}\\n```\\n\\n在前面的代码中，`Generator`通过`yield`一个字符串`Hello World`暂停当前函数的执行。当`Generator`恢复时，执行将从下列语句开始：\\n\\n```javascript\\nconsole.log('Re-entered');\\n```\\n\\n`makeGenerator()`函数本质上是一个工厂，它在被调用时返回一个新的`Generator`对象：\\n\\n```javascript\\nconst gen = makeGenerator();\\n```\\n\\n生成器对象的最重要的方法是`next()`，它用于启动/恢复`Generator`的执行，并返回如下形式的对象：\\n\\n```\\n{\\n  value: <yielded value>\\n  done: <true if the execution reached the end>\\n}\\n```\\n\\n这个对象包含`Generator` `yield`的值和一个指示`Generator`是否已经完成执行的符号。\\n\\n### 一个简单的例子\\n为了演示`Generator`，我们来创建一个名为`fruitGenerator.js`的新模块：\\n\\n```javascript\\nfunction* fruitGenerator() {\\n  yield 'apple';\\n  yield 'orange';\\n  return 'watermelon';\\n}\\nconst newFruitGenerator = fruitGenerator();\\nconsole.log(newFruitGenerator.next()); // [1]\\nconsole.log(newFruitGenerator.next()); // [2]\\nconsole.log(newFruitGenerator.next()); // [3]\\n```\\n\\n前面的代码将打印下面的输出：\\n\\n```\\n{ value: 'apple', done: false }\\n{ value: 'orange', done: false }\\n{ value: 'watermelon', done: true }\\n```\\n\\n我们可以这么解释上述现象：\\n\\n* 第一次调用`newFruitGenerator.next()`时，`Generator`函数开始执行，直到达到第一个`yield`语句为止，该命令暂停`Generator`函数执行，并将值`apple`返回给调用者。\\n* 在第二次调用`newFruitGenerator.next()`时，`Generator`函数恢复执行，从第二个`yield`语句开始，这又使得执行暂停，同时将`orange`返回给调用者。\\n* `newFruitGenerator.next()`的最后一次调用导致`Generator`函数的执行从其最后的`yield`恢复，一个返回语句，它终止`Generator`函数，返回`watermelon`，并将结果对象中的`done`属性设置为`true`。\\n\\n### Generators作为迭代器\\n为了更好地理解为什么`Generator`函数对实现迭代器非常有用，我们来构建一个例子。在我们将调用`iteratorGenerator.js`的新模块中，我们编写下面的代码：\\n\\n```javascript\\nfunction* iteratorGenerator(arr) {\\n  for (let i = 0; i < arr.length; i++) {\\n    yield arr[i];\\n  }\\n}\\nconst iterator = iteratorGenerator(['apple', 'orange', 'watermelon']);\\nlet currentItem = iterator.next();\\nwhile (!currentItem.done) {\\n  console.log(currentItem.value);\\n  currentItem = iterator.next();\\n}\\n```\\n\\n此代码应按如下所示打印数组中的元素：\\n\\n```\\napple\\norange\\nwatermelon\\n```\\n\\n在这个例子中，每次我们调用`iterator.next()`时，我们都会恢复`Generator`函数的`for`循环，通过`yield`数组中的下一个项来运行另一个循环。这演示了如何在函数调用过程中维护`Generator`的状态。当继续执行时，循环和所有变量的值与`Generator`函数执行暂停时的状态完全相同。\\n\\n### 传值给Generators\\n现在我们继续研究`Generator`的基本功能，首先学习如何将值传递回`Generator`函数。这其实很简单，我们需要做的只是为`next()`方法提供一个参数，并且该值将作为`Generator`函数内的`yield`语句的返回值提供。\\n\\n为了展示这一点，我们来创建一个新的简单模块：\\n\\n```javascript\\nfunction* twoWayGenerator() {\\n  const what = yield null;\\n  console.log('Hello ' + what);\\n}\\nconst twoWay = twoWayGenerator();\\ntwoWay.next();\\ntwoWay.next('world');\\n```\\n\\n当执行时，前面的代码会输出`Hello world`。我们做如下的解释：\\n\\n* 第一次调用`next()`方法时，`Generator`函数到达第一个`yield`语句，然后暂停。\\n* 当`next('world')`被调用时，`Generator`函数从上次停止的位置，也就是上次的`yield`语句点恢复，但是这次我们有一个值传递到`Generator`函数。这个值将被赋值到`what`变量。生成器然后执行`console.log()`指令并终止。\\n\\n用类似的方式，我们可以强制`Generator`函数抛出异常。这可以通过使用`Generator`函数的`throw`方法来实现，如下例所示：\\n\\n```javascript\\nconst twoWay = twoWayGenerator();\\ntwoWay.next();\\ntwoWay.throw(new Error());\\n```\\n\\n在这个最后这段代码，`twoWayGenerator()`函数将在`yield`函数返回的时候抛出异常。这就好像从`Generator`函数内部抛出了一个异常一样，这意味着它可以像使用`try ... catch`块一样进行捕获和处理异常。\\n\\n### Generator实现异步控制流\\n你一定想知道`Generator`函数如何帮助我们处理异步操作。我们可以通过创建一个接受`Generator`函数作为参数的特殊函数来演示这一点，并允许我们在`Generator`函数内部使用异步代码。这个函数在异步操作完成时要注意恢复`Generator`函数的执行。我们将调用这个函数`asyncFlow()`：\\n\\n```javascript\\nfunction asyncFlow(generatorFunction) {\\n  function callback(err) {\\n    if (err) {\\n      return generator.throw(err);\\n    }\\n    const results = [].slice.call(arguments, 1);\\n    generator.next(results.length > 1 ? results : results[0]);\\n  }\\n  const generator = generatorFunction(callback);\\n  generator.next();\\n}\\n```\\n\\n前面的函数取一个`Generator`函数作为输入，然后立即调用：\\n\\n```javascript\\nconst generator = generatorFunction(callback);\\ngenerator.next();\\n```\\n\\n`generatorFunction()`接受一个特殊的回调函数作为参数，当`generator.throw()`如果接收到一个错误，便立即返回。另外，通过将在回调函数中接收的`results`传值回`Generator`函数继续`Generator`函数的执行:\\n\\n```javascript\\nif (err) {\\n  return generator.throw(err);\\n}\\nconst results = [].slice.call(arguments, 1);\\ngenerator.next(results.length > 1 ? results : results[0]);\\n```\\n\\n为了说明这个简单的辅助函数的强大，我们创建一个叫做`clone.js`的新模块，这个模块只是创建它本身的克隆。粘贴我们刚才创建的`asyncFlow()`函数，核心代码如下：\\n\\n```javascript\\nconst fs = require('fs');\\nconst path = require('path');\\nasyncFlow(function*(callback) {\\n  const fileName = path.basename(__filename);\\n  const myself = yield fs.readFile(fileName, 'utf8', callback);\\n  yield fs.writeFile(`clone_of_${filename}`, myself, callback);\\n  console.log('Clone created');\\n});\\n```\\n\\n明显地，有了`asyncFlow()`函数的帮助，我们可以像我们书写同步阻塞函数一样用同步的方式来书写异步代码了。并且这个结果背后的原理显得很清楚。一旦异步操作结束，传递给每个异步函数的回调函数将继续`Generator`函数的执行。没有什么复杂的，但是结果确实很令人意外。\\n\\n这个技术有其他两个变化，一个是`Promise`的使用，另外一个则是`thunks`。\\n\\n> 在基于Generator的控制流中使用的thunk只是一个简单的函数，它除了回调之外，部分地应用了原始函数的所有参数。返回值是另一个只接受回调作为参数的函数。例如，fs.readFile（）的thunkified版本如下所示：\\n\\n```javascript\\nfunction readFileThunk(filename, options) {\\n  return function(callback) {\\n    fs.readFile(filename, options, callback);\\n  }\\n}\\n```\\n\\n`thunk`和`Promise`都允许我们创建不需要回调的`Generator`函数作为参数传递，例如，使用`thunk`的`asyncFlow()`版本如下：\\n\\n```javascript\\nfunction asyncFlowWithThunks(generatorFunction) {\\n  function callback(err) {\\n    if (err) {\\n      return generator.throw(err);\\n    }\\n    const results = [].slice.call(arguments, 1);\\n    const thunk = generator.next(results.length > 1 ? results : results[0]).value;\\n    thunk && thunk(callback);\\n  }\\n  const generator = generatorFunction();\\n  const thunk = generator.next().value;\\n  thunk && thunk(callback);\\n}\\n```\\n\\n这个技巧是读取`generator.next()`的返回值，返回值中包含`thunk`。下一步是通过注入特殊的回调函数调用`thunk`本身。这允许我们写下面的代码：\\n\\n```javascript\\nasyncFlowWithThunk(function*() {\\n  const fileName = path.basename(__filename);\\n  const myself = yield readFileThunk(__filename, 'utf8');\\n  yield writeFileThunk(`clone_of_${fileName}`, myself);\\n  console.log(\\\"Clone created\\\")\\n});\\n```\\n\\n### 使用co的基于Gernator的控制流\\n你应该已经猜到了，`Node.js`生态系统会借助`Generator`函数来提供一些处理异步控制流的解决方案，例如，[suspend](https://npm/js.org/package/suspend)是其中一个最老的支持`Promise`、`thunks`和`Node.js`风格回调函数和正常风格的回调函数的 库。还有，大部分我们之前分析的`Promise`库都提供工具函数使得`Generator`和`Promise`可以一起使用。\\n\\n我们选择[co](https://npmjs.org/package/co)作为本章节的例子。它支持很多类型的`yieldables`，其中一些是：\\n\\n* `Thunks`\\n* `Promises`\\n* `Arrays`(并行执行)\\n* `Objects`(并行执行)\\n* `Generators`(委托)\\n* `Generator`函数(委托)\\n\\n还有很多框架或库是基于`co`生态系统的，包括以下一些：\\n\\n* `Web框架`，最流行的是[koa](https://npmjs.org/package/koa)\\n* 实现特定控制流模式的库\\n* 包装流行的`API`兼容`co`的库\\n\\n我们使用`co`重新实现我们的`Generator`版本的`Web爬虫应用程序`。\\n\\n为了将`Node.js`风格的函数转换成`thunks`，我们将会使用一个叫做[thunkify](https://npmjs.org/package/thunkify)的库。\\n\\n### 顺序执行\\n让我们通过修改`Web爬虫应用程序`的版本2开始我们对`Generator`函数和`co`的实际探索。我们要做的第一件事就是加载我们的依赖包，并生成我们要使用的函数的`thunkified`版本。这些将在`spider.js`模块的最开始进行：\\n\\n```javascript\\nconst thunkify = require('thunkify');\\nconst co = require('co');\\nconst request = thunkify(require('request'));\\nconst fs = require('fs');\\nconst mkdirp = thunkify(require('mkdirp'));\\nconst readFile = thunkify(fs.readFile);\\nconst writeFile = thunkify(fs.writeFile);\\nconst nextTick = thunkify(process.nextTick);\\n```\\n\\n看上述代码，我们可以注意到与本章前面`promisify`化的`API`的代码的一些相似之处。在这一点上，有意思的是，如果我们使用我们的`promisified`版本的函数来代替`thunkified`的版本，代码将保持完全一样，这要归功于`co`支持`thunk`和`Promise`对象作为`yieldable`对象。事实上，如果我们想，甚至可以在同一个应用程序中使用`thunk`和`Promise`，即使在同一个`Generator`函数中。就灵活性而言，这是一个巨大的优势，因为它使我们能够使用基于`Generator`函数的控制流来解决我们应用程序中的问题。\\n\\n好的，现在让我们开始将`download()`函数转换为一个`Generator`函数：\\n\\n```javascript\\nfunction* download(url, filename) {\\n  console.log(`Downloading ${url}`);\\n  const response = yield request(url);\\n  const body = response[1];\\n  yield mkdirp(path.dirname(filename));\\n  yield writeFile(filename, body);\\n  console.log(`Downloaded and saved ${url}`);\\n  return body;\\n}\\n```\\n\\n通过使用`Generator`和`co`，我们的`download()`函数变得简单多了。当我们需要做异步操作的时候，我们使用异步的`Generator`函数作为`thunk`来把之前的内容转化到`Generator`函数，并使用`yield`子句。\\n\\n然后我们开始实现我们的`spider()`函数：\\n\\n```javascript\\nfunction* spider(url, nesting) {\\n  cost filename = utilities.urlToFilename(url);\\n  let body;\\n  try {\\n    body = yield readFile(filename, 'utf8');\\n  } catch (err) {\\n    if (err.code !== 'ENOENT') {\\n      throw err;\\n    }\\n    body = yield download(url, filename);\\n  }\\n  yield spiderLinks(url, body, nesting);\\n}\\n```\\n\\n从上述代码中一个有趣的细节是我们可以使用`try...catch`语句块来处理异常。我们还可以使用`throw`来传播异常。另外一个细节是我们`yield`我们的`download()`函数，而这个函数既不是一个`thunk`，也不是一个`promisified`函数，只是另外的一个`Generator`函数。这也毫无问题，由于`co`也支持其他`Generators`作为`yieldables`。\\n\\n最后转换`spiderLinks()`，在这个函数中，我们递归下载一个网页的链接。在这个函数中使用`Generators`，显得简单多了：\\n\\n```javascript\\nfunction* spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return nextTick();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  for (let i = 0; i < links.length; i++) {\\n    yield spider(links[i], nesting - 1);\\n  }\\n}\\n```\\n\\n看上述代码。虽然顺序迭代没有什么模式可以展示。`Generator`和`co`辅助我们做了很多，方便了我们可以使用同步方式开书写异步代码。\\n\\n看最重要的部分，程序的入口：\\n\\n```javascript\\nco(function*() {\\n  try {\\n    yield spider(process.argv[2], 1);\\n    console.log(`Download complete`);\\n  } catch (err) {\\n    console.log(err);\\n  }\\n});\\n```\\n\\n这是唯一一处需要调用`co(...)`来封装的一个`Generator`。实际上，一旦我们这么做，`co`会自动封装我们传递给`yield`语句的任何`Generator`函数，并且这个过程是递归的，所以程序的剩余部分与我们是否使用`co`是完全无关的，虽然是被`co`封装在里面。\\n\\n现在应该可以运行使用`Generator`函数改写的`Web爬虫应用程序`了。\\n\\n### 并行执行\\n不幸的是，虽然`Generator`很方便地进行顺序执行，但是不能直接用来并行化执行一组任务，至少不能仅仅使用`yield`和`Generator`。之前，在种情况下我们使用的模式只是简单地依赖于一个基于回调或者`Promise`的函数，但使用了`Generator`函数后，一切会显得更简单。\\n\\n幸运的是，如果不限制并发数的并行执行，`co`已经可以通过`yield`一个`Promise`对象、`thunk`、`Generator`函数，甚至包含`Generator`函数的数组来实现。\\n\\n考虑到这一点，我们的`Web爬虫应用程序`第三版可以通过重写`spiderLinks()`函数来做如下改动：\\n\\n```javascript\\nfunction* spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return nextTick();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  const tasks = links.map(link => spider(link, nesting - 1));\\n  yield tasks;\\n}\\n```\\n\\n但是上述函数所做的只是拿到所有的任务，这些任务本质上都是通过`Generator`函数来实现异步的，如果在`co`的`thunk`内对一个包含`Generator`函数的数组使用`yield`，这些任务都会并行执行。外层的`Generator`函数会等到`yield`子句的所有异步任务并行执行后再继续执行。\\n\\n接下来我们看怎么用一个基于回调函数的方式来解决相同的并行流。我们用这种方式重写`spiderLinks()`函数：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return nextTick();\\n  }\\n  // 返回一个thunk\\n  return callback => {\\n    let completed = 0,\\n      hasErrors = false;\\n    const links = utilities.getPageLinks(currentUrl, body);\\n    if (links.length === 0) {\\n      return process.nextTick(callback);\\n    }\\n\\n    function done(err, result) {\\n      if (err && !hasErrors) {\\n        hasErrors = true;\\n        return callback(err);\\n      }\\n      if (++completed === links.length && !hasErrors) {\\n        callback();\\n      }\\n    }\\n    for (let i = 0; i < links.length; i++) {\\n      co(spider(links[i], nesting - 1)).then(done);\\n    }\\n  }\\n}\\n```\\n\\n我们使用`co`并行运行`spider()`函数，调用`Generator`函数返回了一个`Promise`对象。这样，等待`Promise`完成后调用`done()`函数。通常，基于`Generator`控制流的库都有这一功能，因此如果需要，你总是可以将一个`Generator`转换成一个基于回调或基于`Promise`的函数。\\n\\n为了并行开启多个下载任务，我们只要重用在前面定义的基于回调的并行执行的模式。我们应该也注意到我们将`spiderLinks()`转换成一个`thunk`(而不再是一个`Generator`函数)。这使得当全部并行任务完成时，我们有一个回调函数可以调用。\\n\\n> 上面讲到的是将一个Generator函数转换为一个thunk的模式，使之能够支持其他的基于回调或基于Promise的控制流算法，并可以通过同步阻塞的代码风格书写异步代码。\\n\\n### 限制并行执行\\n现在我们知道如何处理异步执行流程，应该很容易规划我们的`Web爬虫应用程序`的第四版的实现，这个版本对并发下载任务的数量施加了限制。我们有几个方案可以用来做到这一点。其中一些方案如下：\\n\\n* 使用先前实现的基于回调的`TaskQueue`类。我们只需要`thunkify`我们的`Generator`函数和其提供的回调函数即可。\\n* 使用基于`Promise`的`TaskQueue`类，并确保每个作为任务的`Generator`函数都被转换成一个返回`Promise`对象的函数。\\n* 使用`async`，`thunkify`我们打算使用的工具函数，此外还需要把我们用到的`Generator`函数转化为基于回调的模式，以便于能够被这个库较好地使用。\\n* 使用基于`co`的生态系统中的库，特别是专门为这种场景的库，如[co-limiter](https://npmjs.org/package/co-limiter)。\\n* 实现基于生产者 - 消费者模型的自定义算法，这与`co-limiter`的内部实现原理相同。\\n\\n为了学习，我们选择最后一个方案，甚至帮助我们可以更好地理解一种经常与协程(也和线程和进程)同步相关的模式。\\n\\n### 生产者 - 消费者模式\\n我们的目标是利用队列来提供固定数量的`workers`，与我们想要设置的并发级别一样多。为了实现这个算法，我们将基于本章前面定义的`TaskQueue`类改写：\\n\\n```javascript\\nclass TaskQueue {\\n  constructor(concurrency) {\\n    this.concurrency = concurrency;\\n    this.running = 0;\\n    this.taskQueue = [];\\n    this.consumerQueue = [];\\n    this.spawnWorkers(concurrency);\\n  }\\n  pushTask(task) {\\n    if (this.consumerQueue.length !== 0) {\\n      this.consumerQueue.shift()(null, task);\\n    } else {\\n      this.taskQueue.push(task);\\n    }\\n  }\\n  spawnWorkers(concurrency) {\\n    const self = this;\\n    for (let i = 0; i < concurrency; i++) {\\n      co(function*() {\\n        while (true) {\\n          const task = yield self.nextTask();\\n          yield task;\\n        }\\n      });\\n    }\\n  }\\n  nextTask() {\\n    return callback => {\\n      if (this.taskQueue.length !== 0) {\\n        return callback(null, this.taskQueue.shift());\\n      }\\n      this.consumerQueue.push(callback);\\n    }\\n  }\\n}\\n```\\n\\n让我们分析这个`TaskQueue`类的新实现。首先是在构造函数中。需要调用一次`this.spawnWorkers()`，因为这是启动`worker`的方法。\\n\\n我们的`worker`很简单，它们只是用`co()`包装的立即执行的`Generator`函数，所以每个`Generator`函数可以并行执行。在内部，每个`worker`正在运行在一个死循环（`while(true){}`）中，一直阻塞（`yield`）到新任务在队列中可用时（`yield self.nextTask()`），一旦可以执行新任务，`yield`这个异步任务直到其完成。您可能想知道我们如何能够限制并行执行，并让下一个任务在队列中处于等待状态。答案是在`nextTask()`方法中。我们来详细地看看在这个方法的原理：\\n\\n```javascript\\nnextTask() {\\n  return callback => {\\n    if (this.taskQueue.length !== 0) {\\n      return callback(null, this.taskQueue.shift());\\n    }\\n    this.consumerQueue.push(callback);\\n  }\\n}\\n```\\n\\n我们看这个函数内部发生了什么，这才是这个模式的核心：\\n\\n1. 这个方法返回一个对于`co`而言是一个合法的`yieldable`的`thunk`。\\n2. 只要`taskQueue`类生成的实例中还有下一个任务，`thunk`的回调函数会被立即调用。回调函数调用时，立马解锁一个`worker`的阻塞状态，`yield`这一个任务。\\n3. 如果队列中没有任务了，回调函数本身会被放入`consumerQueue`中。通过这种做法，我们将一个`worker`置于空闲（`idle`）的模式。一旦我们有一个新的任务来要处理，在`consumerQueue`队列中的回调函数会被调用，立马唤醒我们这一`worker`进行异步处理。\\n\\n现在，为了理解`consumerQueue`队列中的空闲`worker`是如何恢复工作的，我们需要分析`pushTask()`方法。如果当前有回调函数可用的话，`pushTask()`方法将调用`consumerQueue`队列中的第一个回调函数，从而将取消对`worker`的锁定。如果没有可用的回调函数，这意味着所有的`worker`都是工作状态，只需要添加一个新的任务到`taskQueue`任务队列中。\\n\\n在`TaskQueue`类中，`worker`充当消费者的角色，而调用`pushTask()`函数的角色可以被认为是生产者。这个模式向我们展示了一个`Generator`函数实际上可以跟一个线程或进程类似。实际上，生产者 - 消费者之间问题是研究进程间通信和同步时最常见的问题，但正如我们已经提到的那样，它对于进程和线程来说，也是一个常见的例子。\\n\\n### 限制下载任务的并发量\\n既然我们已经使用`Generator`函数和生产者 - 消费者模型实现一个限制并行算法，并且已经在`Web爬虫应用程序`第四版应用它来限制中下载任务的并发数。 首先，我们加载和初始化一个`TaskQueue`对象：\\n\\n```javascript\\nconst TaskQueue = require('./taskQueue');\\nconst downloadQueue = new TaskQueue(2);\\n```\\n\\n然后，修改`spiderLinks()`函数。和之前不限制并发的版本类似，所以这里我们只展示修改的部分，主要是通过调用新版本的`TaskQueue`类生成的实例的`pushTask()`方法来限制并行执行：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  //...\\n  return (callback) => {\\n    //...\\n    function done(err, result) {\\n      //...\\n    }\\n    links.forEach(function(link) {\\n      downloadQueue.pushTask(function*() {\\n        yield spider(link, nesting - 1);\\n        done();\\n      });\\n    });\\n  }\\n}\\n```\\n\\n在每个任务中，我们在下载完成后立即调用`done()`函数，因此我们可以计算下载了多少个链接，然后在完成下载时通知`thunk`的回调函数执行。\\n\\n## 配合Babel使用Async await新语法\\n回调函数、`Promise`和`Generator`函数都是用于处理`JavaScript`和`Node.js`异步问题的方式。正如我们所看到的，`Generator`的真正意义在于它提供了一种方式来暂停一个函数的执行，然后等待前面的任务完成后再继续执行。我们可以使用这样的特性来书写异步代码，并且让开发者用同步阻塞的代码风格来书写异步代码。等到异步操作的结果返回后才恢复当前函数的执行。\\n\\n但`Generator`函数是更多的是用来处理迭代器，然而迭代器在异步代码的使用显得有点笨重。代码可能难以理解，导致代码易读性和可维护性差。\\n\\n但在不远的将来会有一种更加简洁的语法。实际上，这个提议即将引入到`ESMASCript 2017`的规范中，这项规范定义了`async`函数语法。\\n\\n`async`函数规范引入两个关键字(`async`和`await`)到原生的`JavaScript`语言中，改进我们书写异步代码的方式。\\n\\n为了理解这项语法的用法和优势为，我们看一个简单的例子：\\n\\n```javascript\\nconst request = require('request');\\n\\nfunction getPageHtml(url) {\\n  return new Promise(function(resolve, reject) {\\n    request(url, function(error, response, body) {\\n      resolve(body);\\n    });\\n  });\\n}\\nasync function main() {\\n  const html = await getPageHtml('http://google.com');\\n  console.log(html);\\n}\\n\\nmain();\\nconsole.log('Loading...');\\n```\\n\\n在上述代码中，有两个函数：`getPageHtml`和`main`。第一个函数的作用是提取给定`URL`的一个远程网页的`HTML`文档代码。值得注意的是，这个函数返回一个`Promise`对象。\\n\\n重点在于`main`函数，因为在这里使用了`async`和`await`关键字。首先要注意的是函数要以`async`关键字为前缀。意思是这个函数执行的是异步代码并且允许它在函数体内使用`await`关键字。`await`关键字在`getPageHtml`调用之前，告诉`JavaScript`解释器在继续执行下一条指令之前，等待`getPageHtml`返回的`Promise`对象的结果。这样，`main`函数内部哪部分代码是异步的，它会等待异步代码的完成再继续执行后续操作，并且不会阻塞这段程序其余部分的正常执行。实际上，控制台会打印字符串`Loading...`，随后是Google主页的`HTML`代码。\\n\\n是不是这种方法的可读性更好并且更容易理解呢? 不幸地是，这个提议尚未定案，即使通过这个提议，我们需要等下一个版本\\n的`ECMAScript`规范出来并把它集成到`Node.js`后，才能使用这个新语法。 所以我们今天做了什么?只是漫无目的地等待?不是，当然不是！我们已经可以在我们的代码中使用`async await`语法，只要我们使用`Babel`。\\n\\n### 安装与运行Babel\\n`Babel`是一个`JavaScript`编译器(或翻译器)，能够使用语法转换器将高版本的`JavaScript`代码转换成其他`JavaScript`代码。语法转换器允许例如我们书写并使用`ES2015`，`ES2016`，`JSX`和其它的新语法，来翻译成往后兼容的代码，在`JavaScript`运行环境如浏览器或`Node.js`中都可以使用`Babel`。\\n\\n在项目中使用`npm`安装`Babel`，命令如下：\\n\\n```\\nnpm install --save-dev babel-cli\\n```\\n\\n我们还需要安装插件以支持`async await`语法的解释或翻译：\\n\\n```\\nnpm install --save-dev babel-plugin-syntax-async-functions babel-plugin-tranform-async-to-generator\\n```\\n\\n现在假设我们想运行我们之前的例子（称为`index.js`）。我们需要通过以下命令启动：\\n\\n```\\nnode_modules/.bin/babel-node --plugins \\\"syntax-async-functions,transform-async-to-generator\\\" index.js\\n```\\n\\n这样，我们使用支持`async await`的转换器动态地转换源代码。`Node.js`运行的实际是保存在内存中的往后兼容的代码。\\n\\n`Babel`也能被配置为一个代码构建工具，保存翻译或解释后的代码到本地文件系统中，便于我们部署和运行生成的代码。\\n\\n> 关于如何安装和配置Babel，可以到官方网站 https://babeljs.io 查阅相关文档。\\n\\n## 几种方式的比较\\n现在，我们应该对于怎么处理`JavaScript`的异步问题有了一个更好的认识和总结。在下面的表格中总结几大机制的优势和劣势：\\n\\n![](http://oczira72b.bkt.clouddn.com/17-11-7/55293366.jpg)\\n\\n> 值得一提的是，我们选择在本章中仅介绍处理异步控制流程的最受欢迎的解决方案，或者是广泛使用的解决方案，但是例如Fibers（ https://npmjs.org/package/fibers ）和Streamline（ https://npmjs.org/p ackage/streamline ）也是值得一看的。\\n\\n## 总结\\n在本章中，我们分析了一些处理异步控制流的方法，分析了`Promise`、`Generator`函数和即将到来的`async await`语法。\\n\\n我们学习了如何使用这些方法编写更简洁，更具有可读性的异步代码。我们讨论了这些方法的一些最重要的优点和缺点，并认识到即使它们非常有用，也需要一些时间来掌握。这就是这几种方式也没有完全取代在许多情况下仍然非常有用的回调的原因。作为一名开发人员，应该按照实际情况分析决定使用哪种解决方案。如果您正在构建执行异步操作的公共库，则应该提供易于使用的`API`，即使对于只想使用回调的开发人员也是如此。\\n\\n在下一章中，我们将探讨另一个与异步代码执行相关的机制，这也是整个`Node.js`生态系统中的另一个基本构建块：`streams`。\",\n        \"_id\": \"5a20d798b564820d22f6910a\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-12-01T04:16:24.262Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 5,\n    \"viewed\": 50,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:17:06.250] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/art/getArticleDetail?id=5a0e8b7949b148371be1f96e
request client ip:  ::1
request query:  {"id":"5a0e8b7949b148371be1f96e"}
response time: 6
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-12-01T04:16:24.253Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"# Asynchronous Control Flow Patterns with ES2015 and Beyond\\n在上一章中，我们学习了如何使用回调处理异步代码，以及如何解决如回调地狱代码等异步问题。回调是`JavaScript`和`Node.js`中的异步编程的基础，但是现在，其他替代方案已经出现。这些替代方案更复杂，以便能够以更方便的方式处理异步代码。\\n\\n在本章中，我们将探讨一些代表性的替代方案，`Promise`和`Generator`。以及`async await`，这是一种创新的语法，可在高版本的`JavaScript`中提供，其也作为`ECMAScript 2017`发行版的一部分。\\n\\n我们将看到这些替代方案如何简化处理异步控制流的方式。最后，我们将比较所有这些方法，以了解所有这些方法的所有优点和缺点，并能够明智地选择最适合我们下一个`Node.js`项目要求的方法。\\n\\n## Promise\\n我们在前面的章节中提到，`CPS风格`不是编写异步代码的唯一方法。事实上，`JavaScript`生态系统为传统的回调模式提供了有趣的替代方案。最着名的选择之一是`Promise`，特别是现在它是`ECMAScript 2015`的一部分，并且现在可以在`Node.js`中可用。\\n\\n### 什么是Promise？\\n`Promise`是一种抽象的对象，我们通常允许函数返回一个名为`Promise`的对象，它表示异步操作的最终结果。通常情况下，我们说当异步操作尚未完成时，我们说`Promise`对象处于`pending`状态，当操作成功完成时，我们说`Promise`对象处于`resolve`状态，当操作错误终止时，我们说`Promise`对象处于`reject`状态。一旦`Promise`处于`resolve`或`reject`，我们认为当前异步操作结束。\\n\\n为了接收到异步操作的正确结果或错误捕获，我们可以使用`Promise`的`then`方法：\\n\\n```javascript\\npromise.then([onFulfilled], [onRejected])\\n```\\n\\n在前面的代码中，`onFulfilled()`是一个函数，最终会收到`Promise`的正确结果，而`onRejected()`是另一个函数，它将接收产生异常的原因（如果有的话）。两个参数都是可选的。\\n\\n要了解`Promise`如何转换我们的代码，让我们考虑以下几点：\\n\\n```javascript\\nasyncOperation(arg, (err, result) => {\\n  if (err) {\\n    // 错误处理\\n  }\\n  // 正常结果处理\\n});\\n```\\n\\n`Promise`允许我们将这个典型的`CPS`代码转换成更好的结构化和更优雅的代码，如下所示：\\n\\n```javascript\\nasyncOperation(arg)\\n  .then(result => {\\n    // 错误处理\\n  }, err => {\\n    // 正常结果处理\\n  });\\n```\\n\\n`then()`方法的一个关键特征是它同步地返回另一个`Promise`对象。如果`onFulfilled()`或`onRejected()`函数中的任何一个函数返回`x`，则`then()`方法返回的`Promise`对象将如下所示：\\n\\n* 如果`x`是一个值，则这个`Promise`对象会正确处理(`resolve`)`x`\\n* 如果`x`是一个`Promise`对象或`thenable`，则会正确处理(`resolve`)`x`\\n* 如果`x`是一个异常，则会捕获异常(`reject`)`x`\\n\\n> 注：thenable是一个具有then方法的类似于Promise的对象(Promise-like)。\\n\\n这个特点使我们能够链式构建`Promise`，允许轻松排列组合我们的异步操作。另外，如果我们没有指定一个`onFulfilled()`或`onRejected()`处理程序，则正确结果或异常捕获将自动转发到`Promise`链的下一个`Promise`。例如，这允许我们在整个链中自动传播错误，直到被`onRejected()`处理程序捕获。随着`Promise`链，任务的顺序执行突然变成简单多了：\\n\\n```javascript\\nasyncOperation(arg)\\n  .then(result1 => {\\n    // 返回另一个Promise\\n    return asyncOperation(arg2);\\n  })\\n  .then(result2 => {\\n    // 返回一个值\\n    return 'done';\\n  })\\n  .then(undefined, err => {\\n    // 捕获Promise链中的异常\\n  });\\n```\\n\\n下图展示了链式`Promise`如何工作：\\n\\n![](http://oczira72b.bkt.clouddn.com/17-10-31/46370382.jpg)\\n\\n`Promise`的另一个重要特性是`onFulfilled()`和`onRejected()`函数是异步调用的，如同上述的例子，在最后那个`then`函数`resolve`一个同步的`Promise`，它也是同步的。这种模式避免了`Zalgo`（参见`Chapter2-Node.js Essential Patterns`），使我们的异步代码更加一致和稳健。\\n\\n如果在`onFulfilled()`或`onRejected()`处理程序中抛出异常（使用`throw`语句），则`then()`方法返回的`Promise`将被自动地`reject`，抛出异常作为`reject`的原因。这相对于`CPS`来说是一个巨大的优势，因为它意味着有了`Promise`，异常将在整个链中自动传播，并且`throw`语句终于可以使用。\\n\\n在以前，许多不同的库实现了`Promise`，大多数时候它们之间不兼容，这意味着不可能在使用不同`Promise`库的`thenable`链式传播错误。\\n\\n`JavaScript`社区非常努力地解决了这个限制，这些努力导致了`Promises / A +`规范的创建。该规范详细描述了`then`方法的行为，提供了一个可互兼容的基础，这使得来自不同库的`Promise`对象能够彼此兼容，开箱即用。\\n\\n有关`Promises / A +`规范的详细说明，可以参考[Promises / A + 官方网站](https://promisesaplus.com)。\\n\\n### Promise / A + 的实施\\n在`JavaScript`中以及`Node.js`中，有几个实现`Promises / A +`规范的库。以下是最受欢迎的：\\n\\n* [Bluebird](https://npmjs.org/package/bluebird)\\n* [Q](https://npmjs.org/package/q)\\n* [RSVP](https://npmjs.org/package/rsvp)\\n* [Vow](https://npmjs.org/package/vow)\\n* [When.js](https://npmjs.org/package/when)\\n* ES2015 promises\\n\\n真正区别他们的是在`Promises / A +`标准之上提供的额外功能。正如我们上述所说的那样，该标准定义了`then()`方法和`Promise`解析过程的行为，但它没有指定其他功能，例如，如何从基于回调的异步函数创建`Promise`。\\n\\n在我们的示例中，我们将使用由`ES2015`的`Promise`，因为`Promise`对象自`Node.js 4`后即可使用，而不需要任何库来实现。\\n\\n作为参考，以下是`ES2015`的`Promise`提供的API：\\n\\n`constructor`(`new Promise（function（resolve, reject）{}）`)：创建了一个新的`Promise`，它基于作为传递两个类型为函数的参数来决定`resolve`或`reject`。构造函数的参数解释如下：\\n\\n* `resolve(obj)` ：`resolve`一个`Promise`，并带上一个参数`obj`，如果`obj`是一个值，这个值就是传递的异步操作成功的结果。如果`obj`是一个`Promise`或一个`thenable`，则会进行正确处理。\\n* `reject(err)`：`reject`一个`Promise`，并带上一个参数`err`。它是`Error`对象的一个实例。\\n\\n#### Promise对象的静态方法\\n* `Promise.resolve(obj)`： 将会创建一个`resolve`的`Promise`实例\\n* `Promise.reject(err)`： 将会创建一个`reject`的`Promise`实例\\n* `Promise.all(iterable)`：返回一个新的`Promise`实例，并且在`iterable`中所\\n有`Promise`状态为`reject`时, 返回的`Promise`实例的状态会被置为`reject`，如果`iterable`中至少有一个`Promise`状态为`reject`时, 返回的`Promise`实例状态也会被置为`reject`，并且`reject`的原因是第一个被`reject`的`Promise`对象的`reject`原因。\\n* `Promise.race(iterable)`：返回一个`Promise`实例，当`iterable`中任何一个`Promise`被`resolve`或被`reject`时， 返回的`Promise`实例以同样的原因`resolve`或`reject`。\\n\\n#### Promise实例方法\\n* `Promise.then(onFulfilled, onRejected)`：这是`Promise`的基本方法。它的行为与我们之前描述的`Promises / A +`标准兼容。\\n* `Promise.catch(onRejected)`：这只是`Promise.then(undefined，onRejected)`的语法糖。\\n\\n> 值得一提的是，一些Promise实现提供了另一种机制来创建新的Promise，称为deferreds。我们不会在这里描述，因为它不是ES2015标准的一部分，但是如果您想了解更多信息，可以阅读Q文档 (https://github.com/kriskowal/q#using-deferreds) 或When.js文档 (https://github.com/cujojs/when/wiki/Deferred) 。\\n\\n### Promisifying一个Node.js回调风格的函数\\n在`JavaScript`中，并不是所有的异步函数和库都支持开箱即用的`Promise`。大多数情况下，我们必须将一个典型的基于回调的函数转换成一个返回`Promise`的函数，这个过程也被称为`promisification`。\\n\\n幸运的是，`Node.js`中使用的回调约定允许我们创建一个可重用的函数，我们通过使用`Promise`对象的构造函数来简化任何`Node.js`风格的`API`。让我们创建一个名为`promisify()`的新函数，并将其包含到`utilities.js`模块中（以便稍后在我们的`Web爬虫应用程序`中使用它）：\\n\\n```javascript\\nmodule.exports.promisify = function(callbackBasedApi) {\\n  return function promisified() {\\n    const args = [].slice.call(arguments);\\n    return new Promise((resolve, reject) => {\\n      args.push((err, result) => {\\n        if (err) {\\n          return reject(err);\\n        }\\n        if (arguments.length <= 2) {\\n          resolve(result);\\n        } else {\\n          resolve([].slice.call(arguments, 1));\\n        }\\n      });\\n      callbackBasedApi.apply(null, args);\\n    });\\n  }\\n};\\n```\\n\\n前面的函数返回另一个名为`promisified()`的函数，它表示输入中给出的`callbackBasedApi`的`promisified`版本。以下展示它是如何工作的：\\n\\n1. `promisified()`函数使用`Promise`构造函数创建一个新的`Promise`对象，并立即将其返回给调用者。\\n2. 在传递给`Promise`构造函数的函数中，我们确保传递给`callbackBasedApi`，这是一个特殊的回调函数。由于我们知道回调总是最后调用的，我们只需将回调函数附加到提供给`promisified()`函数的参数列表里（`args`）。\\n3. 在特殊的回调中，如果我们收到错误，我们立即`reject`这个`Promise`。\\n4. 如果没有收到错误，我们使用一个值或一个数组值来`resolve`这个`Promise`，具体取决于传递给回调的结果数量。\\n5. 最后，我们只需使用我们构建的参数列表调用`callbackBasedApi`。\\n\\n> 大部分的Promise已经提供了一个开箱即用的接口来将一个Node.js风格的API转换成一个返回Promise的API。例如，Q有Q.denodeify()和Q.nbind()，Bluebird有Promise.promisify()，而When.js有node.lift()。\\n\\n### 顺序执行\\n在一些必要的理论之后，我们现在准备将我们的`Web爬虫应用程序`转换为使用`Promise`的形式。让我们直接从版本2开始，直接下载一个Web网页的链接。\\n\\n在`spider.js`模块中，第一步是加载我们的`Promise`实现（我们稍后会使用它）和`Promisifying`我们打算使用的基于回调的函数：\\n\\n```javascript\\nconst utilities = require('./utilities');\\nconst request = utilities.promisify(require('request'));\\nconst mkdirp = utilities.promisify(require('mkdirp'));\\nconst fs = require('fs');\\nconst readFile = utilities.promisify(fs.readFile);\\nconst writeFile = utilities.promisify(fs.writeFile);\\n```\\n\\n现在，我们开始更改我们的`download`函数：\\n\\n```javascript\\nfunction download(url, filename) {\\n  console.log(`Downloading ${url}`);\\n  let body;\\n  return request(url)\\n    .then(response => {\\n      body = response.body;\\n      return mkdirp(path.dirname(filename));\\n    })\\n    .then(() => writeFile(filename, body))\\n    .then(() => {\\n      console.log(`Downloaded and saved: ${url}`);\\n      return body;\\n    });\\n}\\n```\\n\\n这里要注意的到的最重要的是我们也为`readFile()`返回的`Promise`注册\\n一个`onRejected()`函数，用来处理一个网页没有被下载的情况(或文件不存在)。 还有，看我们如何使用`throw`来传递`onRejected()`函数中的错误的。\\n\\n既然我们已经更改我们的`spider()`函数，我们这么修改它的调用方式：\\n\\n```javascript\\nspider(process.argv[2], 1)\\n  .then(() => console.log('Download complete'))\\n  .catch(err => console.log(err));\\n```\\n\\n注意我们是如何第一次使用`Promise`的语法糖`catch`来处理源自`spider()`函数的任何错误情况。如果我们再看看迄今为止我们所写的所有代码，那么我们会惊喜的发现，我们没有包含任何错误传播逻辑，因为我们在使用回调函数时会被迫做这样的事情。这显然是一个巨大的优势，因为它极大地减少了我们代码中的样板文件以及丢失任何异步错误的机会。\\n\\n现在，完成我们唯一缺失的`Web爬虫应用程序`的第二版的`spiderLinks()`函数，我们将在稍后实现它。\\n\\n### 顺序迭代\\n到目前为止，`Web爬虫应用程序`代码库主要是对`Promise`是什么以及如何使用的概述，展示了使用`Promise`实现顺序执行流程的简单性和优雅性。但是，我们现在考虑的代码只涉及到一组已知的异步操作的执行。所以，完成我们对顺序执行流程的探索的缺失部分是看我们如何使用`Promise`来实现迭代。同样，网络蜘蛛第二版的`spiderLinks()`函数也是一个很好的例子。\\n\\n让我们添加缺少的这一块：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  let promise = Promise.resolve();\\n  if (nesting === 0) {\\n    return promise;\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  links.forEach(link => {\\n    promise = promise.then(() => spider(link, nesting - 1));\\n  });\\n  return promise;\\n}\\n```\\n\\n为了异步迭代一个网页的全部链接，我们必须动态创建一个`Promise`的迭代链。\\n\\n1. 首先，我们定义一个空的`Promise`，`resolve`为`undefined`。这个`Promise`只是用来作为`Promise`的迭代链的起始点。 \\n2. 然后，我们通过在循环中调用链中前一个`Promise`的`then()`方法获得的新的`Promise`来更新`Promise`变量。这就是我们使用`Promise`的异步迭代模式。\\n\\n这样，循环的结束，`promise`变量会包含循环中最后一个`then()`返回的`Promise`对象，所以它只有当`Promise`的迭代链中全部`Promise`对象被`resolve`后才能被`resolve`。\\n\\n> 注：在最后调用了这个then方法来resolve这个Promise对象\\n\\n通过这个，我们已使用`Promise`对象重写了我们的`Web爬虫应用程序`。我们现在应该可以运行它了。\\n\\n### 顺序迭代模式\\n为了总结这个顺序执行的部分，让我们提取一个模式来依次遍历一组`Promise`：\\n\\n```javascript\\nlet tasks = [ /* ... */ ]\\nlet promise = Promise.resolve();\\ntasks.forEach(task => {\\n  promise = promise.then(() => {\\n    return task();\\n  });\\n});\\npromise.then(() => {\\n  // 所有任务都完成\\n});\\n```\\n\\n使用`reduce()`方法来替代`forEach()`方法，允许我们写出更为简洁的代码：\\n\\n```javascript\\nlet tasks = [ /* ... */ ]\\nlet promise = tasks.reduce((prev, task) => {\\n  return prev.then(() => {\\n    return task();\\n  });\\n}, Promise.resolve());\\n\\npromise.then(() => {\\n  //All tasks completed\\n});\\n```\\n\\n与往常一样，通过对这种模式的简单调整，我们可以将所有任务的结果收集到一个数组中，我们可以实现一个`mapping`算法，或者构建一个`filter`等等。\\n\\n> 上述这个模式使用循环动态地建立一个链式的Promise。\\n\\n### 并行执行\\n另一个适合用`Promise`的执行流程是并行执行流程。实际上，我们需要做的就是使用内置的`Promise.all()`。这个方法创造了另一个`Promise`对象，只有在输入中的所有`Promise`都`resolve`时才能`resolve`。这是一个并行执行，因为在其参数`Promise`对象的之间没有执行顺序可言。\\n\\n为了演示这一点，我们来看我们的`Web爬虫应用程序`的第三版，它将页面中的所有链接并行下载。让我们再次使用`Promise`更新`spiderLinks()`函数来实现并行流程：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return Promise.resolve();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  const promises = links.map(link => spider(link, nesting - 1));\\n  return Promise.all(promises);\\n}\\n```\\n\\n这里的模式在`elements.map()`迭代中产生一个数组，存放所有异步任务，之后便于同时启动`spider()`任务。这一次，在循环中，我们不等待以前的下载完成，然后开始一个新的下载任务：所有的下载任务在一个循环中一个接一个地开始。之后，我们利用`Promise.all()`方法，它返回一个新的`Promise`对象，当数组中的所有`Promise`对象都被`resolve`时，这个`Promise`对象将被`resolve`。换句话说，所有的下载任务完成，这正是我们想要的。\\n\\n### 限制并行执行\\n不幸的是，`ES2015`的`Promise API`并没有提供一种原生的方式来限制并发任务的数量，但是我们总是可以依靠我们所学到的有关用普通`JavaScript`来限制并发。事实上，我们在`TaskQueue`类中实现的模式可以很容易地被调整来支持返回承诺的任务。这很容易通过修改`next()`方法来完成：\\n\\n```javascript\\nclass TaskQueue {\\n  constructor(concurrency) {\\n    this.concurrency = concurrency;\\n    this.running = 0;\\n    this.queue = [];\\n  }\\n\\n  pushTask(task) {\\n    this.queue.push(task);\\n    this.next();\\n  }\\n\\n  next() {\\n    while (this.running < this.concurrency && this.queue.length) {\\n      const task = this.queue.shift();\\n      task().then(() => {\\n        this.running--;\\n        this.next();\\n      });\\n      this.running++;\\n    }\\n  }\\n}\\n```\\n\\n不同于使用一个回调函数来处理任务，我们简单地调用`Promise`的`then()`。\\n\\n让我们回到`spider.js`模块，并修改它以支持我们的新版本的`TaskQueue`类。首先，我们确保定义一个`TaskQueue`的新实例：\\n\\n```javascript\\nconst TaskQueue = require('./taskQueue');\\nconst downloadQueue = new TaskQueue(2);\\n```\\n\\n然后，是我们的`spiderLinks()`函数。这里的修改也是很简单：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return Promise.resolve();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  // 我们需要如下代码，用于创建Promise对象\\n  // 如果没有下列代码，当任务数量为0时，将永远不会resolve\\n  if (links.length === 0) {\\n    return Promise.resolve();\\n  }\\n  return new Promise((resolve, reject) => {\\n    let completed = 0;\\n    let errored = false;\\n    links.forEach(link => {\\n      let task = () => {\\n        return spider(link, nesting - 1)\\n          .then(() => {\\n            if (++completed === links.length) {\\n              resolve();\\n            }\\n          })\\n          .catch(() => {\\n            if (!errored) {\\n              errored = true;\\n              reject();\\n            }\\n          });\\n      };\\n      downloadQueue.pushTask(task);\\n    });\\n  });\\n}\\n```\\n\\n在上述代码中有几点值得我们注意的：\\n\\n* 首先，我们需要返回使用`Promise`构造函数创建的新的`Promise`对象。正如我们将看到的，这使我们能够在队列中的所有任务完成时手动`resolve`我们的`Promise`对象。\\n* 然后，我们应该看看我们如何定义任务。我们所做的是将一个`onFulfilled()`回调函数的调用添加到由`spider()`返回的`Promise`对象中，所以我们可以计算完成的下载任务的数量。当完成的下载量与当前页面中链接的数量相同时，我们知道任务已经处理完毕，所以我们可以调用外部`Promise`的`resolve()`函数。\\n\\n> Promises / A +规范规定，then()方法的onFulfilled()和onRejected()回调函数只能调用一次（仅调用onFulfilled()和onRejected()）。Promise接口的实现确保即使我们多次手动调用resolve或reject，Promise也仅可以被resolve或reject一次。\\n\\n现在，使用`Promise`的`Web爬虫应用程序`的第4版应该已经准备好了。我们可能再次注意到下载任务如何并行运行，并发数量限制为2。\\n\\n### 在公有API中暴露回调函数和Promise\\n正如我们在前面所学到的，`Promise`可以被用作回调函数的一个很好的替代品。它们使我们的代码更具可读性和易于理解。虽然`Promise`带来了许多优点，但也要求开发人员理解许多不易于理解的概念，以便正确和熟练地使用。由于这个原因和其他原因，在某些情况下，比起`Promise`来说，很多开发者更偏向于回调函数。\\n\\n现在让我们想象一下，我们想要构建一个执行异步操作的公共库。我们需要做什么？我们是创建了一个基于回调函数的`API`还是一个面向`Promise`的`API`？还是两者均有？\\n\\n这是许多知名的库所面临的问题，至少有两种方法值得一提，使我们能够提供一个多功能的`API`。\\n\\n像`request`，`redis`和`mysql`这样的库所使用的第一种方法是提供一个简单的基于回调函数的`API`，如果需要，开发人员可以选择公开函数。其中一些库提供工具函数来`Promise`化异步回调，但开发人员仍然需要以某种方式将暴露的`API`转换为能够使用`Promise`对象。\\n\\n第二种方法更透明。它还提供了一个面向回调的`API`，但它使回调参数可选。每当回调作为参数传递时，函数将正常运行，在完成时或失败时执行回调。当回调未被传递时，函数将立即返回一个`Promise`对象。这种方法有效地结合了回调函数和`Promise`，使得开发者可以在调用时选择采用什么接口，而不需要提前进行`Promise`化。许多库，如`mongoose`和`sequelize`，都支持这种方法。\\n\\n我们来看一个简单的例子。假设我们要实现一个异步执行除法的模块：\\n\\n```javascript\\nmodule.exports = function asyncDivision(dividend, divisor, cb) {\\n  return new Promise((resolve, reject) => { // [1]\\n    process.nextTick(() => {\\n      const result = dividend / divisor;\\n      if (isNaN(result) || !Number.isFinite(result)) {\\n        const error = new Error('Invalid operands');\\n        if (cb) {\\n          cb(error); // [2]\\n        }\\n        return reject(error);\\n      }\\n      if (cb) {\\n        cb(null, result); // [3]\\n      }\\n      resolve(result);\\n    });\\n  });\\n};\\n```\\n\\n该模块的代码非常简单，但是有一些值得强调的细节：\\n\\n* 首先，返回使用`Promise`的构造函数创建的新承诺。我们在构造函数参数函数内定义全部逻辑。\\n* 在发生错误的情况下，我们`reject`这个`Promise`，但如果回调函数在被调用时作为参数传递，我们也执行回调来进行错误传播。\\n* 在计算结果之后，我们`resolve`了这个`Promise`，但是如果有回调函数，我们也会将结果传播给回调函数。\\n\\n我们现在看如何用回调函数和`Promise`来使用这个模块：\\n\\n```javascript\\n// 回调函数的方式\\nasyncDivision(10, 2, (error, result) => {\\n  if (error) {\\n    return console.error(error);\\n  }\\n  console.log(result);\\n});\\n\\n// Promise化的调用方式\\nasyncDivision(22, 11)\\n  .then(result => console.log(result))\\n  .catch(error => console.error(error));\\n```\\n\\n应该很清楚的是，即将开始使用类似于上述的新模块的开发人员将很容易地选择最适合自己需求的风格，而无需在希望利用`Promise`时引入外部`promisification`功能。\\n\\n## Generators\\n`ES2015`规范引入了另外一种机制，除了其他新功能外，还可以用来简化`Node.js`应用程序的异步控制流程。我们正在谈论`Generator`，也被称为`semi-coroutines`。它们是子程序的一般化，可以有不同的入口点。在一个正常的函数中，实际上我们只能有一个入口点，这个入口点对应着函数本身的调用。`Generator`与一般函数类似，但是可以暂停（使用`yield`语句），然后在稍后继续执行。在实现迭代器时，`Generator`特别有用，因为我们已经讨论了如何使用迭代器来实现重要的异步控制流模式，如顺序执行和限制并行执行。\\n\\n### Generators基础\\n在我们探索使用`Generator`来实现异步控制流程之前，学习一些基本概念是很重要的。我们从语法开始吧。可以通过在函数关键字之后附加`*`（星号）运算符来声明`Generator`函数：\\n\\n```javascript\\nfunction* makeGenerator() {\\n  // body\\n}\\n```\\n\\n在`makeGenerator()`函数内部，我们可以使用关键字`yield`暂停执行并返回给调用者传递给它的值：\\n\\n```javascript\\nfunction* makeGenerator() {\\n  yield 'Hello World';\\n  console.log('Re-entered');\\n}\\n```\\n\\n在前面的代码中，`Generator`通过`yield`一个字符串`Hello World`暂停当前函数的执行。当`Generator`恢复时，执行将从下列语句开始：\\n\\n```javascript\\nconsole.log('Re-entered');\\n```\\n\\n`makeGenerator()`函数本质上是一个工厂，它在被调用时返回一个新的`Generator`对象：\\n\\n```javascript\\nconst gen = makeGenerator();\\n```\\n\\n生成器对象的最重要的方法是`next()`，它用于启动/恢复`Generator`的执行，并返回如下形式的对象：\\n\\n```\\n{\\n  value: <yielded value>\\n  done: <true if the execution reached the end>\\n}\\n```\\n\\n这个对象包含`Generator` `yield`的值和一个指示`Generator`是否已经完成执行的符号。\\n\\n### 一个简单的例子\\n为了演示`Generator`，我们来创建一个名为`fruitGenerator.js`的新模块：\\n\\n```javascript\\nfunction* fruitGenerator() {\\n  yield 'apple';\\n  yield 'orange';\\n  return 'watermelon';\\n}\\nconst newFruitGenerator = fruitGenerator();\\nconsole.log(newFruitGenerator.next()); // [1]\\nconsole.log(newFruitGenerator.next()); // [2]\\nconsole.log(newFruitGenerator.next()); // [3]\\n```\\n\\n前面的代码将打印下面的输出：\\n\\n```\\n{ value: 'apple', done: false }\\n{ value: 'orange', done: false }\\n{ value: 'watermelon', done: true }\\n```\\n\\n我们可以这么解释上述现象：\\n\\n* 第一次调用`newFruitGenerator.next()`时，`Generator`函数开始执行，直到达到第一个`yield`语句为止，该命令暂停`Generator`函数执行，并将值`apple`返回给调用者。\\n* 在第二次调用`newFruitGenerator.next()`时，`Generator`函数恢复执行，从第二个`yield`语句开始，这又使得执行暂停，同时将`orange`返回给调用者。\\n* `newFruitGenerator.next()`的最后一次调用导致`Generator`函数的执行从其最后的`yield`恢复，一个返回语句，它终止`Generator`函数，返回`watermelon`，并将结果对象中的`done`属性设置为`true`。\\n\\n### Generators作为迭代器\\n为了更好地理解为什么`Generator`函数对实现迭代器非常有用，我们来构建一个例子。在我们将调用`iteratorGenerator.js`的新模块中，我们编写下面的代码：\\n\\n```javascript\\nfunction* iteratorGenerator(arr) {\\n  for (let i = 0; i < arr.length; i++) {\\n    yield arr[i];\\n  }\\n}\\nconst iterator = iteratorGenerator(['apple', 'orange', 'watermelon']);\\nlet currentItem = iterator.next();\\nwhile (!currentItem.done) {\\n  console.log(currentItem.value);\\n  currentItem = iterator.next();\\n}\\n```\\n\\n此代码应按如下所示打印数组中的元素：\\n\\n```\\napple\\norange\\nwatermelon\\n```\\n\\n在这个例子中，每次我们调用`iterator.next()`时，我们都会恢复`Generator`函数的`for`循环，通过`yield`数组中的下一个项来运行另一个循环。这演示了如何在函数调用过程中维护`Generator`的状态。当继续执行时，循环和所有变量的值与`Generator`函数执行暂停时的状态完全相同。\\n\\n### 传值给Generators\\n现在我们继续研究`Generator`的基本功能，首先学习如何将值传递回`Generator`函数。这其实很简单，我们需要做的只是为`next()`方法提供一个参数，并且该值将作为`Generator`函数内的`yield`语句的返回值提供。\\n\\n为了展示这一点，我们来创建一个新的简单模块：\\n\\n```javascript\\nfunction* twoWayGenerator() {\\n  const what = yield null;\\n  console.log('Hello ' + what);\\n}\\nconst twoWay = twoWayGenerator();\\ntwoWay.next();\\ntwoWay.next('world');\\n```\\n\\n当执行时，前面的代码会输出`Hello world`。我们做如下的解释：\\n\\n* 第一次调用`next()`方法时，`Generator`函数到达第一个`yield`语句，然后暂停。\\n* 当`next('world')`被调用时，`Generator`函数从上次停止的位置，也就是上次的`yield`语句点恢复，但是这次我们有一个值传递到`Generator`函数。这个值将被赋值到`what`变量。生成器然后执行`console.log()`指令并终止。\\n\\n用类似的方式，我们可以强制`Generator`函数抛出异常。这可以通过使用`Generator`函数的`throw`方法来实现，如下例所示：\\n\\n```javascript\\nconst twoWay = twoWayGenerator();\\ntwoWay.next();\\ntwoWay.throw(new Error());\\n```\\n\\n在这个最后这段代码，`twoWayGenerator()`函数将在`yield`函数返回的时候抛出异常。这就好像从`Generator`函数内部抛出了一个异常一样，这意味着它可以像使用`try ... catch`块一样进行捕获和处理异常。\\n\\n### Generator实现异步控制流\\n你一定想知道`Generator`函数如何帮助我们处理异步操作。我们可以通过创建一个接受`Generator`函数作为参数的特殊函数来演示这一点，并允许我们在`Generator`函数内部使用异步代码。这个函数在异步操作完成时要注意恢复`Generator`函数的执行。我们将调用这个函数`asyncFlow()`：\\n\\n```javascript\\nfunction asyncFlow(generatorFunction) {\\n  function callback(err) {\\n    if (err) {\\n      return generator.throw(err);\\n    }\\n    const results = [].slice.call(arguments, 1);\\n    generator.next(results.length > 1 ? results : results[0]);\\n  }\\n  const generator = generatorFunction(callback);\\n  generator.next();\\n}\\n```\\n\\n前面的函数取一个`Generator`函数作为输入，然后立即调用：\\n\\n```javascript\\nconst generator = generatorFunction(callback);\\ngenerator.next();\\n```\\n\\n`generatorFunction()`接受一个特殊的回调函数作为参数，当`generator.throw()`如果接收到一个错误，便立即返回。另外，通过将在回调函数中接收的`results`传值回`Generator`函数继续`Generator`函数的执行:\\n\\n```javascript\\nif (err) {\\n  return generator.throw(err);\\n}\\nconst results = [].slice.call(arguments, 1);\\ngenerator.next(results.length > 1 ? results : results[0]);\\n```\\n\\n为了说明这个简单的辅助函数的强大，我们创建一个叫做`clone.js`的新模块，这个模块只是创建它本身的克隆。粘贴我们刚才创建的`asyncFlow()`函数，核心代码如下：\\n\\n```javascript\\nconst fs = require('fs');\\nconst path = require('path');\\nasyncFlow(function*(callback) {\\n  const fileName = path.basename(__filename);\\n  const myself = yield fs.readFile(fileName, 'utf8', callback);\\n  yield fs.writeFile(`clone_of_${filename}`, myself, callback);\\n  console.log('Clone created');\\n});\\n```\\n\\n明显地，有了`asyncFlow()`函数的帮助，我们可以像我们书写同步阻塞函数一样用同步的方式来书写异步代码了。并且这个结果背后的原理显得很清楚。一旦异步操作结束，传递给每个异步函数的回调函数将继续`Generator`函数的执行。没有什么复杂的，但是结果确实很令人意外。\\n\\n这个技术有其他两个变化，一个是`Promise`的使用，另外一个则是`thunks`。\\n\\n> 在基于Generator的控制流中使用的thunk只是一个简单的函数，它除了回调之外，部分地应用了原始函数的所有参数。返回值是另一个只接受回调作为参数的函数。例如，fs.readFile（）的thunkified版本如下所示：\\n\\n```javascript\\nfunction readFileThunk(filename, options) {\\n  return function(callback) {\\n    fs.readFile(filename, options, callback);\\n  }\\n}\\n```\\n\\n`thunk`和`Promise`都允许我们创建不需要回调的`Generator`函数作为参数传递，例如，使用`thunk`的`asyncFlow()`版本如下：\\n\\n```javascript\\nfunction asyncFlowWithThunks(generatorFunction) {\\n  function callback(err) {\\n    if (err) {\\n      return generator.throw(err);\\n    }\\n    const results = [].slice.call(arguments, 1);\\n    const thunk = generator.next(results.length > 1 ? results : results[0]).value;\\n    thunk && thunk(callback);\\n  }\\n  const generator = generatorFunction();\\n  const thunk = generator.next().value;\\n  thunk && thunk(callback);\\n}\\n```\\n\\n这个技巧是读取`generator.next()`的返回值，返回值中包含`thunk`。下一步是通过注入特殊的回调函数调用`thunk`本身。这允许我们写下面的代码：\\n\\n```javascript\\nasyncFlowWithThunk(function*() {\\n  const fileName = path.basename(__filename);\\n  const myself = yield readFileThunk(__filename, 'utf8');\\n  yield writeFileThunk(`clone_of_${fileName}`, myself);\\n  console.log(\\\"Clone created\\\")\\n});\\n```\\n\\n### 使用co的基于Gernator的控制流\\n你应该已经猜到了，`Node.js`生态系统会借助`Generator`函数来提供一些处理异步控制流的解决方案，例如，[suspend](https://npm/js.org/package/suspend)是其中一个最老的支持`Promise`、`thunks`和`Node.js`风格回调函数和正常风格的回调函数的 库。还有，大部分我们之前分析的`Promise`库都提供工具函数使得`Generator`和`Promise`可以一起使用。\\n\\n我们选择[co](https://npmjs.org/package/co)作为本章节的例子。它支持很多类型的`yieldables`，其中一些是：\\n\\n* `Thunks`\\n* `Promises`\\n* `Arrays`(并行执行)\\n* `Objects`(并行执行)\\n* `Generators`(委托)\\n* `Generator`函数(委托)\\n\\n还有很多框架或库是基于`co`生态系统的，包括以下一些：\\n\\n* `Web框架`，最流行的是[koa](https://npmjs.org/package/koa)\\n* 实现特定控制流模式的库\\n* 包装流行的`API`兼容`co`的库\\n\\n我们使用`co`重新实现我们的`Generator`版本的`Web爬虫应用程序`。\\n\\n为了将`Node.js`风格的函数转换成`thunks`，我们将会使用一个叫做[thunkify](https://npmjs.org/package/thunkify)的库。\\n\\n### 顺序执行\\n让我们通过修改`Web爬虫应用程序`的版本2开始我们对`Generator`函数和`co`的实际探索。我们要做的第一件事就是加载我们的依赖包，并生成我们要使用的函数的`thunkified`版本。这些将在`spider.js`模块的最开始进行：\\n\\n```javascript\\nconst thunkify = require('thunkify');\\nconst co = require('co');\\nconst request = thunkify(require('request'));\\nconst fs = require('fs');\\nconst mkdirp = thunkify(require('mkdirp'));\\nconst readFile = thunkify(fs.readFile);\\nconst writeFile = thunkify(fs.writeFile);\\nconst nextTick = thunkify(process.nextTick);\\n```\\n\\n看上述代码，我们可以注意到与本章前面`promisify`化的`API`的代码的一些相似之处。在这一点上，有意思的是，如果我们使用我们的`promisified`版本的函数来代替`thunkified`的版本，代码将保持完全一样，这要归功于`co`支持`thunk`和`Promise`对象作为`yieldable`对象。事实上，如果我们想，甚至可以在同一个应用程序中使用`thunk`和`Promise`，即使在同一个`Generator`函数中。就灵活性而言，这是一个巨大的优势，因为它使我们能够使用基于`Generator`函数的控制流来解决我们应用程序中的问题。\\n\\n好的，现在让我们开始将`download()`函数转换为一个`Generator`函数：\\n\\n```javascript\\nfunction* download(url, filename) {\\n  console.log(`Downloading ${url}`);\\n  const response = yield request(url);\\n  const body = response[1];\\n  yield mkdirp(path.dirname(filename));\\n  yield writeFile(filename, body);\\n  console.log(`Downloaded and saved ${url}`);\\n  return body;\\n}\\n```\\n\\n通过使用`Generator`和`co`，我们的`download()`函数变得简单多了。当我们需要做异步操作的时候，我们使用异步的`Generator`函数作为`thunk`来把之前的内容转化到`Generator`函数，并使用`yield`子句。\\n\\n然后我们开始实现我们的`spider()`函数：\\n\\n```javascript\\nfunction* spider(url, nesting) {\\n  cost filename = utilities.urlToFilename(url);\\n  let body;\\n  try {\\n    body = yield readFile(filename, 'utf8');\\n  } catch (err) {\\n    if (err.code !== 'ENOENT') {\\n      throw err;\\n    }\\n    body = yield download(url, filename);\\n  }\\n  yield spiderLinks(url, body, nesting);\\n}\\n```\\n\\n从上述代码中一个有趣的细节是我们可以使用`try...catch`语句块来处理异常。我们还可以使用`throw`来传播异常。另外一个细节是我们`yield`我们的`download()`函数，而这个函数既不是一个`thunk`，也不是一个`promisified`函数，只是另外的一个`Generator`函数。这也毫无问题，由于`co`也支持其他`Generators`作为`yieldables`。\\n\\n最后转换`spiderLinks()`，在这个函数中，我们递归下载一个网页的链接。在这个函数中使用`Generators`，显得简单多了：\\n\\n```javascript\\nfunction* spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return nextTick();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  for (let i = 0; i < links.length; i++) {\\n    yield spider(links[i], nesting - 1);\\n  }\\n}\\n```\\n\\n看上述代码。虽然顺序迭代没有什么模式可以展示。`Generator`和`co`辅助我们做了很多，方便了我们可以使用同步方式开书写异步代码。\\n\\n看最重要的部分，程序的入口：\\n\\n```javascript\\nco(function*() {\\n  try {\\n    yield spider(process.argv[2], 1);\\n    console.log(`Download complete`);\\n  } catch (err) {\\n    console.log(err);\\n  }\\n});\\n```\\n\\n这是唯一一处需要调用`co(...)`来封装的一个`Generator`。实际上，一旦我们这么做，`co`会自动封装我们传递给`yield`语句的任何`Generator`函数，并且这个过程是递归的，所以程序的剩余部分与我们是否使用`co`是完全无关的，虽然是被`co`封装在里面。\\n\\n现在应该可以运行使用`Generator`函数改写的`Web爬虫应用程序`了。\\n\\n### 并行执行\\n不幸的是，虽然`Generator`很方便地进行顺序执行，但是不能直接用来并行化执行一组任务，至少不能仅仅使用`yield`和`Generator`。之前，在种情况下我们使用的模式只是简单地依赖于一个基于回调或者`Promise`的函数，但使用了`Generator`函数后，一切会显得更简单。\\n\\n幸运的是，如果不限制并发数的并行执行，`co`已经可以通过`yield`一个`Promise`对象、`thunk`、`Generator`函数，甚至包含`Generator`函数的数组来实现。\\n\\n考虑到这一点，我们的`Web爬虫应用程序`第三版可以通过重写`spiderLinks()`函数来做如下改动：\\n\\n```javascript\\nfunction* spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return nextTick();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  const tasks = links.map(link => spider(link, nesting - 1));\\n  yield tasks;\\n}\\n```\\n\\n但是上述函数所做的只是拿到所有的任务，这些任务本质上都是通过`Generator`函数来实现异步的，如果在`co`的`thunk`内对一个包含`Generator`函数的数组使用`yield`，这些任务都会并行执行。外层的`Generator`函数会等到`yield`子句的所有异步任务并行执行后再继续执行。\\n\\n接下来我们看怎么用一个基于回调函数的方式来解决相同的并行流。我们用这种方式重写`spiderLinks()`函数：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return nextTick();\\n  }\\n  // 返回一个thunk\\n  return callback => {\\n    let completed = 0,\\n      hasErrors = false;\\n    const links = utilities.getPageLinks(currentUrl, body);\\n    if (links.length === 0) {\\n      return process.nextTick(callback);\\n    }\\n\\n    function done(err, result) {\\n      if (err && !hasErrors) {\\n        hasErrors = true;\\n        return callback(err);\\n      }\\n      if (++completed === links.length && !hasErrors) {\\n        callback();\\n      }\\n    }\\n    for (let i = 0; i < links.length; i++) {\\n      co(spider(links[i], nesting - 1)).then(done);\\n    }\\n  }\\n}\\n```\\n\\n我们使用`co`并行运行`spider()`函数，调用`Generator`函数返回了一个`Promise`对象。这样，等待`Promise`完成后调用`done()`函数。通常，基于`Generator`控制流的库都有这一功能，因此如果需要，你总是可以将一个`Generator`转换成一个基于回调或基于`Promise`的函数。\\n\\n为了并行开启多个下载任务，我们只要重用在前面定义的基于回调的并行执行的模式。我们应该也注意到我们将`spiderLinks()`转换成一个`thunk`(而不再是一个`Generator`函数)。这使得当全部并行任务完成时，我们有一个回调函数可以调用。\\n\\n> 上面讲到的是将一个Generator函数转换为一个thunk的模式，使之能够支持其他的基于回调或基于Promise的控制流算法，并可以通过同步阻塞的代码风格书写异步代码。\\n\\n### 限制并行执行\\n现在我们知道如何处理异步执行流程，应该很容易规划我们的`Web爬虫应用程序`的第四版的实现，这个版本对并发下载任务的数量施加了限制。我们有几个方案可以用来做到这一点。其中一些方案如下：\\n\\n* 使用先前实现的基于回调的`TaskQueue`类。我们只需要`thunkify`我们的`Generator`函数和其提供的回调函数即可。\\n* 使用基于`Promise`的`TaskQueue`类，并确保每个作为任务的`Generator`函数都被转换成一个返回`Promise`对象的函数。\\n* 使用`async`，`thunkify`我们打算使用的工具函数，此外还需要把我们用到的`Generator`函数转化为基于回调的模式，以便于能够被这个库较好地使用。\\n* 使用基于`co`的生态系统中的库，特别是专门为这种场景的库，如[co-limiter](https://npmjs.org/package/co-limiter)。\\n* 实现基于生产者 - 消费者模型的自定义算法，这与`co-limiter`的内部实现原理相同。\\n\\n为了学习，我们选择最后一个方案，甚至帮助我们可以更好地理解一种经常与协程(也和线程和进程)同步相关的模式。\\n\\n### 生产者 - 消费者模式\\n我们的目标是利用队列来提供固定数量的`workers`，与我们想要设置的并发级别一样多。为了实现这个算法，我们将基于本章前面定义的`TaskQueue`类改写：\\n\\n```javascript\\nclass TaskQueue {\\n  constructor(concurrency) {\\n    this.concurrency = concurrency;\\n    this.running = 0;\\n    this.taskQueue = [];\\n    this.consumerQueue = [];\\n    this.spawnWorkers(concurrency);\\n  }\\n  pushTask(task) {\\n    if (this.consumerQueue.length !== 0) {\\n      this.consumerQueue.shift()(null, task);\\n    } else {\\n      this.taskQueue.push(task);\\n    }\\n  }\\n  spawnWorkers(concurrency) {\\n    const self = this;\\n    for (let i = 0; i < concurrency; i++) {\\n      co(function*() {\\n        while (true) {\\n          const task = yield self.nextTask();\\n          yield task;\\n        }\\n      });\\n    }\\n  }\\n  nextTask() {\\n    return callback => {\\n      if (this.taskQueue.length !== 0) {\\n        return callback(null, this.taskQueue.shift());\\n      }\\n      this.consumerQueue.push(callback);\\n    }\\n  }\\n}\\n```\\n\\n让我们分析这个`TaskQueue`类的新实现。首先是在构造函数中。需要调用一次`this.spawnWorkers()`，因为这是启动`worker`的方法。\\n\\n我们的`worker`很简单，它们只是用`co()`包装的立即执行的`Generator`函数，所以每个`Generator`函数可以并行执行。在内部，每个`worker`正在运行在一个死循环（`while(true){}`）中，一直阻塞（`yield`）到新任务在队列中可用时（`yield self.nextTask()`），一旦可以执行新任务，`yield`这个异步任务直到其完成。您可能想知道我们如何能够限制并行执行，并让下一个任务在队列中处于等待状态。答案是在`nextTask()`方法中。我们来详细地看看在这个方法的原理：\\n\\n```javascript\\nnextTask() {\\n  return callback => {\\n    if (this.taskQueue.length !== 0) {\\n      return callback(null, this.taskQueue.shift());\\n    }\\n    this.consumerQueue.push(callback);\\n  }\\n}\\n```\\n\\n我们看这个函数内部发生了什么，这才是这个模式的核心：\\n\\n1. 这个方法返回一个对于`co`而言是一个合法的`yieldable`的`thunk`。\\n2. 只要`taskQueue`类生成的实例中还有下一个任务，`thunk`的回调函数会被立即调用。回调函数调用时，立马解锁一个`worker`的阻塞状态，`yield`这一个任务。\\n3. 如果队列中没有任务了，回调函数本身会被放入`consumerQueue`中。通过这种做法，我们将一个`worker`置于空闲（`idle`）的模式。一旦我们有一个新的任务来要处理，在`consumerQueue`队列中的回调函数会被调用，立马唤醒我们这一`worker`进行异步处理。\\n\\n现在，为了理解`consumerQueue`队列中的空闲`worker`是如何恢复工作的，我们需要分析`pushTask()`方法。如果当前有回调函数可用的话，`pushTask()`方法将调用`consumerQueue`队列中的第一个回调函数，从而将取消对`worker`的锁定。如果没有可用的回调函数，这意味着所有的`worker`都是工作状态，只需要添加一个新的任务到`taskQueue`任务队列中。\\n\\n在`TaskQueue`类中，`worker`充当消费者的角色，而调用`pushTask()`函数的角色可以被认为是生产者。这个模式向我们展示了一个`Generator`函数实际上可以跟一个线程或进程类似。实际上，生产者 - 消费者之间问题是研究进程间通信和同步时最常见的问题，但正如我们已经提到的那样，它对于进程和线程来说，也是一个常见的例子。\\n\\n### 限制下载任务的并发量\\n既然我们已经使用`Generator`函数和生产者 - 消费者模型实现一个限制并行算法，并且已经在`Web爬虫应用程序`第四版应用它来限制中下载任务的并发数。 首先，我们加载和初始化一个`TaskQueue`对象：\\n\\n```javascript\\nconst TaskQueue = require('./taskQueue');\\nconst downloadQueue = new TaskQueue(2);\\n```\\n\\n然后，修改`spiderLinks()`函数。和之前不限制并发的版本类似，所以这里我们只展示修改的部分，主要是通过调用新版本的`TaskQueue`类生成的实例的`pushTask()`方法来限制并行执行：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  //...\\n  return (callback) => {\\n    //...\\n    function done(err, result) {\\n      //...\\n    }\\n    links.forEach(function(link) {\\n      downloadQueue.pushTask(function*() {\\n        yield spider(link, nesting - 1);\\n        done();\\n      });\\n    });\\n  }\\n}\\n```\\n\\n在每个任务中，我们在下载完成后立即调用`done()`函数，因此我们可以计算下载了多少个链接，然后在完成下载时通知`thunk`的回调函数执行。\\n\\n## 配合Babel使用Async await新语法\\n回调函数、`Promise`和`Generator`函数都是用于处理`JavaScript`和`Node.js`异步问题的方式。正如我们所看到的，`Generator`的真正意义在于它提供了一种方式来暂停一个函数的执行，然后等待前面的任务完成后再继续执行。我们可以使用这样的特性来书写异步代码，并且让开发者用同步阻塞的代码风格来书写异步代码。等到异步操作的结果返回后才恢复当前函数的执行。\\n\\n但`Generator`函数是更多的是用来处理迭代器，然而迭代器在异步代码的使用显得有点笨重。代码可能难以理解，导致代码易读性和可维护性差。\\n\\n但在不远的将来会有一种更加简洁的语法。实际上，这个提议即将引入到`ESMASCript 2017`的规范中，这项规范定义了`async`函数语法。\\n\\n`async`函数规范引入两个关键字(`async`和`await`)到原生的`JavaScript`语言中，改进我们书写异步代码的方式。\\n\\n为了理解这项语法的用法和优势为，我们看一个简单的例子：\\n\\n```javascript\\nconst request = require('request');\\n\\nfunction getPageHtml(url) {\\n  return new Promise(function(resolve, reject) {\\n    request(url, function(error, response, body) {\\n      resolve(body);\\n    });\\n  });\\n}\\nasync function main() {\\n  const html = await getPageHtml('http://google.com');\\n  console.log(html);\\n}\\n\\nmain();\\nconsole.log('Loading...');\\n```\\n\\n在上述代码中，有两个函数：`getPageHtml`和`main`。第一个函数的作用是提取给定`URL`的一个远程网页的`HTML`文档代码。值得注意的是，这个函数返回一个`Promise`对象。\\n\\n重点在于`main`函数，因为在这里使用了`async`和`await`关键字。首先要注意的是函数要以`async`关键字为前缀。意思是这个函数执行的是异步代码并且允许它在函数体内使用`await`关键字。`await`关键字在`getPageHtml`调用之前，告诉`JavaScript`解释器在继续执行下一条指令之前，等待`getPageHtml`返回的`Promise`对象的结果。这样，`main`函数内部哪部分代码是异步的，它会等待异步代码的完成再继续执行后续操作，并且不会阻塞这段程序其余部分的正常执行。实际上，控制台会打印字符串`Loading...`，随后是Google主页的`HTML`代码。\\n\\n是不是这种方法的可读性更好并且更容易理解呢? 不幸地是，这个提议尚未定案，即使通过这个提议，我们需要等下一个版本\\n的`ECMAScript`规范出来并把它集成到`Node.js`后，才能使用这个新语法。 所以我们今天做了什么?只是漫无目的地等待?不是，当然不是！我们已经可以在我们的代码中使用`async await`语法，只要我们使用`Babel`。\\n\\n### 安装与运行Babel\\n`Babel`是一个`JavaScript`编译器(或翻译器)，能够使用语法转换器将高版本的`JavaScript`代码转换成其他`JavaScript`代码。语法转换器允许例如我们书写并使用`ES2015`，`ES2016`，`JSX`和其它的新语法，来翻译成往后兼容的代码，在`JavaScript`运行环境如浏览器或`Node.js`中都可以使用`Babel`。\\n\\n在项目中使用`npm`安装`Babel`，命令如下：\\n\\n```\\nnpm install --save-dev babel-cli\\n```\\n\\n我们还需要安装插件以支持`async await`语法的解释或翻译：\\n\\n```\\nnpm install --save-dev babel-plugin-syntax-async-functions babel-plugin-tranform-async-to-generator\\n```\\n\\n现在假设我们想运行我们之前的例子（称为`index.js`）。我们需要通过以下命令启动：\\n\\n```\\nnode_modules/.bin/babel-node --plugins \\\"syntax-async-functions,transform-async-to-generator\\\" index.js\\n```\\n\\n这样，我们使用支持`async await`的转换器动态地转换源代码。`Node.js`运行的实际是保存在内存中的往后兼容的代码。\\n\\n`Babel`也能被配置为一个代码构建工具，保存翻译或解释后的代码到本地文件系统中，便于我们部署和运行生成的代码。\\n\\n> 关于如何安装和配置Babel，可以到官方网站 https://babeljs.io 查阅相关文档。\\n\\n## 几种方式的比较\\n现在，我们应该对于怎么处理`JavaScript`的异步问题有了一个更好的认识和总结。在下面的表格中总结几大机制的优势和劣势：\\n\\n![](http://oczira72b.bkt.clouddn.com/17-11-7/55293366.jpg)\\n\\n> 值得一提的是，我们选择在本章中仅介绍处理异步控制流程的最受欢迎的解决方案，或者是广泛使用的解决方案，但是例如Fibers（ https://npmjs.org/package/fibers ）和Streamline（ https://npmjs.org/p ackage/streamline ）也是值得一看的。\\n\\n## 总结\\n在本章中，我们分析了一些处理异步控制流的方法，分析了`Promise`、`Generator`函数和即将到来的`async await`语法。\\n\\n我们学习了如何使用这些方法编写更简洁，更具有可读性的异步代码。我们讨论了这些方法的一些最重要的优点和缺点，并认识到即使它们非常有用，也需要一些时间来掌握。这就是这几种方式也没有完全取代在许多情况下仍然非常有用的回调的原因。作为一名开发人员，应该按照实际情况分析决定使用哪种解决方案。如果您正在构建执行异步操作的公共库，则应该提供易于使用的`API`，即使对于只想使用回调的开发人员也是如此。\\n\\n在下一章中，我们将探讨另一个与异步代码执行相关的机制，这也是整个`Node.js`生态系统中的另一个基本构建块：`streams`。\",\n        \"_id\": \"5a20d798b564820d22f6910a\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-12-01T04:16:24.262Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 5,\n    \"viewed\": 50,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:17:18.948] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/users/getUserInfo?userName=admin
request client ip:  ::1
request query:  {"userName":"admin"}
response time: 1
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"回复成功\",\n  \"data\": {\n    \"userName\": \"admin\",\n    \"registerTime\": \"2017-11-23T07:36:51.931Z\",\n    \"message\": []\n  }\n}"
*************** response log end ***************

[2017-12-01 12:17:18.965] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/art/updateCheckTimes
request client ip:  ::1
request body: 
{"id":"5a0e8b7949b148371be1f96e","token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxNTc2LCJleHAiOjE1MTIxNDQ3NzZ9.uKBuLKHhVqQEXpCm68cxufPp3HqLhF25sI_3iT0rBmI"}
response time: 6
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-12-01T04:16:24.253Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"# Asynchronous Control Flow Patterns with ES2015 and Beyond\\n在上一章中，我们学习了如何使用回调处理异步代码，以及如何解决如回调地狱代码等异步问题。回调是`JavaScript`和`Node.js`中的异步编程的基础，但是现在，其他替代方案已经出现。这些替代方案更复杂，以便能够以更方便的方式处理异步代码。\\n\\n在本章中，我们将探讨一些代表性的替代方案，`Promise`和`Generator`。以及`async await`，这是一种创新的语法，可在高版本的`JavaScript`中提供，其也作为`ECMAScript 2017`发行版的一部分。\\n\\n我们将看到这些替代方案如何简化处理异步控制流的方式。最后，我们将比较所有这些方法，以了解所有这些方法的所有优点和缺点，并能够明智地选择最适合我们下一个`Node.js`项目要求的方法。\\n\\n## Promise\\n我们在前面的章节中提到，`CPS风格`不是编写异步代码的唯一方法。事实上，`JavaScript`生态系统为传统的回调模式提供了有趣的替代方案。最着名的选择之一是`Promise`，特别是现在它是`ECMAScript 2015`的一部分，并且现在可以在`Node.js`中可用。\\n\\n### 什么是Promise？\\n`Promise`是一种抽象的对象，我们通常允许函数返回一个名为`Promise`的对象，它表示异步操作的最终结果。通常情况下，我们说当异步操作尚未完成时，我们说`Promise`对象处于`pending`状态，当操作成功完成时，我们说`Promise`对象处于`resolve`状态，当操作错误终止时，我们说`Promise`对象处于`reject`状态。一旦`Promise`处于`resolve`或`reject`，我们认为当前异步操作结束。\\n\\n为了接收到异步操作的正确结果或错误捕获，我们可以使用`Promise`的`then`方法：\\n\\n```javascript\\npromise.then([onFulfilled], [onRejected])\\n```\\n\\n在前面的代码中，`onFulfilled()`是一个函数，最终会收到`Promise`的正确结果，而`onRejected()`是另一个函数，它将接收产生异常的原因（如果有的话）。两个参数都是可选的。\\n\\n要了解`Promise`如何转换我们的代码，让我们考虑以下几点：\\n\\n```javascript\\nasyncOperation(arg, (err, result) => {\\n  if (err) {\\n    // 错误处理\\n  }\\n  // 正常结果处理\\n});\\n```\\n\\n`Promise`允许我们将这个典型的`CPS`代码转换成更好的结构化和更优雅的代码，如下所示：\\n\\n```javascript\\nasyncOperation(arg)\\n  .then(result => {\\n    // 错误处理\\n  }, err => {\\n    // 正常结果处理\\n  });\\n```\\n\\n`then()`方法的一个关键特征是它同步地返回另一个`Promise`对象。如果`onFulfilled()`或`onRejected()`函数中的任何一个函数返回`x`，则`then()`方法返回的`Promise`对象将如下所示：\\n\\n* 如果`x`是一个值，则这个`Promise`对象会正确处理(`resolve`)`x`\\n* 如果`x`是一个`Promise`对象或`thenable`，则会正确处理(`resolve`)`x`\\n* 如果`x`是一个异常，则会捕获异常(`reject`)`x`\\n\\n> 注：thenable是一个具有then方法的类似于Promise的对象(Promise-like)。\\n\\n这个特点使我们能够链式构建`Promise`，允许轻松排列组合我们的异步操作。另外，如果我们没有指定一个`onFulfilled()`或`onRejected()`处理程序，则正确结果或异常捕获将自动转发到`Promise`链的下一个`Promise`。例如，这允许我们在整个链中自动传播错误，直到被`onRejected()`处理程序捕获。随着`Promise`链，任务的顺序执行突然变成简单多了：\\n\\n```javascript\\nasyncOperation(arg)\\n  .then(result1 => {\\n    // 返回另一个Promise\\n    return asyncOperation(arg2);\\n  })\\n  .then(result2 => {\\n    // 返回一个值\\n    return 'done';\\n  })\\n  .then(undefined, err => {\\n    // 捕获Promise链中的异常\\n  });\\n```\\n\\n下图展示了链式`Promise`如何工作：\\n\\n![](http://oczira72b.bkt.clouddn.com/17-10-31/46370382.jpg)\\n\\n`Promise`的另一个重要特性是`onFulfilled()`和`onRejected()`函数是异步调用的，如同上述的例子，在最后那个`then`函数`resolve`一个同步的`Promise`，它也是同步的。这种模式避免了`Zalgo`（参见`Chapter2-Node.js Essential Patterns`），使我们的异步代码更加一致和稳健。\\n\\n如果在`onFulfilled()`或`onRejected()`处理程序中抛出异常（使用`throw`语句），则`then()`方法返回的`Promise`将被自动地`reject`，抛出异常作为`reject`的原因。这相对于`CPS`来说是一个巨大的优势，因为它意味着有了`Promise`，异常将在整个链中自动传播，并且`throw`语句终于可以使用。\\n\\n在以前，许多不同的库实现了`Promise`，大多数时候它们之间不兼容，这意味着不可能在使用不同`Promise`库的`thenable`链式传播错误。\\n\\n`JavaScript`社区非常努力地解决了这个限制，这些努力导致了`Promises / A +`规范的创建。该规范详细描述了`then`方法的行为，提供了一个可互兼容的基础，这使得来自不同库的`Promise`对象能够彼此兼容，开箱即用。\\n\\n有关`Promises / A +`规范的详细说明，可以参考[Promises / A + 官方网站](https://promisesaplus.com)。\\n\\n### Promise / A + 的实施\\n在`JavaScript`中以及`Node.js`中，有几个实现`Promises / A +`规范的库。以下是最受欢迎的：\\n\\n* [Bluebird](https://npmjs.org/package/bluebird)\\n* [Q](https://npmjs.org/package/q)\\n* [RSVP](https://npmjs.org/package/rsvp)\\n* [Vow](https://npmjs.org/package/vow)\\n* [When.js](https://npmjs.org/package/when)\\n* ES2015 promises\\n\\n真正区别他们的是在`Promises / A +`标准之上提供的额外功能。正如我们上述所说的那样，该标准定义了`then()`方法和`Promise`解析过程的行为，但它没有指定其他功能，例如，如何从基于回调的异步函数创建`Promise`。\\n\\n在我们的示例中，我们将使用由`ES2015`的`Promise`，因为`Promise`对象自`Node.js 4`后即可使用，而不需要任何库来实现。\\n\\n作为参考，以下是`ES2015`的`Promise`提供的API：\\n\\n`constructor`(`new Promise（function（resolve, reject）{}）`)：创建了一个新的`Promise`，它基于作为传递两个类型为函数的参数来决定`resolve`或`reject`。构造函数的参数解释如下：\\n\\n* `resolve(obj)` ：`resolve`一个`Promise`，并带上一个参数`obj`，如果`obj`是一个值，这个值就是传递的异步操作成功的结果。如果`obj`是一个`Promise`或一个`thenable`，则会进行正确处理。\\n* `reject(err)`：`reject`一个`Promise`，并带上一个参数`err`。它是`Error`对象的一个实例。\\n\\n#### Promise对象的静态方法\\n* `Promise.resolve(obj)`： 将会创建一个`resolve`的`Promise`实例\\n* `Promise.reject(err)`： 将会创建一个`reject`的`Promise`实例\\n* `Promise.all(iterable)`：返回一个新的`Promise`实例，并且在`iterable`中所\\n有`Promise`状态为`reject`时, 返回的`Promise`实例的状态会被置为`reject`，如果`iterable`中至少有一个`Promise`状态为`reject`时, 返回的`Promise`实例状态也会被置为`reject`，并且`reject`的原因是第一个被`reject`的`Promise`对象的`reject`原因。\\n* `Promise.race(iterable)`：返回一个`Promise`实例，当`iterable`中任何一个`Promise`被`resolve`或被`reject`时， 返回的`Promise`实例以同样的原因`resolve`或`reject`。\\n\\n#### Promise实例方法\\n* `Promise.then(onFulfilled, onRejected)`：这是`Promise`的基本方法。它的行为与我们之前描述的`Promises / A +`标准兼容。\\n* `Promise.catch(onRejected)`：这只是`Promise.then(undefined，onRejected)`的语法糖。\\n\\n> 值得一提的是，一些Promise实现提供了另一种机制来创建新的Promise，称为deferreds。我们不会在这里描述，因为它不是ES2015标准的一部分，但是如果您想了解更多信息，可以阅读Q文档 (https://github.com/kriskowal/q#using-deferreds) 或When.js文档 (https://github.com/cujojs/when/wiki/Deferred) 。\\n\\n### Promisifying一个Node.js回调风格的函数\\n在`JavaScript`中，并不是所有的异步函数和库都支持开箱即用的`Promise`。大多数情况下，我们必须将一个典型的基于回调的函数转换成一个返回`Promise`的函数，这个过程也被称为`promisification`。\\n\\n幸运的是，`Node.js`中使用的回调约定允许我们创建一个可重用的函数，我们通过使用`Promise`对象的构造函数来简化任何`Node.js`风格的`API`。让我们创建一个名为`promisify()`的新函数，并将其包含到`utilities.js`模块中（以便稍后在我们的`Web爬虫应用程序`中使用它）：\\n\\n```javascript\\nmodule.exports.promisify = function(callbackBasedApi) {\\n  return function promisified() {\\n    const args = [].slice.call(arguments);\\n    return new Promise((resolve, reject) => {\\n      args.push((err, result) => {\\n        if (err) {\\n          return reject(err);\\n        }\\n        if (arguments.length <= 2) {\\n          resolve(result);\\n        } else {\\n          resolve([].slice.call(arguments, 1));\\n        }\\n      });\\n      callbackBasedApi.apply(null, args);\\n    });\\n  }\\n};\\n```\\n\\n前面的函数返回另一个名为`promisified()`的函数，它表示输入中给出的`callbackBasedApi`的`promisified`版本。以下展示它是如何工作的：\\n\\n1. `promisified()`函数使用`Promise`构造函数创建一个新的`Promise`对象，并立即将其返回给调用者。\\n2. 在传递给`Promise`构造函数的函数中，我们确保传递给`callbackBasedApi`，这是一个特殊的回调函数。由于我们知道回调总是最后调用的，我们只需将回调函数附加到提供给`promisified()`函数的参数列表里（`args`）。\\n3. 在特殊的回调中，如果我们收到错误，我们立即`reject`这个`Promise`。\\n4. 如果没有收到错误，我们使用一个值或一个数组值来`resolve`这个`Promise`，具体取决于传递给回调的结果数量。\\n5. 最后，我们只需使用我们构建的参数列表调用`callbackBasedApi`。\\n\\n> 大部分的Promise已经提供了一个开箱即用的接口来将一个Node.js风格的API转换成一个返回Promise的API。例如，Q有Q.denodeify()和Q.nbind()，Bluebird有Promise.promisify()，而When.js有node.lift()。\\n\\n### 顺序执行\\n在一些必要的理论之后，我们现在准备将我们的`Web爬虫应用程序`转换为使用`Promise`的形式。让我们直接从版本2开始，直接下载一个Web网页的链接。\\n\\n在`spider.js`模块中，第一步是加载我们的`Promise`实现（我们稍后会使用它）和`Promisifying`我们打算使用的基于回调的函数：\\n\\n```javascript\\nconst utilities = require('./utilities');\\nconst request = utilities.promisify(require('request'));\\nconst mkdirp = utilities.promisify(require('mkdirp'));\\nconst fs = require('fs');\\nconst readFile = utilities.promisify(fs.readFile);\\nconst writeFile = utilities.promisify(fs.writeFile);\\n```\\n\\n现在，我们开始更改我们的`download`函数：\\n\\n```javascript\\nfunction download(url, filename) {\\n  console.log(`Downloading ${url}`);\\n  let body;\\n  return request(url)\\n    .then(response => {\\n      body = response.body;\\n      return mkdirp(path.dirname(filename));\\n    })\\n    .then(() => writeFile(filename, body))\\n    .then(() => {\\n      console.log(`Downloaded and saved: ${url}`);\\n      return body;\\n    });\\n}\\n```\\n\\n这里要注意的到的最重要的是我们也为`readFile()`返回的`Promise`注册\\n一个`onRejected()`函数，用来处理一个网页没有被下载的情况(或文件不存在)。 还有，看我们如何使用`throw`来传递`onRejected()`函数中的错误的。\\n\\n既然我们已经更改我们的`spider()`函数，我们这么修改它的调用方式：\\n\\n```javascript\\nspider(process.argv[2], 1)\\n  .then(() => console.log('Download complete'))\\n  .catch(err => console.log(err));\\n```\\n\\n注意我们是如何第一次使用`Promise`的语法糖`catch`来处理源自`spider()`函数的任何错误情况。如果我们再看看迄今为止我们所写的所有代码，那么我们会惊喜的发现，我们没有包含任何错误传播逻辑，因为我们在使用回调函数时会被迫做这样的事情。这显然是一个巨大的优势，因为它极大地减少了我们代码中的样板文件以及丢失任何异步错误的机会。\\n\\n现在，完成我们唯一缺失的`Web爬虫应用程序`的第二版的`spiderLinks()`函数，我们将在稍后实现它。\\n\\n### 顺序迭代\\n到目前为止，`Web爬虫应用程序`代码库主要是对`Promise`是什么以及如何使用的概述，展示了使用`Promise`实现顺序执行流程的简单性和优雅性。但是，我们现在考虑的代码只涉及到一组已知的异步操作的执行。所以，完成我们对顺序执行流程的探索的缺失部分是看我们如何使用`Promise`来实现迭代。同样，网络蜘蛛第二版的`spiderLinks()`函数也是一个很好的例子。\\n\\n让我们添加缺少的这一块：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  let promise = Promise.resolve();\\n  if (nesting === 0) {\\n    return promise;\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  links.forEach(link => {\\n    promise = promise.then(() => spider(link, nesting - 1));\\n  });\\n  return promise;\\n}\\n```\\n\\n为了异步迭代一个网页的全部链接，我们必须动态创建一个`Promise`的迭代链。\\n\\n1. 首先，我们定义一个空的`Promise`，`resolve`为`undefined`。这个`Promise`只是用来作为`Promise`的迭代链的起始点。 \\n2. 然后，我们通过在循环中调用链中前一个`Promise`的`then()`方法获得的新的`Promise`来更新`Promise`变量。这就是我们使用`Promise`的异步迭代模式。\\n\\n这样，循环的结束，`promise`变量会包含循环中最后一个`then()`返回的`Promise`对象，所以它只有当`Promise`的迭代链中全部`Promise`对象被`resolve`后才能被`resolve`。\\n\\n> 注：在最后调用了这个then方法来resolve这个Promise对象\\n\\n通过这个，我们已使用`Promise`对象重写了我们的`Web爬虫应用程序`。我们现在应该可以运行它了。\\n\\n### 顺序迭代模式\\n为了总结这个顺序执行的部分，让我们提取一个模式来依次遍历一组`Promise`：\\n\\n```javascript\\nlet tasks = [ /* ... */ ]\\nlet promise = Promise.resolve();\\ntasks.forEach(task => {\\n  promise = promise.then(() => {\\n    return task();\\n  });\\n});\\npromise.then(() => {\\n  // 所有任务都完成\\n});\\n```\\n\\n使用`reduce()`方法来替代`forEach()`方法，允许我们写出更为简洁的代码：\\n\\n```javascript\\nlet tasks = [ /* ... */ ]\\nlet promise = tasks.reduce((prev, task) => {\\n  return prev.then(() => {\\n    return task();\\n  });\\n}, Promise.resolve());\\n\\npromise.then(() => {\\n  //All tasks completed\\n});\\n```\\n\\n与往常一样，通过对这种模式的简单调整，我们可以将所有任务的结果收集到一个数组中，我们可以实现一个`mapping`算法，或者构建一个`filter`等等。\\n\\n> 上述这个模式使用循环动态地建立一个链式的Promise。\\n\\n### 并行执行\\n另一个适合用`Promise`的执行流程是并行执行流程。实际上，我们需要做的就是使用内置的`Promise.all()`。这个方法创造了另一个`Promise`对象，只有在输入中的所有`Promise`都`resolve`时才能`resolve`。这是一个并行执行，因为在其参数`Promise`对象的之间没有执行顺序可言。\\n\\n为了演示这一点，我们来看我们的`Web爬虫应用程序`的第三版，它将页面中的所有链接并行下载。让我们再次使用`Promise`更新`spiderLinks()`函数来实现并行流程：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return Promise.resolve();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  const promises = links.map(link => spider(link, nesting - 1));\\n  return Promise.all(promises);\\n}\\n```\\n\\n这里的模式在`elements.map()`迭代中产生一个数组，存放所有异步任务，之后便于同时启动`spider()`任务。这一次，在循环中，我们不等待以前的下载完成，然后开始一个新的下载任务：所有的下载任务在一个循环中一个接一个地开始。之后，我们利用`Promise.all()`方法，它返回一个新的`Promise`对象，当数组中的所有`Promise`对象都被`resolve`时，这个`Promise`对象将被`resolve`。换句话说，所有的下载任务完成，这正是我们想要的。\\n\\n### 限制并行执行\\n不幸的是，`ES2015`的`Promise API`并没有提供一种原生的方式来限制并发任务的数量，但是我们总是可以依靠我们所学到的有关用普通`JavaScript`来限制并发。事实上，我们在`TaskQueue`类中实现的模式可以很容易地被调整来支持返回承诺的任务。这很容易通过修改`next()`方法来完成：\\n\\n```javascript\\nclass TaskQueue {\\n  constructor(concurrency) {\\n    this.concurrency = concurrency;\\n    this.running = 0;\\n    this.queue = [];\\n  }\\n\\n  pushTask(task) {\\n    this.queue.push(task);\\n    this.next();\\n  }\\n\\n  next() {\\n    while (this.running < this.concurrency && this.queue.length) {\\n      const task = this.queue.shift();\\n      task().then(() => {\\n        this.running--;\\n        this.next();\\n      });\\n      this.running++;\\n    }\\n  }\\n}\\n```\\n\\n不同于使用一个回调函数来处理任务，我们简单地调用`Promise`的`then()`。\\n\\n让我们回到`spider.js`模块，并修改它以支持我们的新版本的`TaskQueue`类。首先，我们确保定义一个`TaskQueue`的新实例：\\n\\n```javascript\\nconst TaskQueue = require('./taskQueue');\\nconst downloadQueue = new TaskQueue(2);\\n```\\n\\n然后，是我们的`spiderLinks()`函数。这里的修改也是很简单：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return Promise.resolve();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  // 我们需要如下代码，用于创建Promise对象\\n  // 如果没有下列代码，当任务数量为0时，将永远不会resolve\\n  if (links.length === 0) {\\n    return Promise.resolve();\\n  }\\n  return new Promise((resolve, reject) => {\\n    let completed = 0;\\n    let errored = false;\\n    links.forEach(link => {\\n      let task = () => {\\n        return spider(link, nesting - 1)\\n          .then(() => {\\n            if (++completed === links.length) {\\n              resolve();\\n            }\\n          })\\n          .catch(() => {\\n            if (!errored) {\\n              errored = true;\\n              reject();\\n            }\\n          });\\n      };\\n      downloadQueue.pushTask(task);\\n    });\\n  });\\n}\\n```\\n\\n在上述代码中有几点值得我们注意的：\\n\\n* 首先，我们需要返回使用`Promise`构造函数创建的新的`Promise`对象。正如我们将看到的，这使我们能够在队列中的所有任务完成时手动`resolve`我们的`Promise`对象。\\n* 然后，我们应该看看我们如何定义任务。我们所做的是将一个`onFulfilled()`回调函数的调用添加到由`spider()`返回的`Promise`对象中，所以我们可以计算完成的下载任务的数量。当完成的下载量与当前页面中链接的数量相同时，我们知道任务已经处理完毕，所以我们可以调用外部`Promise`的`resolve()`函数。\\n\\n> Promises / A +规范规定，then()方法的onFulfilled()和onRejected()回调函数只能调用一次（仅调用onFulfilled()和onRejected()）。Promise接口的实现确保即使我们多次手动调用resolve或reject，Promise也仅可以被resolve或reject一次。\\n\\n现在，使用`Promise`的`Web爬虫应用程序`的第4版应该已经准备好了。我们可能再次注意到下载任务如何并行运行，并发数量限制为2。\\n\\n### 在公有API中暴露回调函数和Promise\\n正如我们在前面所学到的，`Promise`可以被用作回调函数的一个很好的替代品。它们使我们的代码更具可读性和易于理解。虽然`Promise`带来了许多优点，但也要求开发人员理解许多不易于理解的概念，以便正确和熟练地使用。由于这个原因和其他原因，在某些情况下，比起`Promise`来说，很多开发者更偏向于回调函数。\\n\\n现在让我们想象一下，我们想要构建一个执行异步操作的公共库。我们需要做什么？我们是创建了一个基于回调函数的`API`还是一个面向`Promise`的`API`？还是两者均有？\\n\\n这是许多知名的库所面临的问题，至少有两种方法值得一提，使我们能够提供一个多功能的`API`。\\n\\n像`request`，`redis`和`mysql`这样的库所使用的第一种方法是提供一个简单的基于回调函数的`API`，如果需要，开发人员可以选择公开函数。其中一些库提供工具函数来`Promise`化异步回调，但开发人员仍然需要以某种方式将暴露的`API`转换为能够使用`Promise`对象。\\n\\n第二种方法更透明。它还提供了一个面向回调的`API`，但它使回调参数可选。每当回调作为参数传递时，函数将正常运行，在完成时或失败时执行回调。当回调未被传递时，函数将立即返回一个`Promise`对象。这种方法有效地结合了回调函数和`Promise`，使得开发者可以在调用时选择采用什么接口，而不需要提前进行`Promise`化。许多库，如`mongoose`和`sequelize`，都支持这种方法。\\n\\n我们来看一个简单的例子。假设我们要实现一个异步执行除法的模块：\\n\\n```javascript\\nmodule.exports = function asyncDivision(dividend, divisor, cb) {\\n  return new Promise((resolve, reject) => { // [1]\\n    process.nextTick(() => {\\n      const result = dividend / divisor;\\n      if (isNaN(result) || !Number.isFinite(result)) {\\n        const error = new Error('Invalid operands');\\n        if (cb) {\\n          cb(error); // [2]\\n        }\\n        return reject(error);\\n      }\\n      if (cb) {\\n        cb(null, result); // [3]\\n      }\\n      resolve(result);\\n    });\\n  });\\n};\\n```\\n\\n该模块的代码非常简单，但是有一些值得强调的细节：\\n\\n* 首先，返回使用`Promise`的构造函数创建的新承诺。我们在构造函数参数函数内定义全部逻辑。\\n* 在发生错误的情况下，我们`reject`这个`Promise`，但如果回调函数在被调用时作为参数传递，我们也执行回调来进行错误传播。\\n* 在计算结果之后，我们`resolve`了这个`Promise`，但是如果有回调函数，我们也会将结果传播给回调函数。\\n\\n我们现在看如何用回调函数和`Promise`来使用这个模块：\\n\\n```javascript\\n// 回调函数的方式\\nasyncDivision(10, 2, (error, result) => {\\n  if (error) {\\n    return console.error(error);\\n  }\\n  console.log(result);\\n});\\n\\n// Promise化的调用方式\\nasyncDivision(22, 11)\\n  .then(result => console.log(result))\\n  .catch(error => console.error(error));\\n```\\n\\n应该很清楚的是，即将开始使用类似于上述的新模块的开发人员将很容易地选择最适合自己需求的风格，而无需在希望利用`Promise`时引入外部`promisification`功能。\\n\\n## Generators\\n`ES2015`规范引入了另外一种机制，除了其他新功能外，还可以用来简化`Node.js`应用程序的异步控制流程。我们正在谈论`Generator`，也被称为`semi-coroutines`。它们是子程序的一般化，可以有不同的入口点。在一个正常的函数中，实际上我们只能有一个入口点，这个入口点对应着函数本身的调用。`Generator`与一般函数类似，但是可以暂停（使用`yield`语句），然后在稍后继续执行。在实现迭代器时，`Generator`特别有用，因为我们已经讨论了如何使用迭代器来实现重要的异步控制流模式，如顺序执行和限制并行执行。\\n\\n### Generators基础\\n在我们探索使用`Generator`来实现异步控制流程之前，学习一些基本概念是很重要的。我们从语法开始吧。可以通过在函数关键字之后附加`*`（星号）运算符来声明`Generator`函数：\\n\\n```javascript\\nfunction* makeGenerator() {\\n  // body\\n}\\n```\\n\\n在`makeGenerator()`函数内部，我们可以使用关键字`yield`暂停执行并返回给调用者传递给它的值：\\n\\n```javascript\\nfunction* makeGenerator() {\\n  yield 'Hello World';\\n  console.log('Re-entered');\\n}\\n```\\n\\n在前面的代码中，`Generator`通过`yield`一个字符串`Hello World`暂停当前函数的执行。当`Generator`恢复时，执行将从下列语句开始：\\n\\n```javascript\\nconsole.log('Re-entered');\\n```\\n\\n`makeGenerator()`函数本质上是一个工厂，它在被调用时返回一个新的`Generator`对象：\\n\\n```javascript\\nconst gen = makeGenerator();\\n```\\n\\n生成器对象的最重要的方法是`next()`，它用于启动/恢复`Generator`的执行，并返回如下形式的对象：\\n\\n```\\n{\\n  value: <yielded value>\\n  done: <true if the execution reached the end>\\n}\\n```\\n\\n这个对象包含`Generator` `yield`的值和一个指示`Generator`是否已经完成执行的符号。\\n\\n### 一个简单的例子\\n为了演示`Generator`，我们来创建一个名为`fruitGenerator.js`的新模块：\\n\\n```javascript\\nfunction* fruitGenerator() {\\n  yield 'apple';\\n  yield 'orange';\\n  return 'watermelon';\\n}\\nconst newFruitGenerator = fruitGenerator();\\nconsole.log(newFruitGenerator.next()); // [1]\\nconsole.log(newFruitGenerator.next()); // [2]\\nconsole.log(newFruitGenerator.next()); // [3]\\n```\\n\\n前面的代码将打印下面的输出：\\n\\n```\\n{ value: 'apple', done: false }\\n{ value: 'orange', done: false }\\n{ value: 'watermelon', done: true }\\n```\\n\\n我们可以这么解释上述现象：\\n\\n* 第一次调用`newFruitGenerator.next()`时，`Generator`函数开始执行，直到达到第一个`yield`语句为止，该命令暂停`Generator`函数执行，并将值`apple`返回给调用者。\\n* 在第二次调用`newFruitGenerator.next()`时，`Generator`函数恢复执行，从第二个`yield`语句开始，这又使得执行暂停，同时将`orange`返回给调用者。\\n* `newFruitGenerator.next()`的最后一次调用导致`Generator`函数的执行从其最后的`yield`恢复，一个返回语句，它终止`Generator`函数，返回`watermelon`，并将结果对象中的`done`属性设置为`true`。\\n\\n### Generators作为迭代器\\n为了更好地理解为什么`Generator`函数对实现迭代器非常有用，我们来构建一个例子。在我们将调用`iteratorGenerator.js`的新模块中，我们编写下面的代码：\\n\\n```javascript\\nfunction* iteratorGenerator(arr) {\\n  for (let i = 0; i < arr.length; i++) {\\n    yield arr[i];\\n  }\\n}\\nconst iterator = iteratorGenerator(['apple', 'orange', 'watermelon']);\\nlet currentItem = iterator.next();\\nwhile (!currentItem.done) {\\n  console.log(currentItem.value);\\n  currentItem = iterator.next();\\n}\\n```\\n\\n此代码应按如下所示打印数组中的元素：\\n\\n```\\napple\\norange\\nwatermelon\\n```\\n\\n在这个例子中，每次我们调用`iterator.next()`时，我们都会恢复`Generator`函数的`for`循环，通过`yield`数组中的下一个项来运行另一个循环。这演示了如何在函数调用过程中维护`Generator`的状态。当继续执行时，循环和所有变量的值与`Generator`函数执行暂停时的状态完全相同。\\n\\n### 传值给Generators\\n现在我们继续研究`Generator`的基本功能，首先学习如何将值传递回`Generator`函数。这其实很简单，我们需要做的只是为`next()`方法提供一个参数，并且该值将作为`Generator`函数内的`yield`语句的返回值提供。\\n\\n为了展示这一点，我们来创建一个新的简单模块：\\n\\n```javascript\\nfunction* twoWayGenerator() {\\n  const what = yield null;\\n  console.log('Hello ' + what);\\n}\\nconst twoWay = twoWayGenerator();\\ntwoWay.next();\\ntwoWay.next('world');\\n```\\n\\n当执行时，前面的代码会输出`Hello world`。我们做如下的解释：\\n\\n* 第一次调用`next()`方法时，`Generator`函数到达第一个`yield`语句，然后暂停。\\n* 当`next('world')`被调用时，`Generator`函数从上次停止的位置，也就是上次的`yield`语句点恢复，但是这次我们有一个值传递到`Generator`函数。这个值将被赋值到`what`变量。生成器然后执行`console.log()`指令并终止。\\n\\n用类似的方式，我们可以强制`Generator`函数抛出异常。这可以通过使用`Generator`函数的`throw`方法来实现，如下例所示：\\n\\n```javascript\\nconst twoWay = twoWayGenerator();\\ntwoWay.next();\\ntwoWay.throw(new Error());\\n```\\n\\n在这个最后这段代码，`twoWayGenerator()`函数将在`yield`函数返回的时候抛出异常。这就好像从`Generator`函数内部抛出了一个异常一样，这意味着它可以像使用`try ... catch`块一样进行捕获和处理异常。\\n\\n### Generator实现异步控制流\\n你一定想知道`Generator`函数如何帮助我们处理异步操作。我们可以通过创建一个接受`Generator`函数作为参数的特殊函数来演示这一点，并允许我们在`Generator`函数内部使用异步代码。这个函数在异步操作完成时要注意恢复`Generator`函数的执行。我们将调用这个函数`asyncFlow()`：\\n\\n```javascript\\nfunction asyncFlow(generatorFunction) {\\n  function callback(err) {\\n    if (err) {\\n      return generator.throw(err);\\n    }\\n    const results = [].slice.call(arguments, 1);\\n    generator.next(results.length > 1 ? results : results[0]);\\n  }\\n  const generator = generatorFunction(callback);\\n  generator.next();\\n}\\n```\\n\\n前面的函数取一个`Generator`函数作为输入，然后立即调用：\\n\\n```javascript\\nconst generator = generatorFunction(callback);\\ngenerator.next();\\n```\\n\\n`generatorFunction()`接受一个特殊的回调函数作为参数，当`generator.throw()`如果接收到一个错误，便立即返回。另外，通过将在回调函数中接收的`results`传值回`Generator`函数继续`Generator`函数的执行:\\n\\n```javascript\\nif (err) {\\n  return generator.throw(err);\\n}\\nconst results = [].slice.call(arguments, 1);\\ngenerator.next(results.length > 1 ? results : results[0]);\\n```\\n\\n为了说明这个简单的辅助函数的强大，我们创建一个叫做`clone.js`的新模块，这个模块只是创建它本身的克隆。粘贴我们刚才创建的`asyncFlow()`函数，核心代码如下：\\n\\n```javascript\\nconst fs = require('fs');\\nconst path = require('path');\\nasyncFlow(function*(callback) {\\n  const fileName = path.basename(__filename);\\n  const myself = yield fs.readFile(fileName, 'utf8', callback);\\n  yield fs.writeFile(`clone_of_${filename}`, myself, callback);\\n  console.log('Clone created');\\n});\\n```\\n\\n明显地，有了`asyncFlow()`函数的帮助，我们可以像我们书写同步阻塞函数一样用同步的方式来书写异步代码了。并且这个结果背后的原理显得很清楚。一旦异步操作结束，传递给每个异步函数的回调函数将继续`Generator`函数的执行。没有什么复杂的，但是结果确实很令人意外。\\n\\n这个技术有其他两个变化，一个是`Promise`的使用，另外一个则是`thunks`。\\n\\n> 在基于Generator的控制流中使用的thunk只是一个简单的函数，它除了回调之外，部分地应用了原始函数的所有参数。返回值是另一个只接受回调作为参数的函数。例如，fs.readFile（）的thunkified版本如下所示：\\n\\n```javascript\\nfunction readFileThunk(filename, options) {\\n  return function(callback) {\\n    fs.readFile(filename, options, callback);\\n  }\\n}\\n```\\n\\n`thunk`和`Promise`都允许我们创建不需要回调的`Generator`函数作为参数传递，例如，使用`thunk`的`asyncFlow()`版本如下：\\n\\n```javascript\\nfunction asyncFlowWithThunks(generatorFunction) {\\n  function callback(err) {\\n    if (err) {\\n      return generator.throw(err);\\n    }\\n    const results = [].slice.call(arguments, 1);\\n    const thunk = generator.next(results.length > 1 ? results : results[0]).value;\\n    thunk && thunk(callback);\\n  }\\n  const generator = generatorFunction();\\n  const thunk = generator.next().value;\\n  thunk && thunk(callback);\\n}\\n```\\n\\n这个技巧是读取`generator.next()`的返回值，返回值中包含`thunk`。下一步是通过注入特殊的回调函数调用`thunk`本身。这允许我们写下面的代码：\\n\\n```javascript\\nasyncFlowWithThunk(function*() {\\n  const fileName = path.basename(__filename);\\n  const myself = yield readFileThunk(__filename, 'utf8');\\n  yield writeFileThunk(`clone_of_${fileName}`, myself);\\n  console.log(\\\"Clone created\\\")\\n});\\n```\\n\\n### 使用co的基于Gernator的控制流\\n你应该已经猜到了，`Node.js`生态系统会借助`Generator`函数来提供一些处理异步控制流的解决方案，例如，[suspend](https://npm/js.org/package/suspend)是其中一个最老的支持`Promise`、`thunks`和`Node.js`风格回调函数和正常风格的回调函数的 库。还有，大部分我们之前分析的`Promise`库都提供工具函数使得`Generator`和`Promise`可以一起使用。\\n\\n我们选择[co](https://npmjs.org/package/co)作为本章节的例子。它支持很多类型的`yieldables`，其中一些是：\\n\\n* `Thunks`\\n* `Promises`\\n* `Arrays`(并行执行)\\n* `Objects`(并行执行)\\n* `Generators`(委托)\\n* `Generator`函数(委托)\\n\\n还有很多框架或库是基于`co`生态系统的，包括以下一些：\\n\\n* `Web框架`，最流行的是[koa](https://npmjs.org/package/koa)\\n* 实现特定控制流模式的库\\n* 包装流行的`API`兼容`co`的库\\n\\n我们使用`co`重新实现我们的`Generator`版本的`Web爬虫应用程序`。\\n\\n为了将`Node.js`风格的函数转换成`thunks`，我们将会使用一个叫做[thunkify](https://npmjs.org/package/thunkify)的库。\\n\\n### 顺序执行\\n让我们通过修改`Web爬虫应用程序`的版本2开始我们对`Generator`函数和`co`的实际探索。我们要做的第一件事就是加载我们的依赖包，并生成我们要使用的函数的`thunkified`版本。这些将在`spider.js`模块的最开始进行：\\n\\n```javascript\\nconst thunkify = require('thunkify');\\nconst co = require('co');\\nconst request = thunkify(require('request'));\\nconst fs = require('fs');\\nconst mkdirp = thunkify(require('mkdirp'));\\nconst readFile = thunkify(fs.readFile);\\nconst writeFile = thunkify(fs.writeFile);\\nconst nextTick = thunkify(process.nextTick);\\n```\\n\\n看上述代码，我们可以注意到与本章前面`promisify`化的`API`的代码的一些相似之处。在这一点上，有意思的是，如果我们使用我们的`promisified`版本的函数来代替`thunkified`的版本，代码将保持完全一样，这要归功于`co`支持`thunk`和`Promise`对象作为`yieldable`对象。事实上，如果我们想，甚至可以在同一个应用程序中使用`thunk`和`Promise`，即使在同一个`Generator`函数中。就灵活性而言，这是一个巨大的优势，因为它使我们能够使用基于`Generator`函数的控制流来解决我们应用程序中的问题。\\n\\n好的，现在让我们开始将`download()`函数转换为一个`Generator`函数：\\n\\n```javascript\\nfunction* download(url, filename) {\\n  console.log(`Downloading ${url}`);\\n  const response = yield request(url);\\n  const body = response[1];\\n  yield mkdirp(path.dirname(filename));\\n  yield writeFile(filename, body);\\n  console.log(`Downloaded and saved ${url}`);\\n  return body;\\n}\\n```\\n\\n通过使用`Generator`和`co`，我们的`download()`函数变得简单多了。当我们需要做异步操作的时候，我们使用异步的`Generator`函数作为`thunk`来把之前的内容转化到`Generator`函数，并使用`yield`子句。\\n\\n然后我们开始实现我们的`spider()`函数：\\n\\n```javascript\\nfunction* spider(url, nesting) {\\n  cost filename = utilities.urlToFilename(url);\\n  let body;\\n  try {\\n    body = yield readFile(filename, 'utf8');\\n  } catch (err) {\\n    if (err.code !== 'ENOENT') {\\n      throw err;\\n    }\\n    body = yield download(url, filename);\\n  }\\n  yield spiderLinks(url, body, nesting);\\n}\\n```\\n\\n从上述代码中一个有趣的细节是我们可以使用`try...catch`语句块来处理异常。我们还可以使用`throw`来传播异常。另外一个细节是我们`yield`我们的`download()`函数，而这个函数既不是一个`thunk`，也不是一个`promisified`函数，只是另外的一个`Generator`函数。这也毫无问题，由于`co`也支持其他`Generators`作为`yieldables`。\\n\\n最后转换`spiderLinks()`，在这个函数中，我们递归下载一个网页的链接。在这个函数中使用`Generators`，显得简单多了：\\n\\n```javascript\\nfunction* spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return nextTick();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  for (let i = 0; i < links.length; i++) {\\n    yield spider(links[i], nesting - 1);\\n  }\\n}\\n```\\n\\n看上述代码。虽然顺序迭代没有什么模式可以展示。`Generator`和`co`辅助我们做了很多，方便了我们可以使用同步方式开书写异步代码。\\n\\n看最重要的部分，程序的入口：\\n\\n```javascript\\nco(function*() {\\n  try {\\n    yield spider(process.argv[2], 1);\\n    console.log(`Download complete`);\\n  } catch (err) {\\n    console.log(err);\\n  }\\n});\\n```\\n\\n这是唯一一处需要调用`co(...)`来封装的一个`Generator`。实际上，一旦我们这么做，`co`会自动封装我们传递给`yield`语句的任何`Generator`函数，并且这个过程是递归的，所以程序的剩余部分与我们是否使用`co`是完全无关的，虽然是被`co`封装在里面。\\n\\n现在应该可以运行使用`Generator`函数改写的`Web爬虫应用程序`了。\\n\\n### 并行执行\\n不幸的是，虽然`Generator`很方便地进行顺序执行，但是不能直接用来并行化执行一组任务，至少不能仅仅使用`yield`和`Generator`。之前，在种情况下我们使用的模式只是简单地依赖于一个基于回调或者`Promise`的函数，但使用了`Generator`函数后，一切会显得更简单。\\n\\n幸运的是，如果不限制并发数的并行执行，`co`已经可以通过`yield`一个`Promise`对象、`thunk`、`Generator`函数，甚至包含`Generator`函数的数组来实现。\\n\\n考虑到这一点，我们的`Web爬虫应用程序`第三版可以通过重写`spiderLinks()`函数来做如下改动：\\n\\n```javascript\\nfunction* spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return nextTick();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  const tasks = links.map(link => spider(link, nesting - 1));\\n  yield tasks;\\n}\\n```\\n\\n但是上述函数所做的只是拿到所有的任务，这些任务本质上都是通过`Generator`函数来实现异步的，如果在`co`的`thunk`内对一个包含`Generator`函数的数组使用`yield`，这些任务都会并行执行。外层的`Generator`函数会等到`yield`子句的所有异步任务并行执行后再继续执行。\\n\\n接下来我们看怎么用一个基于回调函数的方式来解决相同的并行流。我们用这种方式重写`spiderLinks()`函数：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return nextTick();\\n  }\\n  // 返回一个thunk\\n  return callback => {\\n    let completed = 0,\\n      hasErrors = false;\\n    const links = utilities.getPageLinks(currentUrl, body);\\n    if (links.length === 0) {\\n      return process.nextTick(callback);\\n    }\\n\\n    function done(err, result) {\\n      if (err && !hasErrors) {\\n        hasErrors = true;\\n        return callback(err);\\n      }\\n      if (++completed === links.length && !hasErrors) {\\n        callback();\\n      }\\n    }\\n    for (let i = 0; i < links.length; i++) {\\n      co(spider(links[i], nesting - 1)).then(done);\\n    }\\n  }\\n}\\n```\\n\\n我们使用`co`并行运行`spider()`函数，调用`Generator`函数返回了一个`Promise`对象。这样，等待`Promise`完成后调用`done()`函数。通常，基于`Generator`控制流的库都有这一功能，因此如果需要，你总是可以将一个`Generator`转换成一个基于回调或基于`Promise`的函数。\\n\\n为了并行开启多个下载任务，我们只要重用在前面定义的基于回调的并行执行的模式。我们应该也注意到我们将`spiderLinks()`转换成一个`thunk`(而不再是一个`Generator`函数)。这使得当全部并行任务完成时，我们有一个回调函数可以调用。\\n\\n> 上面讲到的是将一个Generator函数转换为一个thunk的模式，使之能够支持其他的基于回调或基于Promise的控制流算法，并可以通过同步阻塞的代码风格书写异步代码。\\n\\n### 限制并行执行\\n现在我们知道如何处理异步执行流程，应该很容易规划我们的`Web爬虫应用程序`的第四版的实现，这个版本对并发下载任务的数量施加了限制。我们有几个方案可以用来做到这一点。其中一些方案如下：\\n\\n* 使用先前实现的基于回调的`TaskQueue`类。我们只需要`thunkify`我们的`Generator`函数和其提供的回调函数即可。\\n* 使用基于`Promise`的`TaskQueue`类，并确保每个作为任务的`Generator`函数都被转换成一个返回`Promise`对象的函数。\\n* 使用`async`，`thunkify`我们打算使用的工具函数，此外还需要把我们用到的`Generator`函数转化为基于回调的模式，以便于能够被这个库较好地使用。\\n* 使用基于`co`的生态系统中的库，特别是专门为这种场景的库，如[co-limiter](https://npmjs.org/package/co-limiter)。\\n* 实现基于生产者 - 消费者模型的自定义算法，这与`co-limiter`的内部实现原理相同。\\n\\n为了学习，我们选择最后一个方案，甚至帮助我们可以更好地理解一种经常与协程(也和线程和进程)同步相关的模式。\\n\\n### 生产者 - 消费者模式\\n我们的目标是利用队列来提供固定数量的`workers`，与我们想要设置的并发级别一样多。为了实现这个算法，我们将基于本章前面定义的`TaskQueue`类改写：\\n\\n```javascript\\nclass TaskQueue {\\n  constructor(concurrency) {\\n    this.concurrency = concurrency;\\n    this.running = 0;\\n    this.taskQueue = [];\\n    this.consumerQueue = [];\\n    this.spawnWorkers(concurrency);\\n  }\\n  pushTask(task) {\\n    if (this.consumerQueue.length !== 0) {\\n      this.consumerQueue.shift()(null, task);\\n    } else {\\n      this.taskQueue.push(task);\\n    }\\n  }\\n  spawnWorkers(concurrency) {\\n    const self = this;\\n    for (let i = 0; i < concurrency; i++) {\\n      co(function*() {\\n        while (true) {\\n          const task = yield self.nextTask();\\n          yield task;\\n        }\\n      });\\n    }\\n  }\\n  nextTask() {\\n    return callback => {\\n      if (this.taskQueue.length !== 0) {\\n        return callback(null, this.taskQueue.shift());\\n      }\\n      this.consumerQueue.push(callback);\\n    }\\n  }\\n}\\n```\\n\\n让我们分析这个`TaskQueue`类的新实现。首先是在构造函数中。需要调用一次`this.spawnWorkers()`，因为这是启动`worker`的方法。\\n\\n我们的`worker`很简单，它们只是用`co()`包装的立即执行的`Generator`函数，所以每个`Generator`函数可以并行执行。在内部，每个`worker`正在运行在一个死循环（`while(true){}`）中，一直阻塞（`yield`）到新任务在队列中可用时（`yield self.nextTask()`），一旦可以执行新任务，`yield`这个异步任务直到其完成。您可能想知道我们如何能够限制并行执行，并让下一个任务在队列中处于等待状态。答案是在`nextTask()`方法中。我们来详细地看看在这个方法的原理：\\n\\n```javascript\\nnextTask() {\\n  return callback => {\\n    if (this.taskQueue.length !== 0) {\\n      return callback(null, this.taskQueue.shift());\\n    }\\n    this.consumerQueue.push(callback);\\n  }\\n}\\n```\\n\\n我们看这个函数内部发生了什么，这才是这个模式的核心：\\n\\n1. 这个方法返回一个对于`co`而言是一个合法的`yieldable`的`thunk`。\\n2. 只要`taskQueue`类生成的实例中还有下一个任务，`thunk`的回调函数会被立即调用。回调函数调用时，立马解锁一个`worker`的阻塞状态，`yield`这一个任务。\\n3. 如果队列中没有任务了，回调函数本身会被放入`consumerQueue`中。通过这种做法，我们将一个`worker`置于空闲（`idle`）的模式。一旦我们有一个新的任务来要处理，在`consumerQueue`队列中的回调函数会被调用，立马唤醒我们这一`worker`进行异步处理。\\n\\n现在，为了理解`consumerQueue`队列中的空闲`worker`是如何恢复工作的，我们需要分析`pushTask()`方法。如果当前有回调函数可用的话，`pushTask()`方法将调用`consumerQueue`队列中的第一个回调函数，从而将取消对`worker`的锁定。如果没有可用的回调函数，这意味着所有的`worker`都是工作状态，只需要添加一个新的任务到`taskQueue`任务队列中。\\n\\n在`TaskQueue`类中，`worker`充当消费者的角色，而调用`pushTask()`函数的角色可以被认为是生产者。这个模式向我们展示了一个`Generator`函数实际上可以跟一个线程或进程类似。实际上，生产者 - 消费者之间问题是研究进程间通信和同步时最常见的问题，但正如我们已经提到的那样，它对于进程和线程来说，也是一个常见的例子。\\n\\n### 限制下载任务的并发量\\n既然我们已经使用`Generator`函数和生产者 - 消费者模型实现一个限制并行算法，并且已经在`Web爬虫应用程序`第四版应用它来限制中下载任务的并发数。 首先，我们加载和初始化一个`TaskQueue`对象：\\n\\n```javascript\\nconst TaskQueue = require('./taskQueue');\\nconst downloadQueue = new TaskQueue(2);\\n```\\n\\n然后，修改`spiderLinks()`函数。和之前不限制并发的版本类似，所以这里我们只展示修改的部分，主要是通过调用新版本的`TaskQueue`类生成的实例的`pushTask()`方法来限制并行执行：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  //...\\n  return (callback) => {\\n    //...\\n    function done(err, result) {\\n      //...\\n    }\\n    links.forEach(function(link) {\\n      downloadQueue.pushTask(function*() {\\n        yield spider(link, nesting - 1);\\n        done();\\n      });\\n    });\\n  }\\n}\\n```\\n\\n在每个任务中，我们在下载完成后立即调用`done()`函数，因此我们可以计算下载了多少个链接，然后在完成下载时通知`thunk`的回调函数执行。\\n\\n## 配合Babel使用Async await新语法\\n回调函数、`Promise`和`Generator`函数都是用于处理`JavaScript`和`Node.js`异步问题的方式。正如我们所看到的，`Generator`的真正意义在于它提供了一种方式来暂停一个函数的执行，然后等待前面的任务完成后再继续执行。我们可以使用这样的特性来书写异步代码，并且让开发者用同步阻塞的代码风格来书写异步代码。等到异步操作的结果返回后才恢复当前函数的执行。\\n\\n但`Generator`函数是更多的是用来处理迭代器，然而迭代器在异步代码的使用显得有点笨重。代码可能难以理解，导致代码易读性和可维护性差。\\n\\n但在不远的将来会有一种更加简洁的语法。实际上，这个提议即将引入到`ESMASCript 2017`的规范中，这项规范定义了`async`函数语法。\\n\\n`async`函数规范引入两个关键字(`async`和`await`)到原生的`JavaScript`语言中，改进我们书写异步代码的方式。\\n\\n为了理解这项语法的用法和优势为，我们看一个简单的例子：\\n\\n```javascript\\nconst request = require('request');\\n\\nfunction getPageHtml(url) {\\n  return new Promise(function(resolve, reject) {\\n    request(url, function(error, response, body) {\\n      resolve(body);\\n    });\\n  });\\n}\\nasync function main() {\\n  const html = await getPageHtml('http://google.com');\\n  console.log(html);\\n}\\n\\nmain();\\nconsole.log('Loading...');\\n```\\n\\n在上述代码中，有两个函数：`getPageHtml`和`main`。第一个函数的作用是提取给定`URL`的一个远程网页的`HTML`文档代码。值得注意的是，这个函数返回一个`Promise`对象。\\n\\n重点在于`main`函数，因为在这里使用了`async`和`await`关键字。首先要注意的是函数要以`async`关键字为前缀。意思是这个函数执行的是异步代码并且允许它在函数体内使用`await`关键字。`await`关键字在`getPageHtml`调用之前，告诉`JavaScript`解释器在继续执行下一条指令之前，等待`getPageHtml`返回的`Promise`对象的结果。这样，`main`函数内部哪部分代码是异步的，它会等待异步代码的完成再继续执行后续操作，并且不会阻塞这段程序其余部分的正常执行。实际上，控制台会打印字符串`Loading...`，随后是Google主页的`HTML`代码。\\n\\n是不是这种方法的可读性更好并且更容易理解呢? 不幸地是，这个提议尚未定案，即使通过这个提议，我们需要等下一个版本\\n的`ECMAScript`规范出来并把它集成到`Node.js`后，才能使用这个新语法。 所以我们今天做了什么?只是漫无目的地等待?不是，当然不是！我们已经可以在我们的代码中使用`async await`语法，只要我们使用`Babel`。\\n\\n### 安装与运行Babel\\n`Babel`是一个`JavaScript`编译器(或翻译器)，能够使用语法转换器将高版本的`JavaScript`代码转换成其他`JavaScript`代码。语法转换器允许例如我们书写并使用`ES2015`，`ES2016`，`JSX`和其它的新语法，来翻译成往后兼容的代码，在`JavaScript`运行环境如浏览器或`Node.js`中都可以使用`Babel`。\\n\\n在项目中使用`npm`安装`Babel`，命令如下：\\n\\n```\\nnpm install --save-dev babel-cli\\n```\\n\\n我们还需要安装插件以支持`async await`语法的解释或翻译：\\n\\n```\\nnpm install --save-dev babel-plugin-syntax-async-functions babel-plugin-tranform-async-to-generator\\n```\\n\\n现在假设我们想运行我们之前的例子（称为`index.js`）。我们需要通过以下命令启动：\\n\\n```\\nnode_modules/.bin/babel-node --plugins \\\"syntax-async-functions,transform-async-to-generator\\\" index.js\\n```\\n\\n这样，我们使用支持`async await`的转换器动态地转换源代码。`Node.js`运行的实际是保存在内存中的往后兼容的代码。\\n\\n`Babel`也能被配置为一个代码构建工具，保存翻译或解释后的代码到本地文件系统中，便于我们部署和运行生成的代码。\\n\\n> 关于如何安装和配置Babel，可以到官方网站 https://babeljs.io 查阅相关文档。\\n\\n## 几种方式的比较\\n现在，我们应该对于怎么处理`JavaScript`的异步问题有了一个更好的认识和总结。在下面的表格中总结几大机制的优势和劣势：\\n\\n![](http://oczira72b.bkt.clouddn.com/17-11-7/55293366.jpg)\\n\\n> 值得一提的是，我们选择在本章中仅介绍处理异步控制流程的最受欢迎的解决方案，或者是广泛使用的解决方案，但是例如Fibers（ https://npmjs.org/package/fibers ）和Streamline（ https://npmjs.org/p ackage/streamline ）也是值得一看的。\\n\\n## 总结\\n在本章中，我们分析了一些处理异步控制流的方法，分析了`Promise`、`Generator`函数和即将到来的`async await`语法。\\n\\n我们学习了如何使用这些方法编写更简洁，更具有可读性的异步代码。我们讨论了这些方法的一些最重要的优点和缺点，并认识到即使它们非常有用，也需要一些时间来掌握。这就是这几种方式也没有完全取代在许多情况下仍然非常有用的回调的原因。作为一名开发人员，应该按照实际情况分析决定使用哪种解决方案。如果您正在构建执行异步操作的公共库，则应该提供易于使用的`API`，即使对于只想使用回调的开发人员也是如此。\\n\\n在下一章中，我们将探讨另一个与异步代码执行相关的机制，这也是整个`Node.js`生态系统中的另一个基本构建块：`streams`。\",\n        \"_id\": \"5a20d798b564820d22f6910a\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-12-01T04:16:24.262Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 5,\n    \"viewed\": 51,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:17:18.968] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/art/getArticleDetail?id=5a0e8b7949b148371be1f96e
request client ip:  ::1
request query:  {"id":"5a0e8b7949b148371be1f96e"}
response time: 6
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-12-01T04:16:24.253Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"# Asynchronous Control Flow Patterns with ES2015 and Beyond\\n在上一章中，我们学习了如何使用回调处理异步代码，以及如何解决如回调地狱代码等异步问题。回调是`JavaScript`和`Node.js`中的异步编程的基础，但是现在，其他替代方案已经出现。这些替代方案更复杂，以便能够以更方便的方式处理异步代码。\\n\\n在本章中，我们将探讨一些代表性的替代方案，`Promise`和`Generator`。以及`async await`，这是一种创新的语法，可在高版本的`JavaScript`中提供，其也作为`ECMAScript 2017`发行版的一部分。\\n\\n我们将看到这些替代方案如何简化处理异步控制流的方式。最后，我们将比较所有这些方法，以了解所有这些方法的所有优点和缺点，并能够明智地选择最适合我们下一个`Node.js`项目要求的方法。\\n\\n## Promise\\n我们在前面的章节中提到，`CPS风格`不是编写异步代码的唯一方法。事实上，`JavaScript`生态系统为传统的回调模式提供了有趣的替代方案。最着名的选择之一是`Promise`，特别是现在它是`ECMAScript 2015`的一部分，并且现在可以在`Node.js`中可用。\\n\\n### 什么是Promise？\\n`Promise`是一种抽象的对象，我们通常允许函数返回一个名为`Promise`的对象，它表示异步操作的最终结果。通常情况下，我们说当异步操作尚未完成时，我们说`Promise`对象处于`pending`状态，当操作成功完成时，我们说`Promise`对象处于`resolve`状态，当操作错误终止时，我们说`Promise`对象处于`reject`状态。一旦`Promise`处于`resolve`或`reject`，我们认为当前异步操作结束。\\n\\n为了接收到异步操作的正确结果或错误捕获，我们可以使用`Promise`的`then`方法：\\n\\n```javascript\\npromise.then([onFulfilled], [onRejected])\\n```\\n\\n在前面的代码中，`onFulfilled()`是一个函数，最终会收到`Promise`的正确结果，而`onRejected()`是另一个函数，它将接收产生异常的原因（如果有的话）。两个参数都是可选的。\\n\\n要了解`Promise`如何转换我们的代码，让我们考虑以下几点：\\n\\n```javascript\\nasyncOperation(arg, (err, result) => {\\n  if (err) {\\n    // 错误处理\\n  }\\n  // 正常结果处理\\n});\\n```\\n\\n`Promise`允许我们将这个典型的`CPS`代码转换成更好的结构化和更优雅的代码，如下所示：\\n\\n```javascript\\nasyncOperation(arg)\\n  .then(result => {\\n    // 错误处理\\n  }, err => {\\n    // 正常结果处理\\n  });\\n```\\n\\n`then()`方法的一个关键特征是它同步地返回另一个`Promise`对象。如果`onFulfilled()`或`onRejected()`函数中的任何一个函数返回`x`，则`then()`方法返回的`Promise`对象将如下所示：\\n\\n* 如果`x`是一个值，则这个`Promise`对象会正确处理(`resolve`)`x`\\n* 如果`x`是一个`Promise`对象或`thenable`，则会正确处理(`resolve`)`x`\\n* 如果`x`是一个异常，则会捕获异常(`reject`)`x`\\n\\n> 注：thenable是一个具有then方法的类似于Promise的对象(Promise-like)。\\n\\n这个特点使我们能够链式构建`Promise`，允许轻松排列组合我们的异步操作。另外，如果我们没有指定一个`onFulfilled()`或`onRejected()`处理程序，则正确结果或异常捕获将自动转发到`Promise`链的下一个`Promise`。例如，这允许我们在整个链中自动传播错误，直到被`onRejected()`处理程序捕获。随着`Promise`链，任务的顺序执行突然变成简单多了：\\n\\n```javascript\\nasyncOperation(arg)\\n  .then(result1 => {\\n    // 返回另一个Promise\\n    return asyncOperation(arg2);\\n  })\\n  .then(result2 => {\\n    // 返回一个值\\n    return 'done';\\n  })\\n  .then(undefined, err => {\\n    // 捕获Promise链中的异常\\n  });\\n```\\n\\n下图展示了链式`Promise`如何工作：\\n\\n![](http://oczira72b.bkt.clouddn.com/17-10-31/46370382.jpg)\\n\\n`Promise`的另一个重要特性是`onFulfilled()`和`onRejected()`函数是异步调用的，如同上述的例子，在最后那个`then`函数`resolve`一个同步的`Promise`，它也是同步的。这种模式避免了`Zalgo`（参见`Chapter2-Node.js Essential Patterns`），使我们的异步代码更加一致和稳健。\\n\\n如果在`onFulfilled()`或`onRejected()`处理程序中抛出异常（使用`throw`语句），则`then()`方法返回的`Promise`将被自动地`reject`，抛出异常作为`reject`的原因。这相对于`CPS`来说是一个巨大的优势，因为它意味着有了`Promise`，异常将在整个链中自动传播，并且`throw`语句终于可以使用。\\n\\n在以前，许多不同的库实现了`Promise`，大多数时候它们之间不兼容，这意味着不可能在使用不同`Promise`库的`thenable`链式传播错误。\\n\\n`JavaScript`社区非常努力地解决了这个限制，这些努力导致了`Promises / A +`规范的创建。该规范详细描述了`then`方法的行为，提供了一个可互兼容的基础，这使得来自不同库的`Promise`对象能够彼此兼容，开箱即用。\\n\\n有关`Promises / A +`规范的详细说明，可以参考[Promises / A + 官方网站](https://promisesaplus.com)。\\n\\n### Promise / A + 的实施\\n在`JavaScript`中以及`Node.js`中，有几个实现`Promises / A +`规范的库。以下是最受欢迎的：\\n\\n* [Bluebird](https://npmjs.org/package/bluebird)\\n* [Q](https://npmjs.org/package/q)\\n* [RSVP](https://npmjs.org/package/rsvp)\\n* [Vow](https://npmjs.org/package/vow)\\n* [When.js](https://npmjs.org/package/when)\\n* ES2015 promises\\n\\n真正区别他们的是在`Promises / A +`标准之上提供的额外功能。正如我们上述所说的那样，该标准定义了`then()`方法和`Promise`解析过程的行为，但它没有指定其他功能，例如，如何从基于回调的异步函数创建`Promise`。\\n\\n在我们的示例中，我们将使用由`ES2015`的`Promise`，因为`Promise`对象自`Node.js 4`后即可使用，而不需要任何库来实现。\\n\\n作为参考，以下是`ES2015`的`Promise`提供的API：\\n\\n`constructor`(`new Promise（function（resolve, reject）{}）`)：创建了一个新的`Promise`，它基于作为传递两个类型为函数的参数来决定`resolve`或`reject`。构造函数的参数解释如下：\\n\\n* `resolve(obj)` ：`resolve`一个`Promise`，并带上一个参数`obj`，如果`obj`是一个值，这个值就是传递的异步操作成功的结果。如果`obj`是一个`Promise`或一个`thenable`，则会进行正确处理。\\n* `reject(err)`：`reject`一个`Promise`，并带上一个参数`err`。它是`Error`对象的一个实例。\\n\\n#### Promise对象的静态方法\\n* `Promise.resolve(obj)`： 将会创建一个`resolve`的`Promise`实例\\n* `Promise.reject(err)`： 将会创建一个`reject`的`Promise`实例\\n* `Promise.all(iterable)`：返回一个新的`Promise`实例，并且在`iterable`中所\\n有`Promise`状态为`reject`时, 返回的`Promise`实例的状态会被置为`reject`，如果`iterable`中至少有一个`Promise`状态为`reject`时, 返回的`Promise`实例状态也会被置为`reject`，并且`reject`的原因是第一个被`reject`的`Promise`对象的`reject`原因。\\n* `Promise.race(iterable)`：返回一个`Promise`实例，当`iterable`中任何一个`Promise`被`resolve`或被`reject`时， 返回的`Promise`实例以同样的原因`resolve`或`reject`。\\n\\n#### Promise实例方法\\n* `Promise.then(onFulfilled, onRejected)`：这是`Promise`的基本方法。它的行为与我们之前描述的`Promises / A +`标准兼容。\\n* `Promise.catch(onRejected)`：这只是`Promise.then(undefined，onRejected)`的语法糖。\\n\\n> 值得一提的是，一些Promise实现提供了另一种机制来创建新的Promise，称为deferreds。我们不会在这里描述，因为它不是ES2015标准的一部分，但是如果您想了解更多信息，可以阅读Q文档 (https://github.com/kriskowal/q#using-deferreds) 或When.js文档 (https://github.com/cujojs/when/wiki/Deferred) 。\\n\\n### Promisifying一个Node.js回调风格的函数\\n在`JavaScript`中，并不是所有的异步函数和库都支持开箱即用的`Promise`。大多数情况下，我们必须将一个典型的基于回调的函数转换成一个返回`Promise`的函数，这个过程也被称为`promisification`。\\n\\n幸运的是，`Node.js`中使用的回调约定允许我们创建一个可重用的函数，我们通过使用`Promise`对象的构造函数来简化任何`Node.js`风格的`API`。让我们创建一个名为`promisify()`的新函数，并将其包含到`utilities.js`模块中（以便稍后在我们的`Web爬虫应用程序`中使用它）：\\n\\n```javascript\\nmodule.exports.promisify = function(callbackBasedApi) {\\n  return function promisified() {\\n    const args = [].slice.call(arguments);\\n    return new Promise((resolve, reject) => {\\n      args.push((err, result) => {\\n        if (err) {\\n          return reject(err);\\n        }\\n        if (arguments.length <= 2) {\\n          resolve(result);\\n        } else {\\n          resolve([].slice.call(arguments, 1));\\n        }\\n      });\\n      callbackBasedApi.apply(null, args);\\n    });\\n  }\\n};\\n```\\n\\n前面的函数返回另一个名为`promisified()`的函数，它表示输入中给出的`callbackBasedApi`的`promisified`版本。以下展示它是如何工作的：\\n\\n1. `promisified()`函数使用`Promise`构造函数创建一个新的`Promise`对象，并立即将其返回给调用者。\\n2. 在传递给`Promise`构造函数的函数中，我们确保传递给`callbackBasedApi`，这是一个特殊的回调函数。由于我们知道回调总是最后调用的，我们只需将回调函数附加到提供给`promisified()`函数的参数列表里（`args`）。\\n3. 在特殊的回调中，如果我们收到错误，我们立即`reject`这个`Promise`。\\n4. 如果没有收到错误，我们使用一个值或一个数组值来`resolve`这个`Promise`，具体取决于传递给回调的结果数量。\\n5. 最后，我们只需使用我们构建的参数列表调用`callbackBasedApi`。\\n\\n> 大部分的Promise已经提供了一个开箱即用的接口来将一个Node.js风格的API转换成一个返回Promise的API。例如，Q有Q.denodeify()和Q.nbind()，Bluebird有Promise.promisify()，而When.js有node.lift()。\\n\\n### 顺序执行\\n在一些必要的理论之后，我们现在准备将我们的`Web爬虫应用程序`转换为使用`Promise`的形式。让我们直接从版本2开始，直接下载一个Web网页的链接。\\n\\n在`spider.js`模块中，第一步是加载我们的`Promise`实现（我们稍后会使用它）和`Promisifying`我们打算使用的基于回调的函数：\\n\\n```javascript\\nconst utilities = require('./utilities');\\nconst request = utilities.promisify(require('request'));\\nconst mkdirp = utilities.promisify(require('mkdirp'));\\nconst fs = require('fs');\\nconst readFile = utilities.promisify(fs.readFile);\\nconst writeFile = utilities.promisify(fs.writeFile);\\n```\\n\\n现在，我们开始更改我们的`download`函数：\\n\\n```javascript\\nfunction download(url, filename) {\\n  console.log(`Downloading ${url}`);\\n  let body;\\n  return request(url)\\n    .then(response => {\\n      body = response.body;\\n      return mkdirp(path.dirname(filename));\\n    })\\n    .then(() => writeFile(filename, body))\\n    .then(() => {\\n      console.log(`Downloaded and saved: ${url}`);\\n      return body;\\n    });\\n}\\n```\\n\\n这里要注意的到的最重要的是我们也为`readFile()`返回的`Promise`注册\\n一个`onRejected()`函数，用来处理一个网页没有被下载的情况(或文件不存在)。 还有，看我们如何使用`throw`来传递`onRejected()`函数中的错误的。\\n\\n既然我们已经更改我们的`spider()`函数，我们这么修改它的调用方式：\\n\\n```javascript\\nspider(process.argv[2], 1)\\n  .then(() => console.log('Download complete'))\\n  .catch(err => console.log(err));\\n```\\n\\n注意我们是如何第一次使用`Promise`的语法糖`catch`来处理源自`spider()`函数的任何错误情况。如果我们再看看迄今为止我们所写的所有代码，那么我们会惊喜的发现，我们没有包含任何错误传播逻辑，因为我们在使用回调函数时会被迫做这样的事情。这显然是一个巨大的优势，因为它极大地减少了我们代码中的样板文件以及丢失任何异步错误的机会。\\n\\n现在，完成我们唯一缺失的`Web爬虫应用程序`的第二版的`spiderLinks()`函数，我们将在稍后实现它。\\n\\n### 顺序迭代\\n到目前为止，`Web爬虫应用程序`代码库主要是对`Promise`是什么以及如何使用的概述，展示了使用`Promise`实现顺序执行流程的简单性和优雅性。但是，我们现在考虑的代码只涉及到一组已知的异步操作的执行。所以，完成我们对顺序执行流程的探索的缺失部分是看我们如何使用`Promise`来实现迭代。同样，网络蜘蛛第二版的`spiderLinks()`函数也是一个很好的例子。\\n\\n让我们添加缺少的这一块：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  let promise = Promise.resolve();\\n  if (nesting === 0) {\\n    return promise;\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  links.forEach(link => {\\n    promise = promise.then(() => spider(link, nesting - 1));\\n  });\\n  return promise;\\n}\\n```\\n\\n为了异步迭代一个网页的全部链接，我们必须动态创建一个`Promise`的迭代链。\\n\\n1. 首先，我们定义一个空的`Promise`，`resolve`为`undefined`。这个`Promise`只是用来作为`Promise`的迭代链的起始点。 \\n2. 然后，我们通过在循环中调用链中前一个`Promise`的`then()`方法获得的新的`Promise`来更新`Promise`变量。这就是我们使用`Promise`的异步迭代模式。\\n\\n这样，循环的结束，`promise`变量会包含循环中最后一个`then()`返回的`Promise`对象，所以它只有当`Promise`的迭代链中全部`Promise`对象被`resolve`后才能被`resolve`。\\n\\n> 注：在最后调用了这个then方法来resolve这个Promise对象\\n\\n通过这个，我们已使用`Promise`对象重写了我们的`Web爬虫应用程序`。我们现在应该可以运行它了。\\n\\n### 顺序迭代模式\\n为了总结这个顺序执行的部分，让我们提取一个模式来依次遍历一组`Promise`：\\n\\n```javascript\\nlet tasks = [ /* ... */ ]\\nlet promise = Promise.resolve();\\ntasks.forEach(task => {\\n  promise = promise.then(() => {\\n    return task();\\n  });\\n});\\npromise.then(() => {\\n  // 所有任务都完成\\n});\\n```\\n\\n使用`reduce()`方法来替代`forEach()`方法，允许我们写出更为简洁的代码：\\n\\n```javascript\\nlet tasks = [ /* ... */ ]\\nlet promise = tasks.reduce((prev, task) => {\\n  return prev.then(() => {\\n    return task();\\n  });\\n}, Promise.resolve());\\n\\npromise.then(() => {\\n  //All tasks completed\\n});\\n```\\n\\n与往常一样，通过对这种模式的简单调整，我们可以将所有任务的结果收集到一个数组中，我们可以实现一个`mapping`算法，或者构建一个`filter`等等。\\n\\n> 上述这个模式使用循环动态地建立一个链式的Promise。\\n\\n### 并行执行\\n另一个适合用`Promise`的执行流程是并行执行流程。实际上，我们需要做的就是使用内置的`Promise.all()`。这个方法创造了另一个`Promise`对象，只有在输入中的所有`Promise`都`resolve`时才能`resolve`。这是一个并行执行，因为在其参数`Promise`对象的之间没有执行顺序可言。\\n\\n为了演示这一点，我们来看我们的`Web爬虫应用程序`的第三版，它将页面中的所有链接并行下载。让我们再次使用`Promise`更新`spiderLinks()`函数来实现并行流程：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return Promise.resolve();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  const promises = links.map(link => spider(link, nesting - 1));\\n  return Promise.all(promises);\\n}\\n```\\n\\n这里的模式在`elements.map()`迭代中产生一个数组，存放所有异步任务，之后便于同时启动`spider()`任务。这一次，在循环中，我们不等待以前的下载完成，然后开始一个新的下载任务：所有的下载任务在一个循环中一个接一个地开始。之后，我们利用`Promise.all()`方法，它返回一个新的`Promise`对象，当数组中的所有`Promise`对象都被`resolve`时，这个`Promise`对象将被`resolve`。换句话说，所有的下载任务完成，这正是我们想要的。\\n\\n### 限制并行执行\\n不幸的是，`ES2015`的`Promise API`并没有提供一种原生的方式来限制并发任务的数量，但是我们总是可以依靠我们所学到的有关用普通`JavaScript`来限制并发。事实上，我们在`TaskQueue`类中实现的模式可以很容易地被调整来支持返回承诺的任务。这很容易通过修改`next()`方法来完成：\\n\\n```javascript\\nclass TaskQueue {\\n  constructor(concurrency) {\\n    this.concurrency = concurrency;\\n    this.running = 0;\\n    this.queue = [];\\n  }\\n\\n  pushTask(task) {\\n    this.queue.push(task);\\n    this.next();\\n  }\\n\\n  next() {\\n    while (this.running < this.concurrency && this.queue.length) {\\n      const task = this.queue.shift();\\n      task().then(() => {\\n        this.running--;\\n        this.next();\\n      });\\n      this.running++;\\n    }\\n  }\\n}\\n```\\n\\n不同于使用一个回调函数来处理任务，我们简单地调用`Promise`的`then()`。\\n\\n让我们回到`spider.js`模块，并修改它以支持我们的新版本的`TaskQueue`类。首先，我们确保定义一个`TaskQueue`的新实例：\\n\\n```javascript\\nconst TaskQueue = require('./taskQueue');\\nconst downloadQueue = new TaskQueue(2);\\n```\\n\\n然后，是我们的`spiderLinks()`函数。这里的修改也是很简单：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return Promise.resolve();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  // 我们需要如下代码，用于创建Promise对象\\n  // 如果没有下列代码，当任务数量为0时，将永远不会resolve\\n  if (links.length === 0) {\\n    return Promise.resolve();\\n  }\\n  return new Promise((resolve, reject) => {\\n    let completed = 0;\\n    let errored = false;\\n    links.forEach(link => {\\n      let task = () => {\\n        return spider(link, nesting - 1)\\n          .then(() => {\\n            if (++completed === links.length) {\\n              resolve();\\n            }\\n          })\\n          .catch(() => {\\n            if (!errored) {\\n              errored = true;\\n              reject();\\n            }\\n          });\\n      };\\n      downloadQueue.pushTask(task);\\n    });\\n  });\\n}\\n```\\n\\n在上述代码中有几点值得我们注意的：\\n\\n* 首先，我们需要返回使用`Promise`构造函数创建的新的`Promise`对象。正如我们将看到的，这使我们能够在队列中的所有任务完成时手动`resolve`我们的`Promise`对象。\\n* 然后，我们应该看看我们如何定义任务。我们所做的是将一个`onFulfilled()`回调函数的调用添加到由`spider()`返回的`Promise`对象中，所以我们可以计算完成的下载任务的数量。当完成的下载量与当前页面中链接的数量相同时，我们知道任务已经处理完毕，所以我们可以调用外部`Promise`的`resolve()`函数。\\n\\n> Promises / A +规范规定，then()方法的onFulfilled()和onRejected()回调函数只能调用一次（仅调用onFulfilled()和onRejected()）。Promise接口的实现确保即使我们多次手动调用resolve或reject，Promise也仅可以被resolve或reject一次。\\n\\n现在，使用`Promise`的`Web爬虫应用程序`的第4版应该已经准备好了。我们可能再次注意到下载任务如何并行运行，并发数量限制为2。\\n\\n### 在公有API中暴露回调函数和Promise\\n正如我们在前面所学到的，`Promise`可以被用作回调函数的一个很好的替代品。它们使我们的代码更具可读性和易于理解。虽然`Promise`带来了许多优点，但也要求开发人员理解许多不易于理解的概念，以便正确和熟练地使用。由于这个原因和其他原因，在某些情况下，比起`Promise`来说，很多开发者更偏向于回调函数。\\n\\n现在让我们想象一下，我们想要构建一个执行异步操作的公共库。我们需要做什么？我们是创建了一个基于回调函数的`API`还是一个面向`Promise`的`API`？还是两者均有？\\n\\n这是许多知名的库所面临的问题，至少有两种方法值得一提，使我们能够提供一个多功能的`API`。\\n\\n像`request`，`redis`和`mysql`这样的库所使用的第一种方法是提供一个简单的基于回调函数的`API`，如果需要，开发人员可以选择公开函数。其中一些库提供工具函数来`Promise`化异步回调，但开发人员仍然需要以某种方式将暴露的`API`转换为能够使用`Promise`对象。\\n\\n第二种方法更透明。它还提供了一个面向回调的`API`，但它使回调参数可选。每当回调作为参数传递时，函数将正常运行，在完成时或失败时执行回调。当回调未被传递时，函数将立即返回一个`Promise`对象。这种方法有效地结合了回调函数和`Promise`，使得开发者可以在调用时选择采用什么接口，而不需要提前进行`Promise`化。许多库，如`mongoose`和`sequelize`，都支持这种方法。\\n\\n我们来看一个简单的例子。假设我们要实现一个异步执行除法的模块：\\n\\n```javascript\\nmodule.exports = function asyncDivision(dividend, divisor, cb) {\\n  return new Promise((resolve, reject) => { // [1]\\n    process.nextTick(() => {\\n      const result = dividend / divisor;\\n      if (isNaN(result) || !Number.isFinite(result)) {\\n        const error = new Error('Invalid operands');\\n        if (cb) {\\n          cb(error); // [2]\\n        }\\n        return reject(error);\\n      }\\n      if (cb) {\\n        cb(null, result); // [3]\\n      }\\n      resolve(result);\\n    });\\n  });\\n};\\n```\\n\\n该模块的代码非常简单，但是有一些值得强调的细节：\\n\\n* 首先，返回使用`Promise`的构造函数创建的新承诺。我们在构造函数参数函数内定义全部逻辑。\\n* 在发生错误的情况下，我们`reject`这个`Promise`，但如果回调函数在被调用时作为参数传递，我们也执行回调来进行错误传播。\\n* 在计算结果之后，我们`resolve`了这个`Promise`，但是如果有回调函数，我们也会将结果传播给回调函数。\\n\\n我们现在看如何用回调函数和`Promise`来使用这个模块：\\n\\n```javascript\\n// 回调函数的方式\\nasyncDivision(10, 2, (error, result) => {\\n  if (error) {\\n    return console.error(error);\\n  }\\n  console.log(result);\\n});\\n\\n// Promise化的调用方式\\nasyncDivision(22, 11)\\n  .then(result => console.log(result))\\n  .catch(error => console.error(error));\\n```\\n\\n应该很清楚的是，即将开始使用类似于上述的新模块的开发人员将很容易地选择最适合自己需求的风格，而无需在希望利用`Promise`时引入外部`promisification`功能。\\n\\n## Generators\\n`ES2015`规范引入了另外一种机制，除了其他新功能外，还可以用来简化`Node.js`应用程序的异步控制流程。我们正在谈论`Generator`，也被称为`semi-coroutines`。它们是子程序的一般化，可以有不同的入口点。在一个正常的函数中，实际上我们只能有一个入口点，这个入口点对应着函数本身的调用。`Generator`与一般函数类似，但是可以暂停（使用`yield`语句），然后在稍后继续执行。在实现迭代器时，`Generator`特别有用，因为我们已经讨论了如何使用迭代器来实现重要的异步控制流模式，如顺序执行和限制并行执行。\\n\\n### Generators基础\\n在我们探索使用`Generator`来实现异步控制流程之前，学习一些基本概念是很重要的。我们从语法开始吧。可以通过在函数关键字之后附加`*`（星号）运算符来声明`Generator`函数：\\n\\n```javascript\\nfunction* makeGenerator() {\\n  // body\\n}\\n```\\n\\n在`makeGenerator()`函数内部，我们可以使用关键字`yield`暂停执行并返回给调用者传递给它的值：\\n\\n```javascript\\nfunction* makeGenerator() {\\n  yield 'Hello World';\\n  console.log('Re-entered');\\n}\\n```\\n\\n在前面的代码中，`Generator`通过`yield`一个字符串`Hello World`暂停当前函数的执行。当`Generator`恢复时，执行将从下列语句开始：\\n\\n```javascript\\nconsole.log('Re-entered');\\n```\\n\\n`makeGenerator()`函数本质上是一个工厂，它在被调用时返回一个新的`Generator`对象：\\n\\n```javascript\\nconst gen = makeGenerator();\\n```\\n\\n生成器对象的最重要的方法是`next()`，它用于启动/恢复`Generator`的执行，并返回如下形式的对象：\\n\\n```\\n{\\n  value: <yielded value>\\n  done: <true if the execution reached the end>\\n}\\n```\\n\\n这个对象包含`Generator` `yield`的值和一个指示`Generator`是否已经完成执行的符号。\\n\\n### 一个简单的例子\\n为了演示`Generator`，我们来创建一个名为`fruitGenerator.js`的新模块：\\n\\n```javascript\\nfunction* fruitGenerator() {\\n  yield 'apple';\\n  yield 'orange';\\n  return 'watermelon';\\n}\\nconst newFruitGenerator = fruitGenerator();\\nconsole.log(newFruitGenerator.next()); // [1]\\nconsole.log(newFruitGenerator.next()); // [2]\\nconsole.log(newFruitGenerator.next()); // [3]\\n```\\n\\n前面的代码将打印下面的输出：\\n\\n```\\n{ value: 'apple', done: false }\\n{ value: 'orange', done: false }\\n{ value: 'watermelon', done: true }\\n```\\n\\n我们可以这么解释上述现象：\\n\\n* 第一次调用`newFruitGenerator.next()`时，`Generator`函数开始执行，直到达到第一个`yield`语句为止，该命令暂停`Generator`函数执行，并将值`apple`返回给调用者。\\n* 在第二次调用`newFruitGenerator.next()`时，`Generator`函数恢复执行，从第二个`yield`语句开始，这又使得执行暂停，同时将`orange`返回给调用者。\\n* `newFruitGenerator.next()`的最后一次调用导致`Generator`函数的执行从其最后的`yield`恢复，一个返回语句，它终止`Generator`函数，返回`watermelon`，并将结果对象中的`done`属性设置为`true`。\\n\\n### Generators作为迭代器\\n为了更好地理解为什么`Generator`函数对实现迭代器非常有用，我们来构建一个例子。在我们将调用`iteratorGenerator.js`的新模块中，我们编写下面的代码：\\n\\n```javascript\\nfunction* iteratorGenerator(arr) {\\n  for (let i = 0; i < arr.length; i++) {\\n    yield arr[i];\\n  }\\n}\\nconst iterator = iteratorGenerator(['apple', 'orange', 'watermelon']);\\nlet currentItem = iterator.next();\\nwhile (!currentItem.done) {\\n  console.log(currentItem.value);\\n  currentItem = iterator.next();\\n}\\n```\\n\\n此代码应按如下所示打印数组中的元素：\\n\\n```\\napple\\norange\\nwatermelon\\n```\\n\\n在这个例子中，每次我们调用`iterator.next()`时，我们都会恢复`Generator`函数的`for`循环，通过`yield`数组中的下一个项来运行另一个循环。这演示了如何在函数调用过程中维护`Generator`的状态。当继续执行时，循环和所有变量的值与`Generator`函数执行暂停时的状态完全相同。\\n\\n### 传值给Generators\\n现在我们继续研究`Generator`的基本功能，首先学习如何将值传递回`Generator`函数。这其实很简单，我们需要做的只是为`next()`方法提供一个参数，并且该值将作为`Generator`函数内的`yield`语句的返回值提供。\\n\\n为了展示这一点，我们来创建一个新的简单模块：\\n\\n```javascript\\nfunction* twoWayGenerator() {\\n  const what = yield null;\\n  console.log('Hello ' + what);\\n}\\nconst twoWay = twoWayGenerator();\\ntwoWay.next();\\ntwoWay.next('world');\\n```\\n\\n当执行时，前面的代码会输出`Hello world`。我们做如下的解释：\\n\\n* 第一次调用`next()`方法时，`Generator`函数到达第一个`yield`语句，然后暂停。\\n* 当`next('world')`被调用时，`Generator`函数从上次停止的位置，也就是上次的`yield`语句点恢复，但是这次我们有一个值传递到`Generator`函数。这个值将被赋值到`what`变量。生成器然后执行`console.log()`指令并终止。\\n\\n用类似的方式，我们可以强制`Generator`函数抛出异常。这可以通过使用`Generator`函数的`throw`方法来实现，如下例所示：\\n\\n```javascript\\nconst twoWay = twoWayGenerator();\\ntwoWay.next();\\ntwoWay.throw(new Error());\\n```\\n\\n在这个最后这段代码，`twoWayGenerator()`函数将在`yield`函数返回的时候抛出异常。这就好像从`Generator`函数内部抛出了一个异常一样，这意味着它可以像使用`try ... catch`块一样进行捕获和处理异常。\\n\\n### Generator实现异步控制流\\n你一定想知道`Generator`函数如何帮助我们处理异步操作。我们可以通过创建一个接受`Generator`函数作为参数的特殊函数来演示这一点，并允许我们在`Generator`函数内部使用异步代码。这个函数在异步操作完成时要注意恢复`Generator`函数的执行。我们将调用这个函数`asyncFlow()`：\\n\\n```javascript\\nfunction asyncFlow(generatorFunction) {\\n  function callback(err) {\\n    if (err) {\\n      return generator.throw(err);\\n    }\\n    const results = [].slice.call(arguments, 1);\\n    generator.next(results.length > 1 ? results : results[0]);\\n  }\\n  const generator = generatorFunction(callback);\\n  generator.next();\\n}\\n```\\n\\n前面的函数取一个`Generator`函数作为输入，然后立即调用：\\n\\n```javascript\\nconst generator = generatorFunction(callback);\\ngenerator.next();\\n```\\n\\n`generatorFunction()`接受一个特殊的回调函数作为参数，当`generator.throw()`如果接收到一个错误，便立即返回。另外，通过将在回调函数中接收的`results`传值回`Generator`函数继续`Generator`函数的执行:\\n\\n```javascript\\nif (err) {\\n  return generator.throw(err);\\n}\\nconst results = [].slice.call(arguments, 1);\\ngenerator.next(results.length > 1 ? results : results[0]);\\n```\\n\\n为了说明这个简单的辅助函数的强大，我们创建一个叫做`clone.js`的新模块，这个模块只是创建它本身的克隆。粘贴我们刚才创建的`asyncFlow()`函数，核心代码如下：\\n\\n```javascript\\nconst fs = require('fs');\\nconst path = require('path');\\nasyncFlow(function*(callback) {\\n  const fileName = path.basename(__filename);\\n  const myself = yield fs.readFile(fileName, 'utf8', callback);\\n  yield fs.writeFile(`clone_of_${filename}`, myself, callback);\\n  console.log('Clone created');\\n});\\n```\\n\\n明显地，有了`asyncFlow()`函数的帮助，我们可以像我们书写同步阻塞函数一样用同步的方式来书写异步代码了。并且这个结果背后的原理显得很清楚。一旦异步操作结束，传递给每个异步函数的回调函数将继续`Generator`函数的执行。没有什么复杂的，但是结果确实很令人意外。\\n\\n这个技术有其他两个变化，一个是`Promise`的使用，另外一个则是`thunks`。\\n\\n> 在基于Generator的控制流中使用的thunk只是一个简单的函数，它除了回调之外，部分地应用了原始函数的所有参数。返回值是另一个只接受回调作为参数的函数。例如，fs.readFile（）的thunkified版本如下所示：\\n\\n```javascript\\nfunction readFileThunk(filename, options) {\\n  return function(callback) {\\n    fs.readFile(filename, options, callback);\\n  }\\n}\\n```\\n\\n`thunk`和`Promise`都允许我们创建不需要回调的`Generator`函数作为参数传递，例如，使用`thunk`的`asyncFlow()`版本如下：\\n\\n```javascript\\nfunction asyncFlowWithThunks(generatorFunction) {\\n  function callback(err) {\\n    if (err) {\\n      return generator.throw(err);\\n    }\\n    const results = [].slice.call(arguments, 1);\\n    const thunk = generator.next(results.length > 1 ? results : results[0]).value;\\n    thunk && thunk(callback);\\n  }\\n  const generator = generatorFunction();\\n  const thunk = generator.next().value;\\n  thunk && thunk(callback);\\n}\\n```\\n\\n这个技巧是读取`generator.next()`的返回值，返回值中包含`thunk`。下一步是通过注入特殊的回调函数调用`thunk`本身。这允许我们写下面的代码：\\n\\n```javascript\\nasyncFlowWithThunk(function*() {\\n  const fileName = path.basename(__filename);\\n  const myself = yield readFileThunk(__filename, 'utf8');\\n  yield writeFileThunk(`clone_of_${fileName}`, myself);\\n  console.log(\\\"Clone created\\\")\\n});\\n```\\n\\n### 使用co的基于Gernator的控制流\\n你应该已经猜到了，`Node.js`生态系统会借助`Generator`函数来提供一些处理异步控制流的解决方案，例如，[suspend](https://npm/js.org/package/suspend)是其中一个最老的支持`Promise`、`thunks`和`Node.js`风格回调函数和正常风格的回调函数的 库。还有，大部分我们之前分析的`Promise`库都提供工具函数使得`Generator`和`Promise`可以一起使用。\\n\\n我们选择[co](https://npmjs.org/package/co)作为本章节的例子。它支持很多类型的`yieldables`，其中一些是：\\n\\n* `Thunks`\\n* `Promises`\\n* `Arrays`(并行执行)\\n* `Objects`(并行执行)\\n* `Generators`(委托)\\n* `Generator`函数(委托)\\n\\n还有很多框架或库是基于`co`生态系统的，包括以下一些：\\n\\n* `Web框架`，最流行的是[koa](https://npmjs.org/package/koa)\\n* 实现特定控制流模式的库\\n* 包装流行的`API`兼容`co`的库\\n\\n我们使用`co`重新实现我们的`Generator`版本的`Web爬虫应用程序`。\\n\\n为了将`Node.js`风格的函数转换成`thunks`，我们将会使用一个叫做[thunkify](https://npmjs.org/package/thunkify)的库。\\n\\n### 顺序执行\\n让我们通过修改`Web爬虫应用程序`的版本2开始我们对`Generator`函数和`co`的实际探索。我们要做的第一件事就是加载我们的依赖包，并生成我们要使用的函数的`thunkified`版本。这些将在`spider.js`模块的最开始进行：\\n\\n```javascript\\nconst thunkify = require('thunkify');\\nconst co = require('co');\\nconst request = thunkify(require('request'));\\nconst fs = require('fs');\\nconst mkdirp = thunkify(require('mkdirp'));\\nconst readFile = thunkify(fs.readFile);\\nconst writeFile = thunkify(fs.writeFile);\\nconst nextTick = thunkify(process.nextTick);\\n```\\n\\n看上述代码，我们可以注意到与本章前面`promisify`化的`API`的代码的一些相似之处。在这一点上，有意思的是，如果我们使用我们的`promisified`版本的函数来代替`thunkified`的版本，代码将保持完全一样，这要归功于`co`支持`thunk`和`Promise`对象作为`yieldable`对象。事实上，如果我们想，甚至可以在同一个应用程序中使用`thunk`和`Promise`，即使在同一个`Generator`函数中。就灵活性而言，这是一个巨大的优势，因为它使我们能够使用基于`Generator`函数的控制流来解决我们应用程序中的问题。\\n\\n好的，现在让我们开始将`download()`函数转换为一个`Generator`函数：\\n\\n```javascript\\nfunction* download(url, filename) {\\n  console.log(`Downloading ${url}`);\\n  const response = yield request(url);\\n  const body = response[1];\\n  yield mkdirp(path.dirname(filename));\\n  yield writeFile(filename, body);\\n  console.log(`Downloaded and saved ${url}`);\\n  return body;\\n}\\n```\\n\\n通过使用`Generator`和`co`，我们的`download()`函数变得简单多了。当我们需要做异步操作的时候，我们使用异步的`Generator`函数作为`thunk`来把之前的内容转化到`Generator`函数，并使用`yield`子句。\\n\\n然后我们开始实现我们的`spider()`函数：\\n\\n```javascript\\nfunction* spider(url, nesting) {\\n  cost filename = utilities.urlToFilename(url);\\n  let body;\\n  try {\\n    body = yield readFile(filename, 'utf8');\\n  } catch (err) {\\n    if (err.code !== 'ENOENT') {\\n      throw err;\\n    }\\n    body = yield download(url, filename);\\n  }\\n  yield spiderLinks(url, body, nesting);\\n}\\n```\\n\\n从上述代码中一个有趣的细节是我们可以使用`try...catch`语句块来处理异常。我们还可以使用`throw`来传播异常。另外一个细节是我们`yield`我们的`download()`函数，而这个函数既不是一个`thunk`，也不是一个`promisified`函数，只是另外的一个`Generator`函数。这也毫无问题，由于`co`也支持其他`Generators`作为`yieldables`。\\n\\n最后转换`spiderLinks()`，在这个函数中，我们递归下载一个网页的链接。在这个函数中使用`Generators`，显得简单多了：\\n\\n```javascript\\nfunction* spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return nextTick();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  for (let i = 0; i < links.length; i++) {\\n    yield spider(links[i], nesting - 1);\\n  }\\n}\\n```\\n\\n看上述代码。虽然顺序迭代没有什么模式可以展示。`Generator`和`co`辅助我们做了很多，方便了我们可以使用同步方式开书写异步代码。\\n\\n看最重要的部分，程序的入口：\\n\\n```javascript\\nco(function*() {\\n  try {\\n    yield spider(process.argv[2], 1);\\n    console.log(`Download complete`);\\n  } catch (err) {\\n    console.log(err);\\n  }\\n});\\n```\\n\\n这是唯一一处需要调用`co(...)`来封装的一个`Generator`。实际上，一旦我们这么做，`co`会自动封装我们传递给`yield`语句的任何`Generator`函数，并且这个过程是递归的，所以程序的剩余部分与我们是否使用`co`是完全无关的，虽然是被`co`封装在里面。\\n\\n现在应该可以运行使用`Generator`函数改写的`Web爬虫应用程序`了。\\n\\n### 并行执行\\n不幸的是，虽然`Generator`很方便地进行顺序执行，但是不能直接用来并行化执行一组任务，至少不能仅仅使用`yield`和`Generator`。之前，在种情况下我们使用的模式只是简单地依赖于一个基于回调或者`Promise`的函数，但使用了`Generator`函数后，一切会显得更简单。\\n\\n幸运的是，如果不限制并发数的并行执行，`co`已经可以通过`yield`一个`Promise`对象、`thunk`、`Generator`函数，甚至包含`Generator`函数的数组来实现。\\n\\n考虑到这一点，我们的`Web爬虫应用程序`第三版可以通过重写`spiderLinks()`函数来做如下改动：\\n\\n```javascript\\nfunction* spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return nextTick();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  const tasks = links.map(link => spider(link, nesting - 1));\\n  yield tasks;\\n}\\n```\\n\\n但是上述函数所做的只是拿到所有的任务，这些任务本质上都是通过`Generator`函数来实现异步的，如果在`co`的`thunk`内对一个包含`Generator`函数的数组使用`yield`，这些任务都会并行执行。外层的`Generator`函数会等到`yield`子句的所有异步任务并行执行后再继续执行。\\n\\n接下来我们看怎么用一个基于回调函数的方式来解决相同的并行流。我们用这种方式重写`spiderLinks()`函数：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return nextTick();\\n  }\\n  // 返回一个thunk\\n  return callback => {\\n    let completed = 0,\\n      hasErrors = false;\\n    const links = utilities.getPageLinks(currentUrl, body);\\n    if (links.length === 0) {\\n      return process.nextTick(callback);\\n    }\\n\\n    function done(err, result) {\\n      if (err && !hasErrors) {\\n        hasErrors = true;\\n        return callback(err);\\n      }\\n      if (++completed === links.length && !hasErrors) {\\n        callback();\\n      }\\n    }\\n    for (let i = 0; i < links.length; i++) {\\n      co(spider(links[i], nesting - 1)).then(done);\\n    }\\n  }\\n}\\n```\\n\\n我们使用`co`并行运行`spider()`函数，调用`Generator`函数返回了一个`Promise`对象。这样，等待`Promise`完成后调用`done()`函数。通常，基于`Generator`控制流的库都有这一功能，因此如果需要，你总是可以将一个`Generator`转换成一个基于回调或基于`Promise`的函数。\\n\\n为了并行开启多个下载任务，我们只要重用在前面定义的基于回调的并行执行的模式。我们应该也注意到我们将`spiderLinks()`转换成一个`thunk`(而不再是一个`Generator`函数)。这使得当全部并行任务完成时，我们有一个回调函数可以调用。\\n\\n> 上面讲到的是将一个Generator函数转换为一个thunk的模式，使之能够支持其他的基于回调或基于Promise的控制流算法，并可以通过同步阻塞的代码风格书写异步代码。\\n\\n### 限制并行执行\\n现在我们知道如何处理异步执行流程，应该很容易规划我们的`Web爬虫应用程序`的第四版的实现，这个版本对并发下载任务的数量施加了限制。我们有几个方案可以用来做到这一点。其中一些方案如下：\\n\\n* 使用先前实现的基于回调的`TaskQueue`类。我们只需要`thunkify`我们的`Generator`函数和其提供的回调函数即可。\\n* 使用基于`Promise`的`TaskQueue`类，并确保每个作为任务的`Generator`函数都被转换成一个返回`Promise`对象的函数。\\n* 使用`async`，`thunkify`我们打算使用的工具函数，此外还需要把我们用到的`Generator`函数转化为基于回调的模式，以便于能够被这个库较好地使用。\\n* 使用基于`co`的生态系统中的库，特别是专门为这种场景的库，如[co-limiter](https://npmjs.org/package/co-limiter)。\\n* 实现基于生产者 - 消费者模型的自定义算法，这与`co-limiter`的内部实现原理相同。\\n\\n为了学习，我们选择最后一个方案，甚至帮助我们可以更好地理解一种经常与协程(也和线程和进程)同步相关的模式。\\n\\n### 生产者 - 消费者模式\\n我们的目标是利用队列来提供固定数量的`workers`，与我们想要设置的并发级别一样多。为了实现这个算法，我们将基于本章前面定义的`TaskQueue`类改写：\\n\\n```javascript\\nclass TaskQueue {\\n  constructor(concurrency) {\\n    this.concurrency = concurrency;\\n    this.running = 0;\\n    this.taskQueue = [];\\n    this.consumerQueue = [];\\n    this.spawnWorkers(concurrency);\\n  }\\n  pushTask(task) {\\n    if (this.consumerQueue.length !== 0) {\\n      this.consumerQueue.shift()(null, task);\\n    } else {\\n      this.taskQueue.push(task);\\n    }\\n  }\\n  spawnWorkers(concurrency) {\\n    const self = this;\\n    for (let i = 0; i < concurrency; i++) {\\n      co(function*() {\\n        while (true) {\\n          const task = yield self.nextTask();\\n          yield task;\\n        }\\n      });\\n    }\\n  }\\n  nextTask() {\\n    return callback => {\\n      if (this.taskQueue.length !== 0) {\\n        return callback(null, this.taskQueue.shift());\\n      }\\n      this.consumerQueue.push(callback);\\n    }\\n  }\\n}\\n```\\n\\n让我们分析这个`TaskQueue`类的新实现。首先是在构造函数中。需要调用一次`this.spawnWorkers()`，因为这是启动`worker`的方法。\\n\\n我们的`worker`很简单，它们只是用`co()`包装的立即执行的`Generator`函数，所以每个`Generator`函数可以并行执行。在内部，每个`worker`正在运行在一个死循环（`while(true){}`）中，一直阻塞（`yield`）到新任务在队列中可用时（`yield self.nextTask()`），一旦可以执行新任务，`yield`这个异步任务直到其完成。您可能想知道我们如何能够限制并行执行，并让下一个任务在队列中处于等待状态。答案是在`nextTask()`方法中。我们来详细地看看在这个方法的原理：\\n\\n```javascript\\nnextTask() {\\n  return callback => {\\n    if (this.taskQueue.length !== 0) {\\n      return callback(null, this.taskQueue.shift());\\n    }\\n    this.consumerQueue.push(callback);\\n  }\\n}\\n```\\n\\n我们看这个函数内部发生了什么，这才是这个模式的核心：\\n\\n1. 这个方法返回一个对于`co`而言是一个合法的`yieldable`的`thunk`。\\n2. 只要`taskQueue`类生成的实例中还有下一个任务，`thunk`的回调函数会被立即调用。回调函数调用时，立马解锁一个`worker`的阻塞状态，`yield`这一个任务。\\n3. 如果队列中没有任务了，回调函数本身会被放入`consumerQueue`中。通过这种做法，我们将一个`worker`置于空闲（`idle`）的模式。一旦我们有一个新的任务来要处理，在`consumerQueue`队列中的回调函数会被调用，立马唤醒我们这一`worker`进行异步处理。\\n\\n现在，为了理解`consumerQueue`队列中的空闲`worker`是如何恢复工作的，我们需要分析`pushTask()`方法。如果当前有回调函数可用的话，`pushTask()`方法将调用`consumerQueue`队列中的第一个回调函数，从而将取消对`worker`的锁定。如果没有可用的回调函数，这意味着所有的`worker`都是工作状态，只需要添加一个新的任务到`taskQueue`任务队列中。\\n\\n在`TaskQueue`类中，`worker`充当消费者的角色，而调用`pushTask()`函数的角色可以被认为是生产者。这个模式向我们展示了一个`Generator`函数实际上可以跟一个线程或进程类似。实际上，生产者 - 消费者之间问题是研究进程间通信和同步时最常见的问题，但正如我们已经提到的那样，它对于进程和线程来说，也是一个常见的例子。\\n\\n### 限制下载任务的并发量\\n既然我们已经使用`Generator`函数和生产者 - 消费者模型实现一个限制并行算法，并且已经在`Web爬虫应用程序`第四版应用它来限制中下载任务的并发数。 首先，我们加载和初始化一个`TaskQueue`对象：\\n\\n```javascript\\nconst TaskQueue = require('./taskQueue');\\nconst downloadQueue = new TaskQueue(2);\\n```\\n\\n然后，修改`spiderLinks()`函数。和之前不限制并发的版本类似，所以这里我们只展示修改的部分，主要是通过调用新版本的`TaskQueue`类生成的实例的`pushTask()`方法来限制并行执行：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  //...\\n  return (callback) => {\\n    //...\\n    function done(err, result) {\\n      //...\\n    }\\n    links.forEach(function(link) {\\n      downloadQueue.pushTask(function*() {\\n        yield spider(link, nesting - 1);\\n        done();\\n      });\\n    });\\n  }\\n}\\n```\\n\\n在每个任务中，我们在下载完成后立即调用`done()`函数，因此我们可以计算下载了多少个链接，然后在完成下载时通知`thunk`的回调函数执行。\\n\\n## 配合Babel使用Async await新语法\\n回调函数、`Promise`和`Generator`函数都是用于处理`JavaScript`和`Node.js`异步问题的方式。正如我们所看到的，`Generator`的真正意义在于它提供了一种方式来暂停一个函数的执行，然后等待前面的任务完成后再继续执行。我们可以使用这样的特性来书写异步代码，并且让开发者用同步阻塞的代码风格来书写异步代码。等到异步操作的结果返回后才恢复当前函数的执行。\\n\\n但`Generator`函数是更多的是用来处理迭代器，然而迭代器在异步代码的使用显得有点笨重。代码可能难以理解，导致代码易读性和可维护性差。\\n\\n但在不远的将来会有一种更加简洁的语法。实际上，这个提议即将引入到`ESMASCript 2017`的规范中，这项规范定义了`async`函数语法。\\n\\n`async`函数规范引入两个关键字(`async`和`await`)到原生的`JavaScript`语言中，改进我们书写异步代码的方式。\\n\\n为了理解这项语法的用法和优势为，我们看一个简单的例子：\\n\\n```javascript\\nconst request = require('request');\\n\\nfunction getPageHtml(url) {\\n  return new Promise(function(resolve, reject) {\\n    request(url, function(error, response, body) {\\n      resolve(body);\\n    });\\n  });\\n}\\nasync function main() {\\n  const html = await getPageHtml('http://google.com');\\n  console.log(html);\\n}\\n\\nmain();\\nconsole.log('Loading...');\\n```\\n\\n在上述代码中，有两个函数：`getPageHtml`和`main`。第一个函数的作用是提取给定`URL`的一个远程网页的`HTML`文档代码。值得注意的是，这个函数返回一个`Promise`对象。\\n\\n重点在于`main`函数，因为在这里使用了`async`和`await`关键字。首先要注意的是函数要以`async`关键字为前缀。意思是这个函数执行的是异步代码并且允许它在函数体内使用`await`关键字。`await`关键字在`getPageHtml`调用之前，告诉`JavaScript`解释器在继续执行下一条指令之前，等待`getPageHtml`返回的`Promise`对象的结果。这样，`main`函数内部哪部分代码是异步的，它会等待异步代码的完成再继续执行后续操作，并且不会阻塞这段程序其余部分的正常执行。实际上，控制台会打印字符串`Loading...`，随后是Google主页的`HTML`代码。\\n\\n是不是这种方法的可读性更好并且更容易理解呢? 不幸地是，这个提议尚未定案，即使通过这个提议，我们需要等下一个版本\\n的`ECMAScript`规范出来并把它集成到`Node.js`后，才能使用这个新语法。 所以我们今天做了什么?只是漫无目的地等待?不是，当然不是！我们已经可以在我们的代码中使用`async await`语法，只要我们使用`Babel`。\\n\\n### 安装与运行Babel\\n`Babel`是一个`JavaScript`编译器(或翻译器)，能够使用语法转换器将高版本的`JavaScript`代码转换成其他`JavaScript`代码。语法转换器允许例如我们书写并使用`ES2015`，`ES2016`，`JSX`和其它的新语法，来翻译成往后兼容的代码，在`JavaScript`运行环境如浏览器或`Node.js`中都可以使用`Babel`。\\n\\n在项目中使用`npm`安装`Babel`，命令如下：\\n\\n```\\nnpm install --save-dev babel-cli\\n```\\n\\n我们还需要安装插件以支持`async await`语法的解释或翻译：\\n\\n```\\nnpm install --save-dev babel-plugin-syntax-async-functions babel-plugin-tranform-async-to-generator\\n```\\n\\n现在假设我们想运行我们之前的例子（称为`index.js`）。我们需要通过以下命令启动：\\n\\n```\\nnode_modules/.bin/babel-node --plugins \\\"syntax-async-functions,transform-async-to-generator\\\" index.js\\n```\\n\\n这样，我们使用支持`async await`的转换器动态地转换源代码。`Node.js`运行的实际是保存在内存中的往后兼容的代码。\\n\\n`Babel`也能被配置为一个代码构建工具，保存翻译或解释后的代码到本地文件系统中，便于我们部署和运行生成的代码。\\n\\n> 关于如何安装和配置Babel，可以到官方网站 https://babeljs.io 查阅相关文档。\\n\\n## 几种方式的比较\\n现在，我们应该对于怎么处理`JavaScript`的异步问题有了一个更好的认识和总结。在下面的表格中总结几大机制的优势和劣势：\\n\\n![](http://oczira72b.bkt.clouddn.com/17-11-7/55293366.jpg)\\n\\n> 值得一提的是，我们选择在本章中仅介绍处理异步控制流程的最受欢迎的解决方案，或者是广泛使用的解决方案，但是例如Fibers（ https://npmjs.org/package/fibers ）和Streamline（ https://npmjs.org/p ackage/streamline ）也是值得一看的。\\n\\n## 总结\\n在本章中，我们分析了一些处理异步控制流的方法，分析了`Promise`、`Generator`函数和即将到来的`async await`语法。\\n\\n我们学习了如何使用这些方法编写更简洁，更具有可读性的异步代码。我们讨论了这些方法的一些最重要的优点和缺点，并认识到即使它们非常有用，也需要一些时间来掌握。这就是这几种方式也没有完全取代在许多情况下仍然非常有用的回调的原因。作为一名开发人员，应该按照实际情况分析决定使用哪种解决方案。如果您正在构建执行异步操作的公共库，则应该提供易于使用的`API`，即使对于只想使用回调的开发人员也是如此。\\n\\n在下一章中，我们将探讨另一个与异步代码执行相关的机制，这也是整个`Node.js`生态系统中的另一个基本构建块：`streams`。\",\n        \"_id\": \"5a20d798b564820d22f6910a\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-12-01T04:16:24.262Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 5,\n    \"viewed\": 51,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:17:45.196] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/users/getUserInfo?userName=admin
request client ip:  ::1
request query:  {"userName":"admin"}
response time: 1
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"回复成功\",\n  \"data\": {\n    \"userName\": \"admin\",\n    \"registerTime\": \"2017-11-23T07:36:51.931Z\",\n    \"message\": []\n  }\n}"
*************** response log end ***************

[2017-12-01 12:17:45.210] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/art/updateCheckTimes
request client ip:  ::1
request body: 
{"id":"5a0e8b7949b148371be1f96e","token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxNTc2LCJleHAiOjE1MTIxNDQ3NzZ9.uKBuLKHhVqQEXpCm68cxufPp3HqLhF25sI_3iT0rBmI"}
response time: 6
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-12-01T04:16:24.253Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"# Asynchronous Control Flow Patterns with ES2015 and Beyond\\n在上一章中，我们学习了如何使用回调处理异步代码，以及如何解决如回调地狱代码等异步问题。回调是`JavaScript`和`Node.js`中的异步编程的基础，但是现在，其他替代方案已经出现。这些替代方案更复杂，以便能够以更方便的方式处理异步代码。\\n\\n在本章中，我们将探讨一些代表性的替代方案，`Promise`和`Generator`。以及`async await`，这是一种创新的语法，可在高版本的`JavaScript`中提供，其也作为`ECMAScript 2017`发行版的一部分。\\n\\n我们将看到这些替代方案如何简化处理异步控制流的方式。最后，我们将比较所有这些方法，以了解所有这些方法的所有优点和缺点，并能够明智地选择最适合我们下一个`Node.js`项目要求的方法。\\n\\n## Promise\\n我们在前面的章节中提到，`CPS风格`不是编写异步代码的唯一方法。事实上，`JavaScript`生态系统为传统的回调模式提供了有趣的替代方案。最着名的选择之一是`Promise`，特别是现在它是`ECMAScript 2015`的一部分，并且现在可以在`Node.js`中可用。\\n\\n### 什么是Promise？\\n`Promise`是一种抽象的对象，我们通常允许函数返回一个名为`Promise`的对象，它表示异步操作的最终结果。通常情况下，我们说当异步操作尚未完成时，我们说`Promise`对象处于`pending`状态，当操作成功完成时，我们说`Promise`对象处于`resolve`状态，当操作错误终止时，我们说`Promise`对象处于`reject`状态。一旦`Promise`处于`resolve`或`reject`，我们认为当前异步操作结束。\\n\\n为了接收到异步操作的正确结果或错误捕获，我们可以使用`Promise`的`then`方法：\\n\\n```javascript\\npromise.then([onFulfilled], [onRejected])\\n```\\n\\n在前面的代码中，`onFulfilled()`是一个函数，最终会收到`Promise`的正确结果，而`onRejected()`是另一个函数，它将接收产生异常的原因（如果有的话）。两个参数都是可选的。\\n\\n要了解`Promise`如何转换我们的代码，让我们考虑以下几点：\\n\\n```javascript\\nasyncOperation(arg, (err, result) => {\\n  if (err) {\\n    // 错误处理\\n  }\\n  // 正常结果处理\\n});\\n```\\n\\n`Promise`允许我们将这个典型的`CPS`代码转换成更好的结构化和更优雅的代码，如下所示：\\n\\n```javascript\\nasyncOperation(arg)\\n  .then(result => {\\n    // 错误处理\\n  }, err => {\\n    // 正常结果处理\\n  });\\n```\\n\\n`then()`方法的一个关键特征是它同步地返回另一个`Promise`对象。如果`onFulfilled()`或`onRejected()`函数中的任何一个函数返回`x`，则`then()`方法返回的`Promise`对象将如下所示：\\n\\n* 如果`x`是一个值，则这个`Promise`对象会正确处理(`resolve`)`x`\\n* 如果`x`是一个`Promise`对象或`thenable`，则会正确处理(`resolve`)`x`\\n* 如果`x`是一个异常，则会捕获异常(`reject`)`x`\\n\\n> 注：thenable是一个具有then方法的类似于Promise的对象(Promise-like)。\\n\\n这个特点使我们能够链式构建`Promise`，允许轻松排列组合我们的异步操作。另外，如果我们没有指定一个`onFulfilled()`或`onRejected()`处理程序，则正确结果或异常捕获将自动转发到`Promise`链的下一个`Promise`。例如，这允许我们在整个链中自动传播错误，直到被`onRejected()`处理程序捕获。随着`Promise`链，任务的顺序执行突然变成简单多了：\\n\\n```javascript\\nasyncOperation(arg)\\n  .then(result1 => {\\n    // 返回另一个Promise\\n    return asyncOperation(arg2);\\n  })\\n  .then(result2 => {\\n    // 返回一个值\\n    return 'done';\\n  })\\n  .then(undefined, err => {\\n    // 捕获Promise链中的异常\\n  });\\n```\\n\\n下图展示了链式`Promise`如何工作：\\n\\n![](http://oczira72b.bkt.clouddn.com/17-10-31/46370382.jpg)\\n\\n`Promise`的另一个重要特性是`onFulfilled()`和`onRejected()`函数是异步调用的，如同上述的例子，在最后那个`then`函数`resolve`一个同步的`Promise`，它也是同步的。这种模式避免了`Zalgo`（参见`Chapter2-Node.js Essential Patterns`），使我们的异步代码更加一致和稳健。\\n\\n如果在`onFulfilled()`或`onRejected()`处理程序中抛出异常（使用`throw`语句），则`then()`方法返回的`Promise`将被自动地`reject`，抛出异常作为`reject`的原因。这相对于`CPS`来说是一个巨大的优势，因为它意味着有了`Promise`，异常将在整个链中自动传播，并且`throw`语句终于可以使用。\\n\\n在以前，许多不同的库实现了`Promise`，大多数时候它们之间不兼容，这意味着不可能在使用不同`Promise`库的`thenable`链式传播错误。\\n\\n`JavaScript`社区非常努力地解决了这个限制，这些努力导致了`Promises / A +`规范的创建。该规范详细描述了`then`方法的行为，提供了一个可互兼容的基础，这使得来自不同库的`Promise`对象能够彼此兼容，开箱即用。\\n\\n有关`Promises / A +`规范的详细说明，可以参考[Promises / A + 官方网站](https://promisesaplus.com)。\\n\\n### Promise / A + 的实施\\n在`JavaScript`中以及`Node.js`中，有几个实现`Promises / A +`规范的库。以下是最受欢迎的：\\n\\n* [Bluebird](https://npmjs.org/package/bluebird)\\n* [Q](https://npmjs.org/package/q)\\n* [RSVP](https://npmjs.org/package/rsvp)\\n* [Vow](https://npmjs.org/package/vow)\\n* [When.js](https://npmjs.org/package/when)\\n* ES2015 promises\\n\\n真正区别他们的是在`Promises / A +`标准之上提供的额外功能。正如我们上述所说的那样，该标准定义了`then()`方法和`Promise`解析过程的行为，但它没有指定其他功能，例如，如何从基于回调的异步函数创建`Promise`。\\n\\n在我们的示例中，我们将使用由`ES2015`的`Promise`，因为`Promise`对象自`Node.js 4`后即可使用，而不需要任何库来实现。\\n\\n作为参考，以下是`ES2015`的`Promise`提供的API：\\n\\n`constructor`(`new Promise（function（resolve, reject）{}）`)：创建了一个新的`Promise`，它基于作为传递两个类型为函数的参数来决定`resolve`或`reject`。构造函数的参数解释如下：\\n\\n* `resolve(obj)` ：`resolve`一个`Promise`，并带上一个参数`obj`，如果`obj`是一个值，这个值就是传递的异步操作成功的结果。如果`obj`是一个`Promise`或一个`thenable`，则会进行正确处理。\\n* `reject(err)`：`reject`一个`Promise`，并带上一个参数`err`。它是`Error`对象的一个实例。\\n\\n#### Promise对象的静态方法\\n* `Promise.resolve(obj)`： 将会创建一个`resolve`的`Promise`实例\\n* `Promise.reject(err)`： 将会创建一个`reject`的`Promise`实例\\n* `Promise.all(iterable)`：返回一个新的`Promise`实例，并且在`iterable`中所\\n有`Promise`状态为`reject`时, 返回的`Promise`实例的状态会被置为`reject`，如果`iterable`中至少有一个`Promise`状态为`reject`时, 返回的`Promise`实例状态也会被置为`reject`，并且`reject`的原因是第一个被`reject`的`Promise`对象的`reject`原因。\\n* `Promise.race(iterable)`：返回一个`Promise`实例，当`iterable`中任何一个`Promise`被`resolve`或被`reject`时， 返回的`Promise`实例以同样的原因`resolve`或`reject`。\\n\\n#### Promise实例方法\\n* `Promise.then(onFulfilled, onRejected)`：这是`Promise`的基本方法。它的行为与我们之前描述的`Promises / A +`标准兼容。\\n* `Promise.catch(onRejected)`：这只是`Promise.then(undefined，onRejected)`的语法糖。\\n\\n> 值得一提的是，一些Promise实现提供了另一种机制来创建新的Promise，称为deferreds。我们不会在这里描述，因为它不是ES2015标准的一部分，但是如果您想了解更多信息，可以阅读Q文档 (https://github.com/kriskowal/q#using-deferreds) 或When.js文档 (https://github.com/cujojs/when/wiki/Deferred) 。\\n\\n### Promisifying一个Node.js回调风格的函数\\n在`JavaScript`中，并不是所有的异步函数和库都支持开箱即用的`Promise`。大多数情况下，我们必须将一个典型的基于回调的函数转换成一个返回`Promise`的函数，这个过程也被称为`promisification`。\\n\\n幸运的是，`Node.js`中使用的回调约定允许我们创建一个可重用的函数，我们通过使用`Promise`对象的构造函数来简化任何`Node.js`风格的`API`。让我们创建一个名为`promisify()`的新函数，并将其包含到`utilities.js`模块中（以便稍后在我们的`Web爬虫应用程序`中使用它）：\\n\\n```javascript\\nmodule.exports.promisify = function(callbackBasedApi) {\\n  return function promisified() {\\n    const args = [].slice.call(arguments);\\n    return new Promise((resolve, reject) => {\\n      args.push((err, result) => {\\n        if (err) {\\n          return reject(err);\\n        }\\n        if (arguments.length <= 2) {\\n          resolve(result);\\n        } else {\\n          resolve([].slice.call(arguments, 1));\\n        }\\n      });\\n      callbackBasedApi.apply(null, args);\\n    });\\n  }\\n};\\n```\\n\\n前面的函数返回另一个名为`promisified()`的函数，它表示输入中给出的`callbackBasedApi`的`promisified`版本。以下展示它是如何工作的：\\n\\n1. `promisified()`函数使用`Promise`构造函数创建一个新的`Promise`对象，并立即将其返回给调用者。\\n2. 在传递给`Promise`构造函数的函数中，我们确保传递给`callbackBasedApi`，这是一个特殊的回调函数。由于我们知道回调总是最后调用的，我们只需将回调函数附加到提供给`promisified()`函数的参数列表里（`args`）。\\n3. 在特殊的回调中，如果我们收到错误，我们立即`reject`这个`Promise`。\\n4. 如果没有收到错误，我们使用一个值或一个数组值来`resolve`这个`Promise`，具体取决于传递给回调的结果数量。\\n5. 最后，我们只需使用我们构建的参数列表调用`callbackBasedApi`。\\n\\n> 大部分的Promise已经提供了一个开箱即用的接口来将一个Node.js风格的API转换成一个返回Promise的API。例如，Q有Q.denodeify()和Q.nbind()，Bluebird有Promise.promisify()，而When.js有node.lift()。\\n\\n### 顺序执行\\n在一些必要的理论之后，我们现在准备将我们的`Web爬虫应用程序`转换为使用`Promise`的形式。让我们直接从版本2开始，直接下载一个Web网页的链接。\\n\\n在`spider.js`模块中，第一步是加载我们的`Promise`实现（我们稍后会使用它）和`Promisifying`我们打算使用的基于回调的函数：\\n\\n```javascript\\nconst utilities = require('./utilities');\\nconst request = utilities.promisify(require('request'));\\nconst mkdirp = utilities.promisify(require('mkdirp'));\\nconst fs = require('fs');\\nconst readFile = utilities.promisify(fs.readFile);\\nconst writeFile = utilities.promisify(fs.writeFile);\\n```\\n\\n现在，我们开始更改我们的`download`函数：\\n\\n```javascript\\nfunction download(url, filename) {\\n  console.log(`Downloading ${url}`);\\n  let body;\\n  return request(url)\\n    .then(response => {\\n      body = response.body;\\n      return mkdirp(path.dirname(filename));\\n    })\\n    .then(() => writeFile(filename, body))\\n    .then(() => {\\n      console.log(`Downloaded and saved: ${url}`);\\n      return body;\\n    });\\n}\\n```\\n\\n这里要注意的到的最重要的是我们也为`readFile()`返回的`Promise`注册\\n一个`onRejected()`函数，用来处理一个网页没有被下载的情况(或文件不存在)。 还有，看我们如何使用`throw`来传递`onRejected()`函数中的错误的。\\n\\n既然我们已经更改我们的`spider()`函数，我们这么修改它的调用方式：\\n\\n```javascript\\nspider(process.argv[2], 1)\\n  .then(() => console.log('Download complete'))\\n  .catch(err => console.log(err));\\n```\\n\\n注意我们是如何第一次使用`Promise`的语法糖`catch`来处理源自`spider()`函数的任何错误情况。如果我们再看看迄今为止我们所写的所有代码，那么我们会惊喜的发现，我们没有包含任何错误传播逻辑，因为我们在使用回调函数时会被迫做这样的事情。这显然是一个巨大的优势，因为它极大地减少了我们代码中的样板文件以及丢失任何异步错误的机会。\\n\\n现在，完成我们唯一缺失的`Web爬虫应用程序`的第二版的`spiderLinks()`函数，我们将在稍后实现它。\\n\\n### 顺序迭代\\n到目前为止，`Web爬虫应用程序`代码库主要是对`Promise`是什么以及如何使用的概述，展示了使用`Promise`实现顺序执行流程的简单性和优雅性。但是，我们现在考虑的代码只涉及到一组已知的异步操作的执行。所以，完成我们对顺序执行流程的探索的缺失部分是看我们如何使用`Promise`来实现迭代。同样，网络蜘蛛第二版的`spiderLinks()`函数也是一个很好的例子。\\n\\n让我们添加缺少的这一块：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  let promise = Promise.resolve();\\n  if (nesting === 0) {\\n    return promise;\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  links.forEach(link => {\\n    promise = promise.then(() => spider(link, nesting - 1));\\n  });\\n  return promise;\\n}\\n```\\n\\n为了异步迭代一个网页的全部链接，我们必须动态创建一个`Promise`的迭代链。\\n\\n1. 首先，我们定义一个空的`Promise`，`resolve`为`undefined`。这个`Promise`只是用来作为`Promise`的迭代链的起始点。 \\n2. 然后，我们通过在循环中调用链中前一个`Promise`的`then()`方法获得的新的`Promise`来更新`Promise`变量。这就是我们使用`Promise`的异步迭代模式。\\n\\n这样，循环的结束，`promise`变量会包含循环中最后一个`then()`返回的`Promise`对象，所以它只有当`Promise`的迭代链中全部`Promise`对象被`resolve`后才能被`resolve`。\\n\\n> 注：在最后调用了这个then方法来resolve这个Promise对象\\n\\n通过这个，我们已使用`Promise`对象重写了我们的`Web爬虫应用程序`。我们现在应该可以运行它了。\\n\\n### 顺序迭代模式\\n为了总结这个顺序执行的部分，让我们提取一个模式来依次遍历一组`Promise`：\\n\\n```javascript\\nlet tasks = [ /* ... */ ]\\nlet promise = Promise.resolve();\\ntasks.forEach(task => {\\n  promise = promise.then(() => {\\n    return task();\\n  });\\n});\\npromise.then(() => {\\n  // 所有任务都完成\\n});\\n```\\n\\n使用`reduce()`方法来替代`forEach()`方法，允许我们写出更为简洁的代码：\\n\\n```javascript\\nlet tasks = [ /* ... */ ]\\nlet promise = tasks.reduce((prev, task) => {\\n  return prev.then(() => {\\n    return task();\\n  });\\n}, Promise.resolve());\\n\\npromise.then(() => {\\n  //All tasks completed\\n});\\n```\\n\\n与往常一样，通过对这种模式的简单调整，我们可以将所有任务的结果收集到一个数组中，我们可以实现一个`mapping`算法，或者构建一个`filter`等等。\\n\\n> 上述这个模式使用循环动态地建立一个链式的Promise。\\n\\n### 并行执行\\n另一个适合用`Promise`的执行流程是并行执行流程。实际上，我们需要做的就是使用内置的`Promise.all()`。这个方法创造了另一个`Promise`对象，只有在输入中的所有`Promise`都`resolve`时才能`resolve`。这是一个并行执行，因为在其参数`Promise`对象的之间没有执行顺序可言。\\n\\n为了演示这一点，我们来看我们的`Web爬虫应用程序`的第三版，它将页面中的所有链接并行下载。让我们再次使用`Promise`更新`spiderLinks()`函数来实现并行流程：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return Promise.resolve();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  const promises = links.map(link => spider(link, nesting - 1));\\n  return Promise.all(promises);\\n}\\n```\\n\\n这里的模式在`elements.map()`迭代中产生一个数组，存放所有异步任务，之后便于同时启动`spider()`任务。这一次，在循环中，我们不等待以前的下载完成，然后开始一个新的下载任务：所有的下载任务在一个循环中一个接一个地开始。之后，我们利用`Promise.all()`方法，它返回一个新的`Promise`对象，当数组中的所有`Promise`对象都被`resolve`时，这个`Promise`对象将被`resolve`。换句话说，所有的下载任务完成，这正是我们想要的。\\n\\n### 限制并行执行\\n不幸的是，`ES2015`的`Promise API`并没有提供一种原生的方式来限制并发任务的数量，但是我们总是可以依靠我们所学到的有关用普通`JavaScript`来限制并发。事实上，我们在`TaskQueue`类中实现的模式可以很容易地被调整来支持返回承诺的任务。这很容易通过修改`next()`方法来完成：\\n\\n```javascript\\nclass TaskQueue {\\n  constructor(concurrency) {\\n    this.concurrency = concurrency;\\n    this.running = 0;\\n    this.queue = [];\\n  }\\n\\n  pushTask(task) {\\n    this.queue.push(task);\\n    this.next();\\n  }\\n\\n  next() {\\n    while (this.running < this.concurrency && this.queue.length) {\\n      const task = this.queue.shift();\\n      task().then(() => {\\n        this.running--;\\n        this.next();\\n      });\\n      this.running++;\\n    }\\n  }\\n}\\n```\\n\\n不同于使用一个回调函数来处理任务，我们简单地调用`Promise`的`then()`。\\n\\n让我们回到`spider.js`模块，并修改它以支持我们的新版本的`TaskQueue`类。首先，我们确保定义一个`TaskQueue`的新实例：\\n\\n```javascript\\nconst TaskQueue = require('./taskQueue');\\nconst downloadQueue = new TaskQueue(2);\\n```\\n\\n然后，是我们的`spiderLinks()`函数。这里的修改也是很简单：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return Promise.resolve();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  // 我们需要如下代码，用于创建Promise对象\\n  // 如果没有下列代码，当任务数量为0时，将永远不会resolve\\n  if (links.length === 0) {\\n    return Promise.resolve();\\n  }\\n  return new Promise((resolve, reject) => {\\n    let completed = 0;\\n    let errored = false;\\n    links.forEach(link => {\\n      let task = () => {\\n        return spider(link, nesting - 1)\\n          .then(() => {\\n            if (++completed === links.length) {\\n              resolve();\\n            }\\n          })\\n          .catch(() => {\\n            if (!errored) {\\n              errored = true;\\n              reject();\\n            }\\n          });\\n      };\\n      downloadQueue.pushTask(task);\\n    });\\n  });\\n}\\n```\\n\\n在上述代码中有几点值得我们注意的：\\n\\n* 首先，我们需要返回使用`Promise`构造函数创建的新的`Promise`对象。正如我们将看到的，这使我们能够在队列中的所有任务完成时手动`resolve`我们的`Promise`对象。\\n* 然后，我们应该看看我们如何定义任务。我们所做的是将一个`onFulfilled()`回调函数的调用添加到由`spider()`返回的`Promise`对象中，所以我们可以计算完成的下载任务的数量。当完成的下载量与当前页面中链接的数量相同时，我们知道任务已经处理完毕，所以我们可以调用外部`Promise`的`resolve()`函数。\\n\\n> Promises / A +规范规定，then()方法的onFulfilled()和onRejected()回调函数只能调用一次（仅调用onFulfilled()和onRejected()）。Promise接口的实现确保即使我们多次手动调用resolve或reject，Promise也仅可以被resolve或reject一次。\\n\\n现在，使用`Promise`的`Web爬虫应用程序`的第4版应该已经准备好了。我们可能再次注意到下载任务如何并行运行，并发数量限制为2。\\n\\n### 在公有API中暴露回调函数和Promise\\n正如我们在前面所学到的，`Promise`可以被用作回调函数的一个很好的替代品。它们使我们的代码更具可读性和易于理解。虽然`Promise`带来了许多优点，但也要求开发人员理解许多不易于理解的概念，以便正确和熟练地使用。由于这个原因和其他原因，在某些情况下，比起`Promise`来说，很多开发者更偏向于回调函数。\\n\\n现在让我们想象一下，我们想要构建一个执行异步操作的公共库。我们需要做什么？我们是创建了一个基于回调函数的`API`还是一个面向`Promise`的`API`？还是两者均有？\\n\\n这是许多知名的库所面临的问题，至少有两种方法值得一提，使我们能够提供一个多功能的`API`。\\n\\n像`request`，`redis`和`mysql`这样的库所使用的第一种方法是提供一个简单的基于回调函数的`API`，如果需要，开发人员可以选择公开函数。其中一些库提供工具函数来`Promise`化异步回调，但开发人员仍然需要以某种方式将暴露的`API`转换为能够使用`Promise`对象。\\n\\n第二种方法更透明。它还提供了一个面向回调的`API`，但它使回调参数可选。每当回调作为参数传递时，函数将正常运行，在完成时或失败时执行回调。当回调未被传递时，函数将立即返回一个`Promise`对象。这种方法有效地结合了回调函数和`Promise`，使得开发者可以在调用时选择采用什么接口，而不需要提前进行`Promise`化。许多库，如`mongoose`和`sequelize`，都支持这种方法。\\n\\n我们来看一个简单的例子。假设我们要实现一个异步执行除法的模块：\\n\\n```javascript\\nmodule.exports = function asyncDivision(dividend, divisor, cb) {\\n  return new Promise((resolve, reject) => { // [1]\\n    process.nextTick(() => {\\n      const result = dividend / divisor;\\n      if (isNaN(result) || !Number.isFinite(result)) {\\n        const error = new Error('Invalid operands');\\n        if (cb) {\\n          cb(error); // [2]\\n        }\\n        return reject(error);\\n      }\\n      if (cb) {\\n        cb(null, result); // [3]\\n      }\\n      resolve(result);\\n    });\\n  });\\n};\\n```\\n\\n该模块的代码非常简单，但是有一些值得强调的细节：\\n\\n* 首先，返回使用`Promise`的构造函数创建的新承诺。我们在构造函数参数函数内定义全部逻辑。\\n* 在发生错误的情况下，我们`reject`这个`Promise`，但如果回调函数在被调用时作为参数传递，我们也执行回调来进行错误传播。\\n* 在计算结果之后，我们`resolve`了这个`Promise`，但是如果有回调函数，我们也会将结果传播给回调函数。\\n\\n我们现在看如何用回调函数和`Promise`来使用这个模块：\\n\\n```javascript\\n// 回调函数的方式\\nasyncDivision(10, 2, (error, result) => {\\n  if (error) {\\n    return console.error(error);\\n  }\\n  console.log(result);\\n});\\n\\n// Promise化的调用方式\\nasyncDivision(22, 11)\\n  .then(result => console.log(result))\\n  .catch(error => console.error(error));\\n```\\n\\n应该很清楚的是，即将开始使用类似于上述的新模块的开发人员将很容易地选择最适合自己需求的风格，而无需在希望利用`Promise`时引入外部`promisification`功能。\\n\\n## Generators\\n`ES2015`规范引入了另外一种机制，除了其他新功能外，还可以用来简化`Node.js`应用程序的异步控制流程。我们正在谈论`Generator`，也被称为`semi-coroutines`。它们是子程序的一般化，可以有不同的入口点。在一个正常的函数中，实际上我们只能有一个入口点，这个入口点对应着函数本身的调用。`Generator`与一般函数类似，但是可以暂停（使用`yield`语句），然后在稍后继续执行。在实现迭代器时，`Generator`特别有用，因为我们已经讨论了如何使用迭代器来实现重要的异步控制流模式，如顺序执行和限制并行执行。\\n\\n### Generators基础\\n在我们探索使用`Generator`来实现异步控制流程之前，学习一些基本概念是很重要的。我们从语法开始吧。可以通过在函数关键字之后附加`*`（星号）运算符来声明`Generator`函数：\\n\\n```javascript\\nfunction* makeGenerator() {\\n  // body\\n}\\n```\\n\\n在`makeGenerator()`函数内部，我们可以使用关键字`yield`暂停执行并返回给调用者传递给它的值：\\n\\n```javascript\\nfunction* makeGenerator() {\\n  yield 'Hello World';\\n  console.log('Re-entered');\\n}\\n```\\n\\n在前面的代码中，`Generator`通过`yield`一个字符串`Hello World`暂停当前函数的执行。当`Generator`恢复时，执行将从下列语句开始：\\n\\n```javascript\\nconsole.log('Re-entered');\\n```\\n\\n`makeGenerator()`函数本质上是一个工厂，它在被调用时返回一个新的`Generator`对象：\\n\\n```javascript\\nconst gen = makeGenerator();\\n```\\n\\n生成器对象的最重要的方法是`next()`，它用于启动/恢复`Generator`的执行，并返回如下形式的对象：\\n\\n```\\n{\\n  value: <yielded value>\\n  done: <true if the execution reached the end>\\n}\\n```\\n\\n这个对象包含`Generator` `yield`的值和一个指示`Generator`是否已经完成执行的符号。\\n\\n### 一个简单的例子\\n为了演示`Generator`，我们来创建一个名为`fruitGenerator.js`的新模块：\\n\\n```javascript\\nfunction* fruitGenerator() {\\n  yield 'apple';\\n  yield 'orange';\\n  return 'watermelon';\\n}\\nconst newFruitGenerator = fruitGenerator();\\nconsole.log(newFruitGenerator.next()); // [1]\\nconsole.log(newFruitGenerator.next()); // [2]\\nconsole.log(newFruitGenerator.next()); // [3]\\n```\\n\\n前面的代码将打印下面的输出：\\n\\n```\\n{ value: 'apple', done: false }\\n{ value: 'orange', done: false }\\n{ value: 'watermelon', done: true }\\n```\\n\\n我们可以这么解释上述现象：\\n\\n* 第一次调用`newFruitGenerator.next()`时，`Generator`函数开始执行，直到达到第一个`yield`语句为止，该命令暂停`Generator`函数执行，并将值`apple`返回给调用者。\\n* 在第二次调用`newFruitGenerator.next()`时，`Generator`函数恢复执行，从第二个`yield`语句开始，这又使得执行暂停，同时将`orange`返回给调用者。\\n* `newFruitGenerator.next()`的最后一次调用导致`Generator`函数的执行从其最后的`yield`恢复，一个返回语句，它终止`Generator`函数，返回`watermelon`，并将结果对象中的`done`属性设置为`true`。\\n\\n### Generators作为迭代器\\n为了更好地理解为什么`Generator`函数对实现迭代器非常有用，我们来构建一个例子。在我们将调用`iteratorGenerator.js`的新模块中，我们编写下面的代码：\\n\\n```javascript\\nfunction* iteratorGenerator(arr) {\\n  for (let i = 0; i < arr.length; i++) {\\n    yield arr[i];\\n  }\\n}\\nconst iterator = iteratorGenerator(['apple', 'orange', 'watermelon']);\\nlet currentItem = iterator.next();\\nwhile (!currentItem.done) {\\n  console.log(currentItem.value);\\n  currentItem = iterator.next();\\n}\\n```\\n\\n此代码应按如下所示打印数组中的元素：\\n\\n```\\napple\\norange\\nwatermelon\\n```\\n\\n在这个例子中，每次我们调用`iterator.next()`时，我们都会恢复`Generator`函数的`for`循环，通过`yield`数组中的下一个项来运行另一个循环。这演示了如何在函数调用过程中维护`Generator`的状态。当继续执行时，循环和所有变量的值与`Generator`函数执行暂停时的状态完全相同。\\n\\n### 传值给Generators\\n现在我们继续研究`Generator`的基本功能，首先学习如何将值传递回`Generator`函数。这其实很简单，我们需要做的只是为`next()`方法提供一个参数，并且该值将作为`Generator`函数内的`yield`语句的返回值提供。\\n\\n为了展示这一点，我们来创建一个新的简单模块：\\n\\n```javascript\\nfunction* twoWayGenerator() {\\n  const what = yield null;\\n  console.log('Hello ' + what);\\n}\\nconst twoWay = twoWayGenerator();\\ntwoWay.next();\\ntwoWay.next('world');\\n```\\n\\n当执行时，前面的代码会输出`Hello world`。我们做如下的解释：\\n\\n* 第一次调用`next()`方法时，`Generator`函数到达第一个`yield`语句，然后暂停。\\n* 当`next('world')`被调用时，`Generator`函数从上次停止的位置，也就是上次的`yield`语句点恢复，但是这次我们有一个值传递到`Generator`函数。这个值将被赋值到`what`变量。生成器然后执行`console.log()`指令并终止。\\n\\n用类似的方式，我们可以强制`Generator`函数抛出异常。这可以通过使用`Generator`函数的`throw`方法来实现，如下例所示：\\n\\n```javascript\\nconst twoWay = twoWayGenerator();\\ntwoWay.next();\\ntwoWay.throw(new Error());\\n```\\n\\n在这个最后这段代码，`twoWayGenerator()`函数将在`yield`函数返回的时候抛出异常。这就好像从`Generator`函数内部抛出了一个异常一样，这意味着它可以像使用`try ... catch`块一样进行捕获和处理异常。\\n\\n### Generator实现异步控制流\\n你一定想知道`Generator`函数如何帮助我们处理异步操作。我们可以通过创建一个接受`Generator`函数作为参数的特殊函数来演示这一点，并允许我们在`Generator`函数内部使用异步代码。这个函数在异步操作完成时要注意恢复`Generator`函数的执行。我们将调用这个函数`asyncFlow()`：\\n\\n```javascript\\nfunction asyncFlow(generatorFunction) {\\n  function callback(err) {\\n    if (err) {\\n      return generator.throw(err);\\n    }\\n    const results = [].slice.call(arguments, 1);\\n    generator.next(results.length > 1 ? results : results[0]);\\n  }\\n  const generator = generatorFunction(callback);\\n  generator.next();\\n}\\n```\\n\\n前面的函数取一个`Generator`函数作为输入，然后立即调用：\\n\\n```javascript\\nconst generator = generatorFunction(callback);\\ngenerator.next();\\n```\\n\\n`generatorFunction()`接受一个特殊的回调函数作为参数，当`generator.throw()`如果接收到一个错误，便立即返回。另外，通过将在回调函数中接收的`results`传值回`Generator`函数继续`Generator`函数的执行:\\n\\n```javascript\\nif (err) {\\n  return generator.throw(err);\\n}\\nconst results = [].slice.call(arguments, 1);\\ngenerator.next(results.length > 1 ? results : results[0]);\\n```\\n\\n为了说明这个简单的辅助函数的强大，我们创建一个叫做`clone.js`的新模块，这个模块只是创建它本身的克隆。粘贴我们刚才创建的`asyncFlow()`函数，核心代码如下：\\n\\n```javascript\\nconst fs = require('fs');\\nconst path = require('path');\\nasyncFlow(function*(callback) {\\n  const fileName = path.basename(__filename);\\n  const myself = yield fs.readFile(fileName, 'utf8', callback);\\n  yield fs.writeFile(`clone_of_${filename}`, myself, callback);\\n  console.log('Clone created');\\n});\\n```\\n\\n明显地，有了`asyncFlow()`函数的帮助，我们可以像我们书写同步阻塞函数一样用同步的方式来书写异步代码了。并且这个结果背后的原理显得很清楚。一旦异步操作结束，传递给每个异步函数的回调函数将继续`Generator`函数的执行。没有什么复杂的，但是结果确实很令人意外。\\n\\n这个技术有其他两个变化，一个是`Promise`的使用，另外一个则是`thunks`。\\n\\n> 在基于Generator的控制流中使用的thunk只是一个简单的函数，它除了回调之外，部分地应用了原始函数的所有参数。返回值是另一个只接受回调作为参数的函数。例如，fs.readFile（）的thunkified版本如下所示：\\n\\n```javascript\\nfunction readFileThunk(filename, options) {\\n  return function(callback) {\\n    fs.readFile(filename, options, callback);\\n  }\\n}\\n```\\n\\n`thunk`和`Promise`都允许我们创建不需要回调的`Generator`函数作为参数传递，例如，使用`thunk`的`asyncFlow()`版本如下：\\n\\n```javascript\\nfunction asyncFlowWithThunks(generatorFunction) {\\n  function callback(err) {\\n    if (err) {\\n      return generator.throw(err);\\n    }\\n    const results = [].slice.call(arguments, 1);\\n    const thunk = generator.next(results.length > 1 ? results : results[0]).value;\\n    thunk && thunk(callback);\\n  }\\n  const generator = generatorFunction();\\n  const thunk = generator.next().value;\\n  thunk && thunk(callback);\\n}\\n```\\n\\n这个技巧是读取`generator.next()`的返回值，返回值中包含`thunk`。下一步是通过注入特殊的回调函数调用`thunk`本身。这允许我们写下面的代码：\\n\\n```javascript\\nasyncFlowWithThunk(function*() {\\n  const fileName = path.basename(__filename);\\n  const myself = yield readFileThunk(__filename, 'utf8');\\n  yield writeFileThunk(`clone_of_${fileName}`, myself);\\n  console.log(\\\"Clone created\\\")\\n});\\n```\\n\\n### 使用co的基于Gernator的控制流\\n你应该已经猜到了，`Node.js`生态系统会借助`Generator`函数来提供一些处理异步控制流的解决方案，例如，[suspend](https://npm/js.org/package/suspend)是其中一个最老的支持`Promise`、`thunks`和`Node.js`风格回调函数和正常风格的回调函数的 库。还有，大部分我们之前分析的`Promise`库都提供工具函数使得`Generator`和`Promise`可以一起使用。\\n\\n我们选择[co](https://npmjs.org/package/co)作为本章节的例子。它支持很多类型的`yieldables`，其中一些是：\\n\\n* `Thunks`\\n* `Promises`\\n* `Arrays`(并行执行)\\n* `Objects`(并行执行)\\n* `Generators`(委托)\\n* `Generator`函数(委托)\\n\\n还有很多框架或库是基于`co`生态系统的，包括以下一些：\\n\\n* `Web框架`，最流行的是[koa](https://npmjs.org/package/koa)\\n* 实现特定控制流模式的库\\n* 包装流行的`API`兼容`co`的库\\n\\n我们使用`co`重新实现我们的`Generator`版本的`Web爬虫应用程序`。\\n\\n为了将`Node.js`风格的函数转换成`thunks`，我们将会使用一个叫做[thunkify](https://npmjs.org/package/thunkify)的库。\\n\\n### 顺序执行\\n让我们通过修改`Web爬虫应用程序`的版本2开始我们对`Generator`函数和`co`的实际探索。我们要做的第一件事就是加载我们的依赖包，并生成我们要使用的函数的`thunkified`版本。这些将在`spider.js`模块的最开始进行：\\n\\n```javascript\\nconst thunkify = require('thunkify');\\nconst co = require('co');\\nconst request = thunkify(require('request'));\\nconst fs = require('fs');\\nconst mkdirp = thunkify(require('mkdirp'));\\nconst readFile = thunkify(fs.readFile);\\nconst writeFile = thunkify(fs.writeFile);\\nconst nextTick = thunkify(process.nextTick);\\n```\\n\\n看上述代码，我们可以注意到与本章前面`promisify`化的`API`的代码的一些相似之处。在这一点上，有意思的是，如果我们使用我们的`promisified`版本的函数来代替`thunkified`的版本，代码将保持完全一样，这要归功于`co`支持`thunk`和`Promise`对象作为`yieldable`对象。事实上，如果我们想，甚至可以在同一个应用程序中使用`thunk`和`Promise`，即使在同一个`Generator`函数中。就灵活性而言，这是一个巨大的优势，因为它使我们能够使用基于`Generator`函数的控制流来解决我们应用程序中的问题。\\n\\n好的，现在让我们开始将`download()`函数转换为一个`Generator`函数：\\n\\n```javascript\\nfunction* download(url, filename) {\\n  console.log(`Downloading ${url}`);\\n  const response = yield request(url);\\n  const body = response[1];\\n  yield mkdirp(path.dirname(filename));\\n  yield writeFile(filename, body);\\n  console.log(`Downloaded and saved ${url}`);\\n  return body;\\n}\\n```\\n\\n通过使用`Generator`和`co`，我们的`download()`函数变得简单多了。当我们需要做异步操作的时候，我们使用异步的`Generator`函数作为`thunk`来把之前的内容转化到`Generator`函数，并使用`yield`子句。\\n\\n然后我们开始实现我们的`spider()`函数：\\n\\n```javascript\\nfunction* spider(url, nesting) {\\n  cost filename = utilities.urlToFilename(url);\\n  let body;\\n  try {\\n    body = yield readFile(filename, 'utf8');\\n  } catch (err) {\\n    if (err.code !== 'ENOENT') {\\n      throw err;\\n    }\\n    body = yield download(url, filename);\\n  }\\n  yield spiderLinks(url, body, nesting);\\n}\\n```\\n\\n从上述代码中一个有趣的细节是我们可以使用`try...catch`语句块来处理异常。我们还可以使用`throw`来传播异常。另外一个细节是我们`yield`我们的`download()`函数，而这个函数既不是一个`thunk`，也不是一个`promisified`函数，只是另外的一个`Generator`函数。这也毫无问题，由于`co`也支持其他`Generators`作为`yieldables`。\\n\\n最后转换`spiderLinks()`，在这个函数中，我们递归下载一个网页的链接。在这个函数中使用`Generators`，显得简单多了：\\n\\n```javascript\\nfunction* spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return nextTick();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  for (let i = 0; i < links.length; i++) {\\n    yield spider(links[i], nesting - 1);\\n  }\\n}\\n```\\n\\n看上述代码。虽然顺序迭代没有什么模式可以展示。`Generator`和`co`辅助我们做了很多，方便了我们可以使用同步方式开书写异步代码。\\n\\n看最重要的部分，程序的入口：\\n\\n```javascript\\nco(function*() {\\n  try {\\n    yield spider(process.argv[2], 1);\\n    console.log(`Download complete`);\\n  } catch (err) {\\n    console.log(err);\\n  }\\n});\\n```\\n\\n这是唯一一处需要调用`co(...)`来封装的一个`Generator`。实际上，一旦我们这么做，`co`会自动封装我们传递给`yield`语句的任何`Generator`函数，并且这个过程是递归的，所以程序的剩余部分与我们是否使用`co`是完全无关的，虽然是被`co`封装在里面。\\n\\n现在应该可以运行使用`Generator`函数改写的`Web爬虫应用程序`了。\\n\\n### 并行执行\\n不幸的是，虽然`Generator`很方便地进行顺序执行，但是不能直接用来并行化执行一组任务，至少不能仅仅使用`yield`和`Generator`。之前，在种情况下我们使用的模式只是简单地依赖于一个基于回调或者`Promise`的函数，但使用了`Generator`函数后，一切会显得更简单。\\n\\n幸运的是，如果不限制并发数的并行执行，`co`已经可以通过`yield`一个`Promise`对象、`thunk`、`Generator`函数，甚至包含`Generator`函数的数组来实现。\\n\\n考虑到这一点，我们的`Web爬虫应用程序`第三版可以通过重写`spiderLinks()`函数来做如下改动：\\n\\n```javascript\\nfunction* spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return nextTick();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  const tasks = links.map(link => spider(link, nesting - 1));\\n  yield tasks;\\n}\\n```\\n\\n但是上述函数所做的只是拿到所有的任务，这些任务本质上都是通过`Generator`函数来实现异步的，如果在`co`的`thunk`内对一个包含`Generator`函数的数组使用`yield`，这些任务都会并行执行。外层的`Generator`函数会等到`yield`子句的所有异步任务并行执行后再继续执行。\\n\\n接下来我们看怎么用一个基于回调函数的方式来解决相同的并行流。我们用这种方式重写`spiderLinks()`函数：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return nextTick();\\n  }\\n  // 返回一个thunk\\n  return callback => {\\n    let completed = 0,\\n      hasErrors = false;\\n    const links = utilities.getPageLinks(currentUrl, body);\\n    if (links.length === 0) {\\n      return process.nextTick(callback);\\n    }\\n\\n    function done(err, result) {\\n      if (err && !hasErrors) {\\n        hasErrors = true;\\n        return callback(err);\\n      }\\n      if (++completed === links.length && !hasErrors) {\\n        callback();\\n      }\\n    }\\n    for (let i = 0; i < links.length; i++) {\\n      co(spider(links[i], nesting - 1)).then(done);\\n    }\\n  }\\n}\\n```\\n\\n我们使用`co`并行运行`spider()`函数，调用`Generator`函数返回了一个`Promise`对象。这样，等待`Promise`完成后调用`done()`函数。通常，基于`Generator`控制流的库都有这一功能，因此如果需要，你总是可以将一个`Generator`转换成一个基于回调或基于`Promise`的函数。\\n\\n为了并行开启多个下载任务，我们只要重用在前面定义的基于回调的并行执行的模式。我们应该也注意到我们将`spiderLinks()`转换成一个`thunk`(而不再是一个`Generator`函数)。这使得当全部并行任务完成时，我们有一个回调函数可以调用。\\n\\n> 上面讲到的是将一个Generator函数转换为一个thunk的模式，使之能够支持其他的基于回调或基于Promise的控制流算法，并可以通过同步阻塞的代码风格书写异步代码。\\n\\n### 限制并行执行\\n现在我们知道如何处理异步执行流程，应该很容易规划我们的`Web爬虫应用程序`的第四版的实现，这个版本对并发下载任务的数量施加了限制。我们有几个方案可以用来做到这一点。其中一些方案如下：\\n\\n* 使用先前实现的基于回调的`TaskQueue`类。我们只需要`thunkify`我们的`Generator`函数和其提供的回调函数即可。\\n* 使用基于`Promise`的`TaskQueue`类，并确保每个作为任务的`Generator`函数都被转换成一个返回`Promise`对象的函数。\\n* 使用`async`，`thunkify`我们打算使用的工具函数，此外还需要把我们用到的`Generator`函数转化为基于回调的模式，以便于能够被这个库较好地使用。\\n* 使用基于`co`的生态系统中的库，特别是专门为这种场景的库，如[co-limiter](https://npmjs.org/package/co-limiter)。\\n* 实现基于生产者 - 消费者模型的自定义算法，这与`co-limiter`的内部实现原理相同。\\n\\n为了学习，我们选择最后一个方案，甚至帮助我们可以更好地理解一种经常与协程(也和线程和进程)同步相关的模式。\\n\\n### 生产者 - 消费者模式\\n我们的目标是利用队列来提供固定数量的`workers`，与我们想要设置的并发级别一样多。为了实现这个算法，我们将基于本章前面定义的`TaskQueue`类改写：\\n\\n```javascript\\nclass TaskQueue {\\n  constructor(concurrency) {\\n    this.concurrency = concurrency;\\n    this.running = 0;\\n    this.taskQueue = [];\\n    this.consumerQueue = [];\\n    this.spawnWorkers(concurrency);\\n  }\\n  pushTask(task) {\\n    if (this.consumerQueue.length !== 0) {\\n      this.consumerQueue.shift()(null, task);\\n    } else {\\n      this.taskQueue.push(task);\\n    }\\n  }\\n  spawnWorkers(concurrency) {\\n    const self = this;\\n    for (let i = 0; i < concurrency; i++) {\\n      co(function*() {\\n        while (true) {\\n          const task = yield self.nextTask();\\n          yield task;\\n        }\\n      });\\n    }\\n  }\\n  nextTask() {\\n    return callback => {\\n      if (this.taskQueue.length !== 0) {\\n        return callback(null, this.taskQueue.shift());\\n      }\\n      this.consumerQueue.push(callback);\\n    }\\n  }\\n}\\n```\\n\\n让我们分析这个`TaskQueue`类的新实现。首先是在构造函数中。需要调用一次`this.spawnWorkers()`，因为这是启动`worker`的方法。\\n\\n我们的`worker`很简单，它们只是用`co()`包装的立即执行的`Generator`函数，所以每个`Generator`函数可以并行执行。在内部，每个`worker`正在运行在一个死循环（`while(true){}`）中，一直阻塞（`yield`）到新任务在队列中可用时（`yield self.nextTask()`），一旦可以执行新任务，`yield`这个异步任务直到其完成。您可能想知道我们如何能够限制并行执行，并让下一个任务在队列中处于等待状态。答案是在`nextTask()`方法中。我们来详细地看看在这个方法的原理：\\n\\n```javascript\\nnextTask() {\\n  return callback => {\\n    if (this.taskQueue.length !== 0) {\\n      return callback(null, this.taskQueue.shift());\\n    }\\n    this.consumerQueue.push(callback);\\n  }\\n}\\n```\\n\\n我们看这个函数内部发生了什么，这才是这个模式的核心：\\n\\n1. 这个方法返回一个对于`co`而言是一个合法的`yieldable`的`thunk`。\\n2. 只要`taskQueue`类生成的实例中还有下一个任务，`thunk`的回调函数会被立即调用。回调函数调用时，立马解锁一个`worker`的阻塞状态，`yield`这一个任务。\\n3. 如果队列中没有任务了，回调函数本身会被放入`consumerQueue`中。通过这种做法，我们将一个`worker`置于空闲（`idle`）的模式。一旦我们有一个新的任务来要处理，在`consumerQueue`队列中的回调函数会被调用，立马唤醒我们这一`worker`进行异步处理。\\n\\n现在，为了理解`consumerQueue`队列中的空闲`worker`是如何恢复工作的，我们需要分析`pushTask()`方法。如果当前有回调函数可用的话，`pushTask()`方法将调用`consumerQueue`队列中的第一个回调函数，从而将取消对`worker`的锁定。如果没有可用的回调函数，这意味着所有的`worker`都是工作状态，只需要添加一个新的任务到`taskQueue`任务队列中。\\n\\n在`TaskQueue`类中，`worker`充当消费者的角色，而调用`pushTask()`函数的角色可以被认为是生产者。这个模式向我们展示了一个`Generator`函数实际上可以跟一个线程或进程类似。实际上，生产者 - 消费者之间问题是研究进程间通信和同步时最常见的问题，但正如我们已经提到的那样，它对于进程和线程来说，也是一个常见的例子。\\n\\n### 限制下载任务的并发量\\n既然我们已经使用`Generator`函数和生产者 - 消费者模型实现一个限制并行算法，并且已经在`Web爬虫应用程序`第四版应用它来限制中下载任务的并发数。 首先，我们加载和初始化一个`TaskQueue`对象：\\n\\n```javascript\\nconst TaskQueue = require('./taskQueue');\\nconst downloadQueue = new TaskQueue(2);\\n```\\n\\n然后，修改`spiderLinks()`函数。和之前不限制并发的版本类似，所以这里我们只展示修改的部分，主要是通过调用新版本的`TaskQueue`类生成的实例的`pushTask()`方法来限制并行执行：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  //...\\n  return (callback) => {\\n    //...\\n    function done(err, result) {\\n      //...\\n    }\\n    links.forEach(function(link) {\\n      downloadQueue.pushTask(function*() {\\n        yield spider(link, nesting - 1);\\n        done();\\n      });\\n    });\\n  }\\n}\\n```\\n\\n在每个任务中，我们在下载完成后立即调用`done()`函数，因此我们可以计算下载了多少个链接，然后在完成下载时通知`thunk`的回调函数执行。\\n\\n## 配合Babel使用Async await新语法\\n回调函数、`Promise`和`Generator`函数都是用于处理`JavaScript`和`Node.js`异步问题的方式。正如我们所看到的，`Generator`的真正意义在于它提供了一种方式来暂停一个函数的执行，然后等待前面的任务完成后再继续执行。我们可以使用这样的特性来书写异步代码，并且让开发者用同步阻塞的代码风格来书写异步代码。等到异步操作的结果返回后才恢复当前函数的执行。\\n\\n但`Generator`函数是更多的是用来处理迭代器，然而迭代器在异步代码的使用显得有点笨重。代码可能难以理解，导致代码易读性和可维护性差。\\n\\n但在不远的将来会有一种更加简洁的语法。实际上，这个提议即将引入到`ESMASCript 2017`的规范中，这项规范定义了`async`函数语法。\\n\\n`async`函数规范引入两个关键字(`async`和`await`)到原生的`JavaScript`语言中，改进我们书写异步代码的方式。\\n\\n为了理解这项语法的用法和优势为，我们看一个简单的例子：\\n\\n```javascript\\nconst request = require('request');\\n\\nfunction getPageHtml(url) {\\n  return new Promise(function(resolve, reject) {\\n    request(url, function(error, response, body) {\\n      resolve(body);\\n    });\\n  });\\n}\\nasync function main() {\\n  const html = await getPageHtml('http://google.com');\\n  console.log(html);\\n}\\n\\nmain();\\nconsole.log('Loading...');\\n```\\n\\n在上述代码中，有两个函数：`getPageHtml`和`main`。第一个函数的作用是提取给定`URL`的一个远程网页的`HTML`文档代码。值得注意的是，这个函数返回一个`Promise`对象。\\n\\n重点在于`main`函数，因为在这里使用了`async`和`await`关键字。首先要注意的是函数要以`async`关键字为前缀。意思是这个函数执行的是异步代码并且允许它在函数体内使用`await`关键字。`await`关键字在`getPageHtml`调用之前，告诉`JavaScript`解释器在继续执行下一条指令之前，等待`getPageHtml`返回的`Promise`对象的结果。这样，`main`函数内部哪部分代码是异步的，它会等待异步代码的完成再继续执行后续操作，并且不会阻塞这段程序其余部分的正常执行。实际上，控制台会打印字符串`Loading...`，随后是Google主页的`HTML`代码。\\n\\n是不是这种方法的可读性更好并且更容易理解呢? 不幸地是，这个提议尚未定案，即使通过这个提议，我们需要等下一个版本\\n的`ECMAScript`规范出来并把它集成到`Node.js`后，才能使用这个新语法。 所以我们今天做了什么?只是漫无目的地等待?不是，当然不是！我们已经可以在我们的代码中使用`async await`语法，只要我们使用`Babel`。\\n\\n### 安装与运行Babel\\n`Babel`是一个`JavaScript`编译器(或翻译器)，能够使用语法转换器将高版本的`JavaScript`代码转换成其他`JavaScript`代码。语法转换器允许例如我们书写并使用`ES2015`，`ES2016`，`JSX`和其它的新语法，来翻译成往后兼容的代码，在`JavaScript`运行环境如浏览器或`Node.js`中都可以使用`Babel`。\\n\\n在项目中使用`npm`安装`Babel`，命令如下：\\n\\n```\\nnpm install --save-dev babel-cli\\n```\\n\\n我们还需要安装插件以支持`async await`语法的解释或翻译：\\n\\n```\\nnpm install --save-dev babel-plugin-syntax-async-functions babel-plugin-tranform-async-to-generator\\n```\\n\\n现在假设我们想运行我们之前的例子（称为`index.js`）。我们需要通过以下命令启动：\\n\\n```\\nnode_modules/.bin/babel-node --plugins \\\"syntax-async-functions,transform-async-to-generator\\\" index.js\\n```\\n\\n这样，我们使用支持`async await`的转换器动态地转换源代码。`Node.js`运行的实际是保存在内存中的往后兼容的代码。\\n\\n`Babel`也能被配置为一个代码构建工具，保存翻译或解释后的代码到本地文件系统中，便于我们部署和运行生成的代码。\\n\\n> 关于如何安装和配置Babel，可以到官方网站 https://babeljs.io 查阅相关文档。\\n\\n## 几种方式的比较\\n现在，我们应该对于怎么处理`JavaScript`的异步问题有了一个更好的认识和总结。在下面的表格中总结几大机制的优势和劣势：\\n\\n![](http://oczira72b.bkt.clouddn.com/17-11-7/55293366.jpg)\\n\\n> 值得一提的是，我们选择在本章中仅介绍处理异步控制流程的最受欢迎的解决方案，或者是广泛使用的解决方案，但是例如Fibers（ https://npmjs.org/package/fibers ）和Streamline（ https://npmjs.org/p ackage/streamline ）也是值得一看的。\\n\\n## 总结\\n在本章中，我们分析了一些处理异步控制流的方法，分析了`Promise`、`Generator`函数和即将到来的`async await`语法。\\n\\n我们学习了如何使用这些方法编写更简洁，更具有可读性的异步代码。我们讨论了这些方法的一些最重要的优点和缺点，并认识到即使它们非常有用，也需要一些时间来掌握。这就是这几种方式也没有完全取代在许多情况下仍然非常有用的回调的原因。作为一名开发人员，应该按照实际情况分析决定使用哪种解决方案。如果您正在构建执行异步操作的公共库，则应该提供易于使用的`API`，即使对于只想使用回调的开发人员也是如此。\\n\\n在下一章中，我们将探讨另一个与异步代码执行相关的机制，这也是整个`Node.js`生态系统中的另一个基本构建块：`streams`。\",\n        \"_id\": \"5a20d798b564820d22f6910a\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-12-01T04:16:24.262Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 5,\n    \"viewed\": 52,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:17:45.215] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/art/getArticleDetail?id=5a0e8b7949b148371be1f96e
request client ip:  ::1
request query:  {"id":"5a0e8b7949b148371be1f96e"}
response time: 7
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-12-01T04:16:24.253Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"# Asynchronous Control Flow Patterns with ES2015 and Beyond\\n在上一章中，我们学习了如何使用回调处理异步代码，以及如何解决如回调地狱代码等异步问题。回调是`JavaScript`和`Node.js`中的异步编程的基础，但是现在，其他替代方案已经出现。这些替代方案更复杂，以便能够以更方便的方式处理异步代码。\\n\\n在本章中，我们将探讨一些代表性的替代方案，`Promise`和`Generator`。以及`async await`，这是一种创新的语法，可在高版本的`JavaScript`中提供，其也作为`ECMAScript 2017`发行版的一部分。\\n\\n我们将看到这些替代方案如何简化处理异步控制流的方式。最后，我们将比较所有这些方法，以了解所有这些方法的所有优点和缺点，并能够明智地选择最适合我们下一个`Node.js`项目要求的方法。\\n\\n## Promise\\n我们在前面的章节中提到，`CPS风格`不是编写异步代码的唯一方法。事实上，`JavaScript`生态系统为传统的回调模式提供了有趣的替代方案。最着名的选择之一是`Promise`，特别是现在它是`ECMAScript 2015`的一部分，并且现在可以在`Node.js`中可用。\\n\\n### 什么是Promise？\\n`Promise`是一种抽象的对象，我们通常允许函数返回一个名为`Promise`的对象，它表示异步操作的最终结果。通常情况下，我们说当异步操作尚未完成时，我们说`Promise`对象处于`pending`状态，当操作成功完成时，我们说`Promise`对象处于`resolve`状态，当操作错误终止时，我们说`Promise`对象处于`reject`状态。一旦`Promise`处于`resolve`或`reject`，我们认为当前异步操作结束。\\n\\n为了接收到异步操作的正确结果或错误捕获，我们可以使用`Promise`的`then`方法：\\n\\n```javascript\\npromise.then([onFulfilled], [onRejected])\\n```\\n\\n在前面的代码中，`onFulfilled()`是一个函数，最终会收到`Promise`的正确结果，而`onRejected()`是另一个函数，它将接收产生异常的原因（如果有的话）。两个参数都是可选的。\\n\\n要了解`Promise`如何转换我们的代码，让我们考虑以下几点：\\n\\n```javascript\\nasyncOperation(arg, (err, result) => {\\n  if (err) {\\n    // 错误处理\\n  }\\n  // 正常结果处理\\n});\\n```\\n\\n`Promise`允许我们将这个典型的`CPS`代码转换成更好的结构化和更优雅的代码，如下所示：\\n\\n```javascript\\nasyncOperation(arg)\\n  .then(result => {\\n    // 错误处理\\n  }, err => {\\n    // 正常结果处理\\n  });\\n```\\n\\n`then()`方法的一个关键特征是它同步地返回另一个`Promise`对象。如果`onFulfilled()`或`onRejected()`函数中的任何一个函数返回`x`，则`then()`方法返回的`Promise`对象将如下所示：\\n\\n* 如果`x`是一个值，则这个`Promise`对象会正确处理(`resolve`)`x`\\n* 如果`x`是一个`Promise`对象或`thenable`，则会正确处理(`resolve`)`x`\\n* 如果`x`是一个异常，则会捕获异常(`reject`)`x`\\n\\n> 注：thenable是一个具有then方法的类似于Promise的对象(Promise-like)。\\n\\n这个特点使我们能够链式构建`Promise`，允许轻松排列组合我们的异步操作。另外，如果我们没有指定一个`onFulfilled()`或`onRejected()`处理程序，则正确结果或异常捕获将自动转发到`Promise`链的下一个`Promise`。例如，这允许我们在整个链中自动传播错误，直到被`onRejected()`处理程序捕获。随着`Promise`链，任务的顺序执行突然变成简单多了：\\n\\n```javascript\\nasyncOperation(arg)\\n  .then(result1 => {\\n    // 返回另一个Promise\\n    return asyncOperation(arg2);\\n  })\\n  .then(result2 => {\\n    // 返回一个值\\n    return 'done';\\n  })\\n  .then(undefined, err => {\\n    // 捕获Promise链中的异常\\n  });\\n```\\n\\n下图展示了链式`Promise`如何工作：\\n\\n![](http://oczira72b.bkt.clouddn.com/17-10-31/46370382.jpg)\\n\\n`Promise`的另一个重要特性是`onFulfilled()`和`onRejected()`函数是异步调用的，如同上述的例子，在最后那个`then`函数`resolve`一个同步的`Promise`，它也是同步的。这种模式避免了`Zalgo`（参见`Chapter2-Node.js Essential Patterns`），使我们的异步代码更加一致和稳健。\\n\\n如果在`onFulfilled()`或`onRejected()`处理程序中抛出异常（使用`throw`语句），则`then()`方法返回的`Promise`将被自动地`reject`，抛出异常作为`reject`的原因。这相对于`CPS`来说是一个巨大的优势，因为它意味着有了`Promise`，异常将在整个链中自动传播，并且`throw`语句终于可以使用。\\n\\n在以前，许多不同的库实现了`Promise`，大多数时候它们之间不兼容，这意味着不可能在使用不同`Promise`库的`thenable`链式传播错误。\\n\\n`JavaScript`社区非常努力地解决了这个限制，这些努力导致了`Promises / A +`规范的创建。该规范详细描述了`then`方法的行为，提供了一个可互兼容的基础，这使得来自不同库的`Promise`对象能够彼此兼容，开箱即用。\\n\\n有关`Promises / A +`规范的详细说明，可以参考[Promises / A + 官方网站](https://promisesaplus.com)。\\n\\n### Promise / A + 的实施\\n在`JavaScript`中以及`Node.js`中，有几个实现`Promises / A +`规范的库。以下是最受欢迎的：\\n\\n* [Bluebird](https://npmjs.org/package/bluebird)\\n* [Q](https://npmjs.org/package/q)\\n* [RSVP](https://npmjs.org/package/rsvp)\\n* [Vow](https://npmjs.org/package/vow)\\n* [When.js](https://npmjs.org/package/when)\\n* ES2015 promises\\n\\n真正区别他们的是在`Promises / A +`标准之上提供的额外功能。正如我们上述所说的那样，该标准定义了`then()`方法和`Promise`解析过程的行为，但它没有指定其他功能，例如，如何从基于回调的异步函数创建`Promise`。\\n\\n在我们的示例中，我们将使用由`ES2015`的`Promise`，因为`Promise`对象自`Node.js 4`后即可使用，而不需要任何库来实现。\\n\\n作为参考，以下是`ES2015`的`Promise`提供的API：\\n\\n`constructor`(`new Promise（function（resolve, reject）{}）`)：创建了一个新的`Promise`，它基于作为传递两个类型为函数的参数来决定`resolve`或`reject`。构造函数的参数解释如下：\\n\\n* `resolve(obj)` ：`resolve`一个`Promise`，并带上一个参数`obj`，如果`obj`是一个值，这个值就是传递的异步操作成功的结果。如果`obj`是一个`Promise`或一个`thenable`，则会进行正确处理。\\n* `reject(err)`：`reject`一个`Promise`，并带上一个参数`err`。它是`Error`对象的一个实例。\\n\\n#### Promise对象的静态方法\\n* `Promise.resolve(obj)`： 将会创建一个`resolve`的`Promise`实例\\n* `Promise.reject(err)`： 将会创建一个`reject`的`Promise`实例\\n* `Promise.all(iterable)`：返回一个新的`Promise`实例，并且在`iterable`中所\\n有`Promise`状态为`reject`时, 返回的`Promise`实例的状态会被置为`reject`，如果`iterable`中至少有一个`Promise`状态为`reject`时, 返回的`Promise`实例状态也会被置为`reject`，并且`reject`的原因是第一个被`reject`的`Promise`对象的`reject`原因。\\n* `Promise.race(iterable)`：返回一个`Promise`实例，当`iterable`中任何一个`Promise`被`resolve`或被`reject`时， 返回的`Promise`实例以同样的原因`resolve`或`reject`。\\n\\n#### Promise实例方法\\n* `Promise.then(onFulfilled, onRejected)`：这是`Promise`的基本方法。它的行为与我们之前描述的`Promises / A +`标准兼容。\\n* `Promise.catch(onRejected)`：这只是`Promise.then(undefined，onRejected)`的语法糖。\\n\\n> 值得一提的是，一些Promise实现提供了另一种机制来创建新的Promise，称为deferreds。我们不会在这里描述，因为它不是ES2015标准的一部分，但是如果您想了解更多信息，可以阅读Q文档 (https://github.com/kriskowal/q#using-deferreds) 或When.js文档 (https://github.com/cujojs/when/wiki/Deferred) 。\\n\\n### Promisifying一个Node.js回调风格的函数\\n在`JavaScript`中，并不是所有的异步函数和库都支持开箱即用的`Promise`。大多数情况下，我们必须将一个典型的基于回调的函数转换成一个返回`Promise`的函数，这个过程也被称为`promisification`。\\n\\n幸运的是，`Node.js`中使用的回调约定允许我们创建一个可重用的函数，我们通过使用`Promise`对象的构造函数来简化任何`Node.js`风格的`API`。让我们创建一个名为`promisify()`的新函数，并将其包含到`utilities.js`模块中（以便稍后在我们的`Web爬虫应用程序`中使用它）：\\n\\n```javascript\\nmodule.exports.promisify = function(callbackBasedApi) {\\n  return function promisified() {\\n    const args = [].slice.call(arguments);\\n    return new Promise((resolve, reject) => {\\n      args.push((err, result) => {\\n        if (err) {\\n          return reject(err);\\n        }\\n        if (arguments.length <= 2) {\\n          resolve(result);\\n        } else {\\n          resolve([].slice.call(arguments, 1));\\n        }\\n      });\\n      callbackBasedApi.apply(null, args);\\n    });\\n  }\\n};\\n```\\n\\n前面的函数返回另一个名为`promisified()`的函数，它表示输入中给出的`callbackBasedApi`的`promisified`版本。以下展示它是如何工作的：\\n\\n1. `promisified()`函数使用`Promise`构造函数创建一个新的`Promise`对象，并立即将其返回给调用者。\\n2. 在传递给`Promise`构造函数的函数中，我们确保传递给`callbackBasedApi`，这是一个特殊的回调函数。由于我们知道回调总是最后调用的，我们只需将回调函数附加到提供给`promisified()`函数的参数列表里（`args`）。\\n3. 在特殊的回调中，如果我们收到错误，我们立即`reject`这个`Promise`。\\n4. 如果没有收到错误，我们使用一个值或一个数组值来`resolve`这个`Promise`，具体取决于传递给回调的结果数量。\\n5. 最后，我们只需使用我们构建的参数列表调用`callbackBasedApi`。\\n\\n> 大部分的Promise已经提供了一个开箱即用的接口来将一个Node.js风格的API转换成一个返回Promise的API。例如，Q有Q.denodeify()和Q.nbind()，Bluebird有Promise.promisify()，而When.js有node.lift()。\\n\\n### 顺序执行\\n在一些必要的理论之后，我们现在准备将我们的`Web爬虫应用程序`转换为使用`Promise`的形式。让我们直接从版本2开始，直接下载一个Web网页的链接。\\n\\n在`spider.js`模块中，第一步是加载我们的`Promise`实现（我们稍后会使用它）和`Promisifying`我们打算使用的基于回调的函数：\\n\\n```javascript\\nconst utilities = require('./utilities');\\nconst request = utilities.promisify(require('request'));\\nconst mkdirp = utilities.promisify(require('mkdirp'));\\nconst fs = require('fs');\\nconst readFile = utilities.promisify(fs.readFile);\\nconst writeFile = utilities.promisify(fs.writeFile);\\n```\\n\\n现在，我们开始更改我们的`download`函数：\\n\\n```javascript\\nfunction download(url, filename) {\\n  console.log(`Downloading ${url}`);\\n  let body;\\n  return request(url)\\n    .then(response => {\\n      body = response.body;\\n      return mkdirp(path.dirname(filename));\\n    })\\n    .then(() => writeFile(filename, body))\\n    .then(() => {\\n      console.log(`Downloaded and saved: ${url}`);\\n      return body;\\n    });\\n}\\n```\\n\\n这里要注意的到的最重要的是我们也为`readFile()`返回的`Promise`注册\\n一个`onRejected()`函数，用来处理一个网页没有被下载的情况(或文件不存在)。 还有，看我们如何使用`throw`来传递`onRejected()`函数中的错误的。\\n\\n既然我们已经更改我们的`spider()`函数，我们这么修改它的调用方式：\\n\\n```javascript\\nspider(process.argv[2], 1)\\n  .then(() => console.log('Download complete'))\\n  .catch(err => console.log(err));\\n```\\n\\n注意我们是如何第一次使用`Promise`的语法糖`catch`来处理源自`spider()`函数的任何错误情况。如果我们再看看迄今为止我们所写的所有代码，那么我们会惊喜的发现，我们没有包含任何错误传播逻辑，因为我们在使用回调函数时会被迫做这样的事情。这显然是一个巨大的优势，因为它极大地减少了我们代码中的样板文件以及丢失任何异步错误的机会。\\n\\n现在，完成我们唯一缺失的`Web爬虫应用程序`的第二版的`spiderLinks()`函数，我们将在稍后实现它。\\n\\n### 顺序迭代\\n到目前为止，`Web爬虫应用程序`代码库主要是对`Promise`是什么以及如何使用的概述，展示了使用`Promise`实现顺序执行流程的简单性和优雅性。但是，我们现在考虑的代码只涉及到一组已知的异步操作的执行。所以，完成我们对顺序执行流程的探索的缺失部分是看我们如何使用`Promise`来实现迭代。同样，网络蜘蛛第二版的`spiderLinks()`函数也是一个很好的例子。\\n\\n让我们添加缺少的这一块：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  let promise = Promise.resolve();\\n  if (nesting === 0) {\\n    return promise;\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  links.forEach(link => {\\n    promise = promise.then(() => spider(link, nesting - 1));\\n  });\\n  return promise;\\n}\\n```\\n\\n为了异步迭代一个网页的全部链接，我们必须动态创建一个`Promise`的迭代链。\\n\\n1. 首先，我们定义一个空的`Promise`，`resolve`为`undefined`。这个`Promise`只是用来作为`Promise`的迭代链的起始点。 \\n2. 然后，我们通过在循环中调用链中前一个`Promise`的`then()`方法获得的新的`Promise`来更新`Promise`变量。这就是我们使用`Promise`的异步迭代模式。\\n\\n这样，循环的结束，`promise`变量会包含循环中最后一个`then()`返回的`Promise`对象，所以它只有当`Promise`的迭代链中全部`Promise`对象被`resolve`后才能被`resolve`。\\n\\n> 注：在最后调用了这个then方法来resolve这个Promise对象\\n\\n通过这个，我们已使用`Promise`对象重写了我们的`Web爬虫应用程序`。我们现在应该可以运行它了。\\n\\n### 顺序迭代模式\\n为了总结这个顺序执行的部分，让我们提取一个模式来依次遍历一组`Promise`：\\n\\n```javascript\\nlet tasks = [ /* ... */ ]\\nlet promise = Promise.resolve();\\ntasks.forEach(task => {\\n  promise = promise.then(() => {\\n    return task();\\n  });\\n});\\npromise.then(() => {\\n  // 所有任务都完成\\n});\\n```\\n\\n使用`reduce()`方法来替代`forEach()`方法，允许我们写出更为简洁的代码：\\n\\n```javascript\\nlet tasks = [ /* ... */ ]\\nlet promise = tasks.reduce((prev, task) => {\\n  return prev.then(() => {\\n    return task();\\n  });\\n}, Promise.resolve());\\n\\npromise.then(() => {\\n  //All tasks completed\\n});\\n```\\n\\n与往常一样，通过对这种模式的简单调整，我们可以将所有任务的结果收集到一个数组中，我们可以实现一个`mapping`算法，或者构建一个`filter`等等。\\n\\n> 上述这个模式使用循环动态地建立一个链式的Promise。\\n\\n### 并行执行\\n另一个适合用`Promise`的执行流程是并行执行流程。实际上，我们需要做的就是使用内置的`Promise.all()`。这个方法创造了另一个`Promise`对象，只有在输入中的所有`Promise`都`resolve`时才能`resolve`。这是一个并行执行，因为在其参数`Promise`对象的之间没有执行顺序可言。\\n\\n为了演示这一点，我们来看我们的`Web爬虫应用程序`的第三版，它将页面中的所有链接并行下载。让我们再次使用`Promise`更新`spiderLinks()`函数来实现并行流程：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return Promise.resolve();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  const promises = links.map(link => spider(link, nesting - 1));\\n  return Promise.all(promises);\\n}\\n```\\n\\n这里的模式在`elements.map()`迭代中产生一个数组，存放所有异步任务，之后便于同时启动`spider()`任务。这一次，在循环中，我们不等待以前的下载完成，然后开始一个新的下载任务：所有的下载任务在一个循环中一个接一个地开始。之后，我们利用`Promise.all()`方法，它返回一个新的`Promise`对象，当数组中的所有`Promise`对象都被`resolve`时，这个`Promise`对象将被`resolve`。换句话说，所有的下载任务完成，这正是我们想要的。\\n\\n### 限制并行执行\\n不幸的是，`ES2015`的`Promise API`并没有提供一种原生的方式来限制并发任务的数量，但是我们总是可以依靠我们所学到的有关用普通`JavaScript`来限制并发。事实上，我们在`TaskQueue`类中实现的模式可以很容易地被调整来支持返回承诺的任务。这很容易通过修改`next()`方法来完成：\\n\\n```javascript\\nclass TaskQueue {\\n  constructor(concurrency) {\\n    this.concurrency = concurrency;\\n    this.running = 0;\\n    this.queue = [];\\n  }\\n\\n  pushTask(task) {\\n    this.queue.push(task);\\n    this.next();\\n  }\\n\\n  next() {\\n    while (this.running < this.concurrency && this.queue.length) {\\n      const task = this.queue.shift();\\n      task().then(() => {\\n        this.running--;\\n        this.next();\\n      });\\n      this.running++;\\n    }\\n  }\\n}\\n```\\n\\n不同于使用一个回调函数来处理任务，我们简单地调用`Promise`的`then()`。\\n\\n让我们回到`spider.js`模块，并修改它以支持我们的新版本的`TaskQueue`类。首先，我们确保定义一个`TaskQueue`的新实例：\\n\\n```javascript\\nconst TaskQueue = require('./taskQueue');\\nconst downloadQueue = new TaskQueue(2);\\n```\\n\\n然后，是我们的`spiderLinks()`函数。这里的修改也是很简单：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return Promise.resolve();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  // 我们需要如下代码，用于创建Promise对象\\n  // 如果没有下列代码，当任务数量为0时，将永远不会resolve\\n  if (links.length === 0) {\\n    return Promise.resolve();\\n  }\\n  return new Promise((resolve, reject) => {\\n    let completed = 0;\\n    let errored = false;\\n    links.forEach(link => {\\n      let task = () => {\\n        return spider(link, nesting - 1)\\n          .then(() => {\\n            if (++completed === links.length) {\\n              resolve();\\n            }\\n          })\\n          .catch(() => {\\n            if (!errored) {\\n              errored = true;\\n              reject();\\n            }\\n          });\\n      };\\n      downloadQueue.pushTask(task);\\n    });\\n  });\\n}\\n```\\n\\n在上述代码中有几点值得我们注意的：\\n\\n* 首先，我们需要返回使用`Promise`构造函数创建的新的`Promise`对象。正如我们将看到的，这使我们能够在队列中的所有任务完成时手动`resolve`我们的`Promise`对象。\\n* 然后，我们应该看看我们如何定义任务。我们所做的是将一个`onFulfilled()`回调函数的调用添加到由`spider()`返回的`Promise`对象中，所以我们可以计算完成的下载任务的数量。当完成的下载量与当前页面中链接的数量相同时，我们知道任务已经处理完毕，所以我们可以调用外部`Promise`的`resolve()`函数。\\n\\n> Promises / A +规范规定，then()方法的onFulfilled()和onRejected()回调函数只能调用一次（仅调用onFulfilled()和onRejected()）。Promise接口的实现确保即使我们多次手动调用resolve或reject，Promise也仅可以被resolve或reject一次。\\n\\n现在，使用`Promise`的`Web爬虫应用程序`的第4版应该已经准备好了。我们可能再次注意到下载任务如何并行运行，并发数量限制为2。\\n\\n### 在公有API中暴露回调函数和Promise\\n正如我们在前面所学到的，`Promise`可以被用作回调函数的一个很好的替代品。它们使我们的代码更具可读性和易于理解。虽然`Promise`带来了许多优点，但也要求开发人员理解许多不易于理解的概念，以便正确和熟练地使用。由于这个原因和其他原因，在某些情况下，比起`Promise`来说，很多开发者更偏向于回调函数。\\n\\n现在让我们想象一下，我们想要构建一个执行异步操作的公共库。我们需要做什么？我们是创建了一个基于回调函数的`API`还是一个面向`Promise`的`API`？还是两者均有？\\n\\n这是许多知名的库所面临的问题，至少有两种方法值得一提，使我们能够提供一个多功能的`API`。\\n\\n像`request`，`redis`和`mysql`这样的库所使用的第一种方法是提供一个简单的基于回调函数的`API`，如果需要，开发人员可以选择公开函数。其中一些库提供工具函数来`Promise`化异步回调，但开发人员仍然需要以某种方式将暴露的`API`转换为能够使用`Promise`对象。\\n\\n第二种方法更透明。它还提供了一个面向回调的`API`，但它使回调参数可选。每当回调作为参数传递时，函数将正常运行，在完成时或失败时执行回调。当回调未被传递时，函数将立即返回一个`Promise`对象。这种方法有效地结合了回调函数和`Promise`，使得开发者可以在调用时选择采用什么接口，而不需要提前进行`Promise`化。许多库，如`mongoose`和`sequelize`，都支持这种方法。\\n\\n我们来看一个简单的例子。假设我们要实现一个异步执行除法的模块：\\n\\n```javascript\\nmodule.exports = function asyncDivision(dividend, divisor, cb) {\\n  return new Promise((resolve, reject) => { // [1]\\n    process.nextTick(() => {\\n      const result = dividend / divisor;\\n      if (isNaN(result) || !Number.isFinite(result)) {\\n        const error = new Error('Invalid operands');\\n        if (cb) {\\n          cb(error); // [2]\\n        }\\n        return reject(error);\\n      }\\n      if (cb) {\\n        cb(null, result); // [3]\\n      }\\n      resolve(result);\\n    });\\n  });\\n};\\n```\\n\\n该模块的代码非常简单，但是有一些值得强调的细节：\\n\\n* 首先，返回使用`Promise`的构造函数创建的新承诺。我们在构造函数参数函数内定义全部逻辑。\\n* 在发生错误的情况下，我们`reject`这个`Promise`，但如果回调函数在被调用时作为参数传递，我们也执行回调来进行错误传播。\\n* 在计算结果之后，我们`resolve`了这个`Promise`，但是如果有回调函数，我们也会将结果传播给回调函数。\\n\\n我们现在看如何用回调函数和`Promise`来使用这个模块：\\n\\n```javascript\\n// 回调函数的方式\\nasyncDivision(10, 2, (error, result) => {\\n  if (error) {\\n    return console.error(error);\\n  }\\n  console.log(result);\\n});\\n\\n// Promise化的调用方式\\nasyncDivision(22, 11)\\n  .then(result => console.log(result))\\n  .catch(error => console.error(error));\\n```\\n\\n应该很清楚的是，即将开始使用类似于上述的新模块的开发人员将很容易地选择最适合自己需求的风格，而无需在希望利用`Promise`时引入外部`promisification`功能。\\n\\n## Generators\\n`ES2015`规范引入了另外一种机制，除了其他新功能外，还可以用来简化`Node.js`应用程序的异步控制流程。我们正在谈论`Generator`，也被称为`semi-coroutines`。它们是子程序的一般化，可以有不同的入口点。在一个正常的函数中，实际上我们只能有一个入口点，这个入口点对应着函数本身的调用。`Generator`与一般函数类似，但是可以暂停（使用`yield`语句），然后在稍后继续执行。在实现迭代器时，`Generator`特别有用，因为我们已经讨论了如何使用迭代器来实现重要的异步控制流模式，如顺序执行和限制并行执行。\\n\\n### Generators基础\\n在我们探索使用`Generator`来实现异步控制流程之前，学习一些基本概念是很重要的。我们从语法开始吧。可以通过在函数关键字之后附加`*`（星号）运算符来声明`Generator`函数：\\n\\n```javascript\\nfunction* makeGenerator() {\\n  // body\\n}\\n```\\n\\n在`makeGenerator()`函数内部，我们可以使用关键字`yield`暂停执行并返回给调用者传递给它的值：\\n\\n```javascript\\nfunction* makeGenerator() {\\n  yield 'Hello World';\\n  console.log('Re-entered');\\n}\\n```\\n\\n在前面的代码中，`Generator`通过`yield`一个字符串`Hello World`暂停当前函数的执行。当`Generator`恢复时，执行将从下列语句开始：\\n\\n```javascript\\nconsole.log('Re-entered');\\n```\\n\\n`makeGenerator()`函数本质上是一个工厂，它在被调用时返回一个新的`Generator`对象：\\n\\n```javascript\\nconst gen = makeGenerator();\\n```\\n\\n生成器对象的最重要的方法是`next()`，它用于启动/恢复`Generator`的执行，并返回如下形式的对象：\\n\\n```\\n{\\n  value: <yielded value>\\n  done: <true if the execution reached the end>\\n}\\n```\\n\\n这个对象包含`Generator` `yield`的值和一个指示`Generator`是否已经完成执行的符号。\\n\\n### 一个简单的例子\\n为了演示`Generator`，我们来创建一个名为`fruitGenerator.js`的新模块：\\n\\n```javascript\\nfunction* fruitGenerator() {\\n  yield 'apple';\\n  yield 'orange';\\n  return 'watermelon';\\n}\\nconst newFruitGenerator = fruitGenerator();\\nconsole.log(newFruitGenerator.next()); // [1]\\nconsole.log(newFruitGenerator.next()); // [2]\\nconsole.log(newFruitGenerator.next()); // [3]\\n```\\n\\n前面的代码将打印下面的输出：\\n\\n```\\n{ value: 'apple', done: false }\\n{ value: 'orange', done: false }\\n{ value: 'watermelon', done: true }\\n```\\n\\n我们可以这么解释上述现象：\\n\\n* 第一次调用`newFruitGenerator.next()`时，`Generator`函数开始执行，直到达到第一个`yield`语句为止，该命令暂停`Generator`函数执行，并将值`apple`返回给调用者。\\n* 在第二次调用`newFruitGenerator.next()`时，`Generator`函数恢复执行，从第二个`yield`语句开始，这又使得执行暂停，同时将`orange`返回给调用者。\\n* `newFruitGenerator.next()`的最后一次调用导致`Generator`函数的执行从其最后的`yield`恢复，一个返回语句，它终止`Generator`函数，返回`watermelon`，并将结果对象中的`done`属性设置为`true`。\\n\\n### Generators作为迭代器\\n为了更好地理解为什么`Generator`函数对实现迭代器非常有用，我们来构建一个例子。在我们将调用`iteratorGenerator.js`的新模块中，我们编写下面的代码：\\n\\n```javascript\\nfunction* iteratorGenerator(arr) {\\n  for (let i = 0; i < arr.length; i++) {\\n    yield arr[i];\\n  }\\n}\\nconst iterator = iteratorGenerator(['apple', 'orange', 'watermelon']);\\nlet currentItem = iterator.next();\\nwhile (!currentItem.done) {\\n  console.log(currentItem.value);\\n  currentItem = iterator.next();\\n}\\n```\\n\\n此代码应按如下所示打印数组中的元素：\\n\\n```\\napple\\norange\\nwatermelon\\n```\\n\\n在这个例子中，每次我们调用`iterator.next()`时，我们都会恢复`Generator`函数的`for`循环，通过`yield`数组中的下一个项来运行另一个循环。这演示了如何在函数调用过程中维护`Generator`的状态。当继续执行时，循环和所有变量的值与`Generator`函数执行暂停时的状态完全相同。\\n\\n### 传值给Generators\\n现在我们继续研究`Generator`的基本功能，首先学习如何将值传递回`Generator`函数。这其实很简单，我们需要做的只是为`next()`方法提供一个参数，并且该值将作为`Generator`函数内的`yield`语句的返回值提供。\\n\\n为了展示这一点，我们来创建一个新的简单模块：\\n\\n```javascript\\nfunction* twoWayGenerator() {\\n  const what = yield null;\\n  console.log('Hello ' + what);\\n}\\nconst twoWay = twoWayGenerator();\\ntwoWay.next();\\ntwoWay.next('world');\\n```\\n\\n当执行时，前面的代码会输出`Hello world`。我们做如下的解释：\\n\\n* 第一次调用`next()`方法时，`Generator`函数到达第一个`yield`语句，然后暂停。\\n* 当`next('world')`被调用时，`Generator`函数从上次停止的位置，也就是上次的`yield`语句点恢复，但是这次我们有一个值传递到`Generator`函数。这个值将被赋值到`what`变量。生成器然后执行`console.log()`指令并终止。\\n\\n用类似的方式，我们可以强制`Generator`函数抛出异常。这可以通过使用`Generator`函数的`throw`方法来实现，如下例所示：\\n\\n```javascript\\nconst twoWay = twoWayGenerator();\\ntwoWay.next();\\ntwoWay.throw(new Error());\\n```\\n\\n在这个最后这段代码，`twoWayGenerator()`函数将在`yield`函数返回的时候抛出异常。这就好像从`Generator`函数内部抛出了一个异常一样，这意味着它可以像使用`try ... catch`块一样进行捕获和处理异常。\\n\\n### Generator实现异步控制流\\n你一定想知道`Generator`函数如何帮助我们处理异步操作。我们可以通过创建一个接受`Generator`函数作为参数的特殊函数来演示这一点，并允许我们在`Generator`函数内部使用异步代码。这个函数在异步操作完成时要注意恢复`Generator`函数的执行。我们将调用这个函数`asyncFlow()`：\\n\\n```javascript\\nfunction asyncFlow(generatorFunction) {\\n  function callback(err) {\\n    if (err) {\\n      return generator.throw(err);\\n    }\\n    const results = [].slice.call(arguments, 1);\\n    generator.next(results.length > 1 ? results : results[0]);\\n  }\\n  const generator = generatorFunction(callback);\\n  generator.next();\\n}\\n```\\n\\n前面的函数取一个`Generator`函数作为输入，然后立即调用：\\n\\n```javascript\\nconst generator = generatorFunction(callback);\\ngenerator.next();\\n```\\n\\n`generatorFunction()`接受一个特殊的回调函数作为参数，当`generator.throw()`如果接收到一个错误，便立即返回。另外，通过将在回调函数中接收的`results`传值回`Generator`函数继续`Generator`函数的执行:\\n\\n```javascript\\nif (err) {\\n  return generator.throw(err);\\n}\\nconst results = [].slice.call(arguments, 1);\\ngenerator.next(results.length > 1 ? results : results[0]);\\n```\\n\\n为了说明这个简单的辅助函数的强大，我们创建一个叫做`clone.js`的新模块，这个模块只是创建它本身的克隆。粘贴我们刚才创建的`asyncFlow()`函数，核心代码如下：\\n\\n```javascript\\nconst fs = require('fs');\\nconst path = require('path');\\nasyncFlow(function*(callback) {\\n  const fileName = path.basename(__filename);\\n  const myself = yield fs.readFile(fileName, 'utf8', callback);\\n  yield fs.writeFile(`clone_of_${filename}`, myself, callback);\\n  console.log('Clone created');\\n});\\n```\\n\\n明显地，有了`asyncFlow()`函数的帮助，我们可以像我们书写同步阻塞函数一样用同步的方式来书写异步代码了。并且这个结果背后的原理显得很清楚。一旦异步操作结束，传递给每个异步函数的回调函数将继续`Generator`函数的执行。没有什么复杂的，但是结果确实很令人意外。\\n\\n这个技术有其他两个变化，一个是`Promise`的使用，另外一个则是`thunks`。\\n\\n> 在基于Generator的控制流中使用的thunk只是一个简单的函数，它除了回调之外，部分地应用了原始函数的所有参数。返回值是另一个只接受回调作为参数的函数。例如，fs.readFile（）的thunkified版本如下所示：\\n\\n```javascript\\nfunction readFileThunk(filename, options) {\\n  return function(callback) {\\n    fs.readFile(filename, options, callback);\\n  }\\n}\\n```\\n\\n`thunk`和`Promise`都允许我们创建不需要回调的`Generator`函数作为参数传递，例如，使用`thunk`的`asyncFlow()`版本如下：\\n\\n```javascript\\nfunction asyncFlowWithThunks(generatorFunction) {\\n  function callback(err) {\\n    if (err) {\\n      return generator.throw(err);\\n    }\\n    const results = [].slice.call(arguments, 1);\\n    const thunk = generator.next(results.length > 1 ? results : results[0]).value;\\n    thunk && thunk(callback);\\n  }\\n  const generator = generatorFunction();\\n  const thunk = generator.next().value;\\n  thunk && thunk(callback);\\n}\\n```\\n\\n这个技巧是读取`generator.next()`的返回值，返回值中包含`thunk`。下一步是通过注入特殊的回调函数调用`thunk`本身。这允许我们写下面的代码：\\n\\n```javascript\\nasyncFlowWithThunk(function*() {\\n  const fileName = path.basename(__filename);\\n  const myself = yield readFileThunk(__filename, 'utf8');\\n  yield writeFileThunk(`clone_of_${fileName}`, myself);\\n  console.log(\\\"Clone created\\\")\\n});\\n```\\n\\n### 使用co的基于Gernator的控制流\\n你应该已经猜到了，`Node.js`生态系统会借助`Generator`函数来提供一些处理异步控制流的解决方案，例如，[suspend](https://npm/js.org/package/suspend)是其中一个最老的支持`Promise`、`thunks`和`Node.js`风格回调函数和正常风格的回调函数的 库。还有，大部分我们之前分析的`Promise`库都提供工具函数使得`Generator`和`Promise`可以一起使用。\\n\\n我们选择[co](https://npmjs.org/package/co)作为本章节的例子。它支持很多类型的`yieldables`，其中一些是：\\n\\n* `Thunks`\\n* `Promises`\\n* `Arrays`(并行执行)\\n* `Objects`(并行执行)\\n* `Generators`(委托)\\n* `Generator`函数(委托)\\n\\n还有很多框架或库是基于`co`生态系统的，包括以下一些：\\n\\n* `Web框架`，最流行的是[koa](https://npmjs.org/package/koa)\\n* 实现特定控制流模式的库\\n* 包装流行的`API`兼容`co`的库\\n\\n我们使用`co`重新实现我们的`Generator`版本的`Web爬虫应用程序`。\\n\\n为了将`Node.js`风格的函数转换成`thunks`，我们将会使用一个叫做[thunkify](https://npmjs.org/package/thunkify)的库。\\n\\n### 顺序执行\\n让我们通过修改`Web爬虫应用程序`的版本2开始我们对`Generator`函数和`co`的实际探索。我们要做的第一件事就是加载我们的依赖包，并生成我们要使用的函数的`thunkified`版本。这些将在`spider.js`模块的最开始进行：\\n\\n```javascript\\nconst thunkify = require('thunkify');\\nconst co = require('co');\\nconst request = thunkify(require('request'));\\nconst fs = require('fs');\\nconst mkdirp = thunkify(require('mkdirp'));\\nconst readFile = thunkify(fs.readFile);\\nconst writeFile = thunkify(fs.writeFile);\\nconst nextTick = thunkify(process.nextTick);\\n```\\n\\n看上述代码，我们可以注意到与本章前面`promisify`化的`API`的代码的一些相似之处。在这一点上，有意思的是，如果我们使用我们的`promisified`版本的函数来代替`thunkified`的版本，代码将保持完全一样，这要归功于`co`支持`thunk`和`Promise`对象作为`yieldable`对象。事实上，如果我们想，甚至可以在同一个应用程序中使用`thunk`和`Promise`，即使在同一个`Generator`函数中。就灵活性而言，这是一个巨大的优势，因为它使我们能够使用基于`Generator`函数的控制流来解决我们应用程序中的问题。\\n\\n好的，现在让我们开始将`download()`函数转换为一个`Generator`函数：\\n\\n```javascript\\nfunction* download(url, filename) {\\n  console.log(`Downloading ${url}`);\\n  const response = yield request(url);\\n  const body = response[1];\\n  yield mkdirp(path.dirname(filename));\\n  yield writeFile(filename, body);\\n  console.log(`Downloaded and saved ${url}`);\\n  return body;\\n}\\n```\\n\\n通过使用`Generator`和`co`，我们的`download()`函数变得简单多了。当我们需要做异步操作的时候，我们使用异步的`Generator`函数作为`thunk`来把之前的内容转化到`Generator`函数，并使用`yield`子句。\\n\\n然后我们开始实现我们的`spider()`函数：\\n\\n```javascript\\nfunction* spider(url, nesting) {\\n  cost filename = utilities.urlToFilename(url);\\n  let body;\\n  try {\\n    body = yield readFile(filename, 'utf8');\\n  } catch (err) {\\n    if (err.code !== 'ENOENT') {\\n      throw err;\\n    }\\n    body = yield download(url, filename);\\n  }\\n  yield spiderLinks(url, body, nesting);\\n}\\n```\\n\\n从上述代码中一个有趣的细节是我们可以使用`try...catch`语句块来处理异常。我们还可以使用`throw`来传播异常。另外一个细节是我们`yield`我们的`download()`函数，而这个函数既不是一个`thunk`，也不是一个`promisified`函数，只是另外的一个`Generator`函数。这也毫无问题，由于`co`也支持其他`Generators`作为`yieldables`。\\n\\n最后转换`spiderLinks()`，在这个函数中，我们递归下载一个网页的链接。在这个函数中使用`Generators`，显得简单多了：\\n\\n```javascript\\nfunction* spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return nextTick();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  for (let i = 0; i < links.length; i++) {\\n    yield spider(links[i], nesting - 1);\\n  }\\n}\\n```\\n\\n看上述代码。虽然顺序迭代没有什么模式可以展示。`Generator`和`co`辅助我们做了很多，方便了我们可以使用同步方式开书写异步代码。\\n\\n看最重要的部分，程序的入口：\\n\\n```javascript\\nco(function*() {\\n  try {\\n    yield spider(process.argv[2], 1);\\n    console.log(`Download complete`);\\n  } catch (err) {\\n    console.log(err);\\n  }\\n});\\n```\\n\\n这是唯一一处需要调用`co(...)`来封装的一个`Generator`。实际上，一旦我们这么做，`co`会自动封装我们传递给`yield`语句的任何`Generator`函数，并且这个过程是递归的，所以程序的剩余部分与我们是否使用`co`是完全无关的，虽然是被`co`封装在里面。\\n\\n现在应该可以运行使用`Generator`函数改写的`Web爬虫应用程序`了。\\n\\n### 并行执行\\n不幸的是，虽然`Generator`很方便地进行顺序执行，但是不能直接用来并行化执行一组任务，至少不能仅仅使用`yield`和`Generator`。之前，在种情况下我们使用的模式只是简单地依赖于一个基于回调或者`Promise`的函数，但使用了`Generator`函数后，一切会显得更简单。\\n\\n幸运的是，如果不限制并发数的并行执行，`co`已经可以通过`yield`一个`Promise`对象、`thunk`、`Generator`函数，甚至包含`Generator`函数的数组来实现。\\n\\n考虑到这一点，我们的`Web爬虫应用程序`第三版可以通过重写`spiderLinks()`函数来做如下改动：\\n\\n```javascript\\nfunction* spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return nextTick();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  const tasks = links.map(link => spider(link, nesting - 1));\\n  yield tasks;\\n}\\n```\\n\\n但是上述函数所做的只是拿到所有的任务，这些任务本质上都是通过`Generator`函数来实现异步的，如果在`co`的`thunk`内对一个包含`Generator`函数的数组使用`yield`，这些任务都会并行执行。外层的`Generator`函数会等到`yield`子句的所有异步任务并行执行后再继续执行。\\n\\n接下来我们看怎么用一个基于回调函数的方式来解决相同的并行流。我们用这种方式重写`spiderLinks()`函数：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return nextTick();\\n  }\\n  // 返回一个thunk\\n  return callback => {\\n    let completed = 0,\\n      hasErrors = false;\\n    const links = utilities.getPageLinks(currentUrl, body);\\n    if (links.length === 0) {\\n      return process.nextTick(callback);\\n    }\\n\\n    function done(err, result) {\\n      if (err && !hasErrors) {\\n        hasErrors = true;\\n        return callback(err);\\n      }\\n      if (++completed === links.length && !hasErrors) {\\n        callback();\\n      }\\n    }\\n    for (let i = 0; i < links.length; i++) {\\n      co(spider(links[i], nesting - 1)).then(done);\\n    }\\n  }\\n}\\n```\\n\\n我们使用`co`并行运行`spider()`函数，调用`Generator`函数返回了一个`Promise`对象。这样，等待`Promise`完成后调用`done()`函数。通常，基于`Generator`控制流的库都有这一功能，因此如果需要，你总是可以将一个`Generator`转换成一个基于回调或基于`Promise`的函数。\\n\\n为了并行开启多个下载任务，我们只要重用在前面定义的基于回调的并行执行的模式。我们应该也注意到我们将`spiderLinks()`转换成一个`thunk`(而不再是一个`Generator`函数)。这使得当全部并行任务完成时，我们有一个回调函数可以调用。\\n\\n> 上面讲到的是将一个Generator函数转换为一个thunk的模式，使之能够支持其他的基于回调或基于Promise的控制流算法，并可以通过同步阻塞的代码风格书写异步代码。\\n\\n### 限制并行执行\\n现在我们知道如何处理异步执行流程，应该很容易规划我们的`Web爬虫应用程序`的第四版的实现，这个版本对并发下载任务的数量施加了限制。我们有几个方案可以用来做到这一点。其中一些方案如下：\\n\\n* 使用先前实现的基于回调的`TaskQueue`类。我们只需要`thunkify`我们的`Generator`函数和其提供的回调函数即可。\\n* 使用基于`Promise`的`TaskQueue`类，并确保每个作为任务的`Generator`函数都被转换成一个返回`Promise`对象的函数。\\n* 使用`async`，`thunkify`我们打算使用的工具函数，此外还需要把我们用到的`Generator`函数转化为基于回调的模式，以便于能够被这个库较好地使用。\\n* 使用基于`co`的生态系统中的库，特别是专门为这种场景的库，如[co-limiter](https://npmjs.org/package/co-limiter)。\\n* 实现基于生产者 - 消费者模型的自定义算法，这与`co-limiter`的内部实现原理相同。\\n\\n为了学习，我们选择最后一个方案，甚至帮助我们可以更好地理解一种经常与协程(也和线程和进程)同步相关的模式。\\n\\n### 生产者 - 消费者模式\\n我们的目标是利用队列来提供固定数量的`workers`，与我们想要设置的并发级别一样多。为了实现这个算法，我们将基于本章前面定义的`TaskQueue`类改写：\\n\\n```javascript\\nclass TaskQueue {\\n  constructor(concurrency) {\\n    this.concurrency = concurrency;\\n    this.running = 0;\\n    this.taskQueue = [];\\n    this.consumerQueue = [];\\n    this.spawnWorkers(concurrency);\\n  }\\n  pushTask(task) {\\n    if (this.consumerQueue.length !== 0) {\\n      this.consumerQueue.shift()(null, task);\\n    } else {\\n      this.taskQueue.push(task);\\n    }\\n  }\\n  spawnWorkers(concurrency) {\\n    const self = this;\\n    for (let i = 0; i < concurrency; i++) {\\n      co(function*() {\\n        while (true) {\\n          const task = yield self.nextTask();\\n          yield task;\\n        }\\n      });\\n    }\\n  }\\n  nextTask() {\\n    return callback => {\\n      if (this.taskQueue.length !== 0) {\\n        return callback(null, this.taskQueue.shift());\\n      }\\n      this.consumerQueue.push(callback);\\n    }\\n  }\\n}\\n```\\n\\n让我们分析这个`TaskQueue`类的新实现。首先是在构造函数中。需要调用一次`this.spawnWorkers()`，因为这是启动`worker`的方法。\\n\\n我们的`worker`很简单，它们只是用`co()`包装的立即执行的`Generator`函数，所以每个`Generator`函数可以并行执行。在内部，每个`worker`正在运行在一个死循环（`while(true){}`）中，一直阻塞（`yield`）到新任务在队列中可用时（`yield self.nextTask()`），一旦可以执行新任务，`yield`这个异步任务直到其完成。您可能想知道我们如何能够限制并行执行，并让下一个任务在队列中处于等待状态。答案是在`nextTask()`方法中。我们来详细地看看在这个方法的原理：\\n\\n```javascript\\nnextTask() {\\n  return callback => {\\n    if (this.taskQueue.length !== 0) {\\n      return callback(null, this.taskQueue.shift());\\n    }\\n    this.consumerQueue.push(callback);\\n  }\\n}\\n```\\n\\n我们看这个函数内部发生了什么，这才是这个模式的核心：\\n\\n1. 这个方法返回一个对于`co`而言是一个合法的`yieldable`的`thunk`。\\n2. 只要`taskQueue`类生成的实例中还有下一个任务，`thunk`的回调函数会被立即调用。回调函数调用时，立马解锁一个`worker`的阻塞状态，`yield`这一个任务。\\n3. 如果队列中没有任务了，回调函数本身会被放入`consumerQueue`中。通过这种做法，我们将一个`worker`置于空闲（`idle`）的模式。一旦我们有一个新的任务来要处理，在`consumerQueue`队列中的回调函数会被调用，立马唤醒我们这一`worker`进行异步处理。\\n\\n现在，为了理解`consumerQueue`队列中的空闲`worker`是如何恢复工作的，我们需要分析`pushTask()`方法。如果当前有回调函数可用的话，`pushTask()`方法将调用`consumerQueue`队列中的第一个回调函数，从而将取消对`worker`的锁定。如果没有可用的回调函数，这意味着所有的`worker`都是工作状态，只需要添加一个新的任务到`taskQueue`任务队列中。\\n\\n在`TaskQueue`类中，`worker`充当消费者的角色，而调用`pushTask()`函数的角色可以被认为是生产者。这个模式向我们展示了一个`Generator`函数实际上可以跟一个线程或进程类似。实际上，生产者 - 消费者之间问题是研究进程间通信和同步时最常见的问题，但正如我们已经提到的那样，它对于进程和线程来说，也是一个常见的例子。\\n\\n### 限制下载任务的并发量\\n既然我们已经使用`Generator`函数和生产者 - 消费者模型实现一个限制并行算法，并且已经在`Web爬虫应用程序`第四版应用它来限制中下载任务的并发数。 首先，我们加载和初始化一个`TaskQueue`对象：\\n\\n```javascript\\nconst TaskQueue = require('./taskQueue');\\nconst downloadQueue = new TaskQueue(2);\\n```\\n\\n然后，修改`spiderLinks()`函数。和之前不限制并发的版本类似，所以这里我们只展示修改的部分，主要是通过调用新版本的`TaskQueue`类生成的实例的`pushTask()`方法来限制并行执行：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  //...\\n  return (callback) => {\\n    //...\\n    function done(err, result) {\\n      //...\\n    }\\n    links.forEach(function(link) {\\n      downloadQueue.pushTask(function*() {\\n        yield spider(link, nesting - 1);\\n        done();\\n      });\\n    });\\n  }\\n}\\n```\\n\\n在每个任务中，我们在下载完成后立即调用`done()`函数，因此我们可以计算下载了多少个链接，然后在完成下载时通知`thunk`的回调函数执行。\\n\\n## 配合Babel使用Async await新语法\\n回调函数、`Promise`和`Generator`函数都是用于处理`JavaScript`和`Node.js`异步问题的方式。正如我们所看到的，`Generator`的真正意义在于它提供了一种方式来暂停一个函数的执行，然后等待前面的任务完成后再继续执行。我们可以使用这样的特性来书写异步代码，并且让开发者用同步阻塞的代码风格来书写异步代码。等到异步操作的结果返回后才恢复当前函数的执行。\\n\\n但`Generator`函数是更多的是用来处理迭代器，然而迭代器在异步代码的使用显得有点笨重。代码可能难以理解，导致代码易读性和可维护性差。\\n\\n但在不远的将来会有一种更加简洁的语法。实际上，这个提议即将引入到`ESMASCript 2017`的规范中，这项规范定义了`async`函数语法。\\n\\n`async`函数规范引入两个关键字(`async`和`await`)到原生的`JavaScript`语言中，改进我们书写异步代码的方式。\\n\\n为了理解这项语法的用法和优势为，我们看一个简单的例子：\\n\\n```javascript\\nconst request = require('request');\\n\\nfunction getPageHtml(url) {\\n  return new Promise(function(resolve, reject) {\\n    request(url, function(error, response, body) {\\n      resolve(body);\\n    });\\n  });\\n}\\nasync function main() {\\n  const html = await getPageHtml('http://google.com');\\n  console.log(html);\\n}\\n\\nmain();\\nconsole.log('Loading...');\\n```\\n\\n在上述代码中，有两个函数：`getPageHtml`和`main`。第一个函数的作用是提取给定`URL`的一个远程网页的`HTML`文档代码。值得注意的是，这个函数返回一个`Promise`对象。\\n\\n重点在于`main`函数，因为在这里使用了`async`和`await`关键字。首先要注意的是函数要以`async`关键字为前缀。意思是这个函数执行的是异步代码并且允许它在函数体内使用`await`关键字。`await`关键字在`getPageHtml`调用之前，告诉`JavaScript`解释器在继续执行下一条指令之前，等待`getPageHtml`返回的`Promise`对象的结果。这样，`main`函数内部哪部分代码是异步的，它会等待异步代码的完成再继续执行后续操作，并且不会阻塞这段程序其余部分的正常执行。实际上，控制台会打印字符串`Loading...`，随后是Google主页的`HTML`代码。\\n\\n是不是这种方法的可读性更好并且更容易理解呢? 不幸地是，这个提议尚未定案，即使通过这个提议，我们需要等下一个版本\\n的`ECMAScript`规范出来并把它集成到`Node.js`后，才能使用这个新语法。 所以我们今天做了什么?只是漫无目的地等待?不是，当然不是！我们已经可以在我们的代码中使用`async await`语法，只要我们使用`Babel`。\\n\\n### 安装与运行Babel\\n`Babel`是一个`JavaScript`编译器(或翻译器)，能够使用语法转换器将高版本的`JavaScript`代码转换成其他`JavaScript`代码。语法转换器允许例如我们书写并使用`ES2015`，`ES2016`，`JSX`和其它的新语法，来翻译成往后兼容的代码，在`JavaScript`运行环境如浏览器或`Node.js`中都可以使用`Babel`。\\n\\n在项目中使用`npm`安装`Babel`，命令如下：\\n\\n```\\nnpm install --save-dev babel-cli\\n```\\n\\n我们还需要安装插件以支持`async await`语法的解释或翻译：\\n\\n```\\nnpm install --save-dev babel-plugin-syntax-async-functions babel-plugin-tranform-async-to-generator\\n```\\n\\n现在假设我们想运行我们之前的例子（称为`index.js`）。我们需要通过以下命令启动：\\n\\n```\\nnode_modules/.bin/babel-node --plugins \\\"syntax-async-functions,transform-async-to-generator\\\" index.js\\n```\\n\\n这样，我们使用支持`async await`的转换器动态地转换源代码。`Node.js`运行的实际是保存在内存中的往后兼容的代码。\\n\\n`Babel`也能被配置为一个代码构建工具，保存翻译或解释后的代码到本地文件系统中，便于我们部署和运行生成的代码。\\n\\n> 关于如何安装和配置Babel，可以到官方网站 https://babeljs.io 查阅相关文档。\\n\\n## 几种方式的比较\\n现在，我们应该对于怎么处理`JavaScript`的异步问题有了一个更好的认识和总结。在下面的表格中总结几大机制的优势和劣势：\\n\\n![](http://oczira72b.bkt.clouddn.com/17-11-7/55293366.jpg)\\n\\n> 值得一提的是，我们选择在本章中仅介绍处理异步控制流程的最受欢迎的解决方案，或者是广泛使用的解决方案，但是例如Fibers（ https://npmjs.org/package/fibers ）和Streamline（ https://npmjs.org/p ackage/streamline ）也是值得一看的。\\n\\n## 总结\\n在本章中，我们分析了一些处理异步控制流的方法，分析了`Promise`、`Generator`函数和即将到来的`async await`语法。\\n\\n我们学习了如何使用这些方法编写更简洁，更具有可读性的异步代码。我们讨论了这些方法的一些最重要的优点和缺点，并认识到即使它们非常有用，也需要一些时间来掌握。这就是这几种方式也没有完全取代在许多情况下仍然非常有用的回调的原因。作为一名开发人员，应该按照实际情况分析决定使用哪种解决方案。如果您正在构建执行异步操作的公共库，则应该提供易于使用的`API`，即使对于只想使用回调的开发人员也是如此。\\n\\n在下一章中，我们将探讨另一个与异步代码执行相关的机制，这也是整个`Node.js`生态系统中的另一个基本构建块：`streams`。\",\n        \"_id\": \"5a20d798b564820d22f6910a\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-12-01T04:16:24.262Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 5,\n    \"viewed\": 52,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:17:48.174] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/users/getUserInfo?userName=admin
request client ip:  ::1
request query:  {"userName":"admin"}
response time: 2
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"回复成功\",\n  \"data\": {\n    \"userName\": \"admin\",\n    \"registerTime\": \"2017-11-23T07:36:51.931Z\",\n    \"message\": []\n  }\n}"
*************** response log end ***************

[2017-12-01 12:17:48.187] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/art/updateCheckTimes
request client ip:  ::1
request body: 
{"id":"5a0e8b7949b148371be1f96e","token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxNTc2LCJleHAiOjE1MTIxNDQ3NzZ9.uKBuLKHhVqQEXpCm68cxufPp3HqLhF25sI_3iT0rBmI"}
response time: 7
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-12-01T04:16:24.253Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"# Asynchronous Control Flow Patterns with ES2015 and Beyond\\n在上一章中，我们学习了如何使用回调处理异步代码，以及如何解决如回调地狱代码等异步问题。回调是`JavaScript`和`Node.js`中的异步编程的基础，但是现在，其他替代方案已经出现。这些替代方案更复杂，以便能够以更方便的方式处理异步代码。\\n\\n在本章中，我们将探讨一些代表性的替代方案，`Promise`和`Generator`。以及`async await`，这是一种创新的语法，可在高版本的`JavaScript`中提供，其也作为`ECMAScript 2017`发行版的一部分。\\n\\n我们将看到这些替代方案如何简化处理异步控制流的方式。最后，我们将比较所有这些方法，以了解所有这些方法的所有优点和缺点，并能够明智地选择最适合我们下一个`Node.js`项目要求的方法。\\n\\n## Promise\\n我们在前面的章节中提到，`CPS风格`不是编写异步代码的唯一方法。事实上，`JavaScript`生态系统为传统的回调模式提供了有趣的替代方案。最着名的选择之一是`Promise`，特别是现在它是`ECMAScript 2015`的一部分，并且现在可以在`Node.js`中可用。\\n\\n### 什么是Promise？\\n`Promise`是一种抽象的对象，我们通常允许函数返回一个名为`Promise`的对象，它表示异步操作的最终结果。通常情况下，我们说当异步操作尚未完成时，我们说`Promise`对象处于`pending`状态，当操作成功完成时，我们说`Promise`对象处于`resolve`状态，当操作错误终止时，我们说`Promise`对象处于`reject`状态。一旦`Promise`处于`resolve`或`reject`，我们认为当前异步操作结束。\\n\\n为了接收到异步操作的正确结果或错误捕获，我们可以使用`Promise`的`then`方法：\\n\\n```javascript\\npromise.then([onFulfilled], [onRejected])\\n```\\n\\n在前面的代码中，`onFulfilled()`是一个函数，最终会收到`Promise`的正确结果，而`onRejected()`是另一个函数，它将接收产生异常的原因（如果有的话）。两个参数都是可选的。\\n\\n要了解`Promise`如何转换我们的代码，让我们考虑以下几点：\\n\\n```javascript\\nasyncOperation(arg, (err, result) => {\\n  if (err) {\\n    // 错误处理\\n  }\\n  // 正常结果处理\\n});\\n```\\n\\n`Promise`允许我们将这个典型的`CPS`代码转换成更好的结构化和更优雅的代码，如下所示：\\n\\n```javascript\\nasyncOperation(arg)\\n  .then(result => {\\n    // 错误处理\\n  }, err => {\\n    // 正常结果处理\\n  });\\n```\\n\\n`then()`方法的一个关键特征是它同步地返回另一个`Promise`对象。如果`onFulfilled()`或`onRejected()`函数中的任何一个函数返回`x`，则`then()`方法返回的`Promise`对象将如下所示：\\n\\n* 如果`x`是一个值，则这个`Promise`对象会正确处理(`resolve`)`x`\\n* 如果`x`是一个`Promise`对象或`thenable`，则会正确处理(`resolve`)`x`\\n* 如果`x`是一个异常，则会捕获异常(`reject`)`x`\\n\\n> 注：thenable是一个具有then方法的类似于Promise的对象(Promise-like)。\\n\\n这个特点使我们能够链式构建`Promise`，允许轻松排列组合我们的异步操作。另外，如果我们没有指定一个`onFulfilled()`或`onRejected()`处理程序，则正确结果或异常捕获将自动转发到`Promise`链的下一个`Promise`。例如，这允许我们在整个链中自动传播错误，直到被`onRejected()`处理程序捕获。随着`Promise`链，任务的顺序执行突然变成简单多了：\\n\\n```javascript\\nasyncOperation(arg)\\n  .then(result1 => {\\n    // 返回另一个Promise\\n    return asyncOperation(arg2);\\n  })\\n  .then(result2 => {\\n    // 返回一个值\\n    return 'done';\\n  })\\n  .then(undefined, err => {\\n    // 捕获Promise链中的异常\\n  });\\n```\\n\\n下图展示了链式`Promise`如何工作：\\n\\n![](http://oczira72b.bkt.clouddn.com/17-10-31/46370382.jpg)\\n\\n`Promise`的另一个重要特性是`onFulfilled()`和`onRejected()`函数是异步调用的，如同上述的例子，在最后那个`then`函数`resolve`一个同步的`Promise`，它也是同步的。这种模式避免了`Zalgo`（参见`Chapter2-Node.js Essential Patterns`），使我们的异步代码更加一致和稳健。\\n\\n如果在`onFulfilled()`或`onRejected()`处理程序中抛出异常（使用`throw`语句），则`then()`方法返回的`Promise`将被自动地`reject`，抛出异常作为`reject`的原因。这相对于`CPS`来说是一个巨大的优势，因为它意味着有了`Promise`，异常将在整个链中自动传播，并且`throw`语句终于可以使用。\\n\\n在以前，许多不同的库实现了`Promise`，大多数时候它们之间不兼容，这意味着不可能在使用不同`Promise`库的`thenable`链式传播错误。\\n\\n`JavaScript`社区非常努力地解决了这个限制，这些努力导致了`Promises / A +`规范的创建。该规范详细描述了`then`方法的行为，提供了一个可互兼容的基础，这使得来自不同库的`Promise`对象能够彼此兼容，开箱即用。\\n\\n有关`Promises / A +`规范的详细说明，可以参考[Promises / A + 官方网站](https://promisesaplus.com)。\\n\\n### Promise / A + 的实施\\n在`JavaScript`中以及`Node.js`中，有几个实现`Promises / A +`规范的库。以下是最受欢迎的：\\n\\n* [Bluebird](https://npmjs.org/package/bluebird)\\n* [Q](https://npmjs.org/package/q)\\n* [RSVP](https://npmjs.org/package/rsvp)\\n* [Vow](https://npmjs.org/package/vow)\\n* [When.js](https://npmjs.org/package/when)\\n* ES2015 promises\\n\\n真正区别他们的是在`Promises / A +`标准之上提供的额外功能。正如我们上述所说的那样，该标准定义了`then()`方法和`Promise`解析过程的行为，但它没有指定其他功能，例如，如何从基于回调的异步函数创建`Promise`。\\n\\n在我们的示例中，我们将使用由`ES2015`的`Promise`，因为`Promise`对象自`Node.js 4`后即可使用，而不需要任何库来实现。\\n\\n作为参考，以下是`ES2015`的`Promise`提供的API：\\n\\n`constructor`(`new Promise（function（resolve, reject）{}）`)：创建了一个新的`Promise`，它基于作为传递两个类型为函数的参数来决定`resolve`或`reject`。构造函数的参数解释如下：\\n\\n* `resolve(obj)` ：`resolve`一个`Promise`，并带上一个参数`obj`，如果`obj`是一个值，这个值就是传递的异步操作成功的结果。如果`obj`是一个`Promise`或一个`thenable`，则会进行正确处理。\\n* `reject(err)`：`reject`一个`Promise`，并带上一个参数`err`。它是`Error`对象的一个实例。\\n\\n#### Promise对象的静态方法\\n* `Promise.resolve(obj)`： 将会创建一个`resolve`的`Promise`实例\\n* `Promise.reject(err)`： 将会创建一个`reject`的`Promise`实例\\n* `Promise.all(iterable)`：返回一个新的`Promise`实例，并且在`iterable`中所\\n有`Promise`状态为`reject`时, 返回的`Promise`实例的状态会被置为`reject`，如果`iterable`中至少有一个`Promise`状态为`reject`时, 返回的`Promise`实例状态也会被置为`reject`，并且`reject`的原因是第一个被`reject`的`Promise`对象的`reject`原因。\\n* `Promise.race(iterable)`：返回一个`Promise`实例，当`iterable`中任何一个`Promise`被`resolve`或被`reject`时， 返回的`Promise`实例以同样的原因`resolve`或`reject`。\\n\\n#### Promise实例方法\\n* `Promise.then(onFulfilled, onRejected)`：这是`Promise`的基本方法。它的行为与我们之前描述的`Promises / A +`标准兼容。\\n* `Promise.catch(onRejected)`：这只是`Promise.then(undefined，onRejected)`的语法糖。\\n\\n> 值得一提的是，一些Promise实现提供了另一种机制来创建新的Promise，称为deferreds。我们不会在这里描述，因为它不是ES2015标准的一部分，但是如果您想了解更多信息，可以阅读Q文档 (https://github.com/kriskowal/q#using-deferreds) 或When.js文档 (https://github.com/cujojs/when/wiki/Deferred) 。\\n\\n### Promisifying一个Node.js回调风格的函数\\n在`JavaScript`中，并不是所有的异步函数和库都支持开箱即用的`Promise`。大多数情况下，我们必须将一个典型的基于回调的函数转换成一个返回`Promise`的函数，这个过程也被称为`promisification`。\\n\\n幸运的是，`Node.js`中使用的回调约定允许我们创建一个可重用的函数，我们通过使用`Promise`对象的构造函数来简化任何`Node.js`风格的`API`。让我们创建一个名为`promisify()`的新函数，并将其包含到`utilities.js`模块中（以便稍后在我们的`Web爬虫应用程序`中使用它）：\\n\\n```javascript\\nmodule.exports.promisify = function(callbackBasedApi) {\\n  return function promisified() {\\n    const args = [].slice.call(arguments);\\n    return new Promise((resolve, reject) => {\\n      args.push((err, result) => {\\n        if (err) {\\n          return reject(err);\\n        }\\n        if (arguments.length <= 2) {\\n          resolve(result);\\n        } else {\\n          resolve([].slice.call(arguments, 1));\\n        }\\n      });\\n      callbackBasedApi.apply(null, args);\\n    });\\n  }\\n};\\n```\\n\\n前面的函数返回另一个名为`promisified()`的函数，它表示输入中给出的`callbackBasedApi`的`promisified`版本。以下展示它是如何工作的：\\n\\n1. `promisified()`函数使用`Promise`构造函数创建一个新的`Promise`对象，并立即将其返回给调用者。\\n2. 在传递给`Promise`构造函数的函数中，我们确保传递给`callbackBasedApi`，这是一个特殊的回调函数。由于我们知道回调总是最后调用的，我们只需将回调函数附加到提供给`promisified()`函数的参数列表里（`args`）。\\n3. 在特殊的回调中，如果我们收到错误，我们立即`reject`这个`Promise`。\\n4. 如果没有收到错误，我们使用一个值或一个数组值来`resolve`这个`Promise`，具体取决于传递给回调的结果数量。\\n5. 最后，我们只需使用我们构建的参数列表调用`callbackBasedApi`。\\n\\n> 大部分的Promise已经提供了一个开箱即用的接口来将一个Node.js风格的API转换成一个返回Promise的API。例如，Q有Q.denodeify()和Q.nbind()，Bluebird有Promise.promisify()，而When.js有node.lift()。\\n\\n### 顺序执行\\n在一些必要的理论之后，我们现在准备将我们的`Web爬虫应用程序`转换为使用`Promise`的形式。让我们直接从版本2开始，直接下载一个Web网页的链接。\\n\\n在`spider.js`模块中，第一步是加载我们的`Promise`实现（我们稍后会使用它）和`Promisifying`我们打算使用的基于回调的函数：\\n\\n```javascript\\nconst utilities = require('./utilities');\\nconst request = utilities.promisify(require('request'));\\nconst mkdirp = utilities.promisify(require('mkdirp'));\\nconst fs = require('fs');\\nconst readFile = utilities.promisify(fs.readFile);\\nconst writeFile = utilities.promisify(fs.writeFile);\\n```\\n\\n现在，我们开始更改我们的`download`函数：\\n\\n```javascript\\nfunction download(url, filename) {\\n  console.log(`Downloading ${url}`);\\n  let body;\\n  return request(url)\\n    .then(response => {\\n      body = response.body;\\n      return mkdirp(path.dirname(filename));\\n    })\\n    .then(() => writeFile(filename, body))\\n    .then(() => {\\n      console.log(`Downloaded and saved: ${url}`);\\n      return body;\\n    });\\n}\\n```\\n\\n这里要注意的到的最重要的是我们也为`readFile()`返回的`Promise`注册\\n一个`onRejected()`函数，用来处理一个网页没有被下载的情况(或文件不存在)。 还有，看我们如何使用`throw`来传递`onRejected()`函数中的错误的。\\n\\n既然我们已经更改我们的`spider()`函数，我们这么修改它的调用方式：\\n\\n```javascript\\nspider(process.argv[2], 1)\\n  .then(() => console.log('Download complete'))\\n  .catch(err => console.log(err));\\n```\\n\\n注意我们是如何第一次使用`Promise`的语法糖`catch`来处理源自`spider()`函数的任何错误情况。如果我们再看看迄今为止我们所写的所有代码，那么我们会惊喜的发现，我们没有包含任何错误传播逻辑，因为我们在使用回调函数时会被迫做这样的事情。这显然是一个巨大的优势，因为它极大地减少了我们代码中的样板文件以及丢失任何异步错误的机会。\\n\\n现在，完成我们唯一缺失的`Web爬虫应用程序`的第二版的`spiderLinks()`函数，我们将在稍后实现它。\\n\\n### 顺序迭代\\n到目前为止，`Web爬虫应用程序`代码库主要是对`Promise`是什么以及如何使用的概述，展示了使用`Promise`实现顺序执行流程的简单性和优雅性。但是，我们现在考虑的代码只涉及到一组已知的异步操作的执行。所以，完成我们对顺序执行流程的探索的缺失部分是看我们如何使用`Promise`来实现迭代。同样，网络蜘蛛第二版的`spiderLinks()`函数也是一个很好的例子。\\n\\n让我们添加缺少的这一块：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  let promise = Promise.resolve();\\n  if (nesting === 0) {\\n    return promise;\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  links.forEach(link => {\\n    promise = promise.then(() => spider(link, nesting - 1));\\n  });\\n  return promise;\\n}\\n```\\n\\n为了异步迭代一个网页的全部链接，我们必须动态创建一个`Promise`的迭代链。\\n\\n1. 首先，我们定义一个空的`Promise`，`resolve`为`undefined`。这个`Promise`只是用来作为`Promise`的迭代链的起始点。 \\n2. 然后，我们通过在循环中调用链中前一个`Promise`的`then()`方法获得的新的`Promise`来更新`Promise`变量。这就是我们使用`Promise`的异步迭代模式。\\n\\n这样，循环的结束，`promise`变量会包含循环中最后一个`then()`返回的`Promise`对象，所以它只有当`Promise`的迭代链中全部`Promise`对象被`resolve`后才能被`resolve`。\\n\\n> 注：在最后调用了这个then方法来resolve这个Promise对象\\n\\n通过这个，我们已使用`Promise`对象重写了我们的`Web爬虫应用程序`。我们现在应该可以运行它了。\\n\\n### 顺序迭代模式\\n为了总结这个顺序执行的部分，让我们提取一个模式来依次遍历一组`Promise`：\\n\\n```javascript\\nlet tasks = [ /* ... */ ]\\nlet promise = Promise.resolve();\\ntasks.forEach(task => {\\n  promise = promise.then(() => {\\n    return task();\\n  });\\n});\\npromise.then(() => {\\n  // 所有任务都完成\\n});\\n```\\n\\n使用`reduce()`方法来替代`forEach()`方法，允许我们写出更为简洁的代码：\\n\\n```javascript\\nlet tasks = [ /* ... */ ]\\nlet promise = tasks.reduce((prev, task) => {\\n  return prev.then(() => {\\n    return task();\\n  });\\n}, Promise.resolve());\\n\\npromise.then(() => {\\n  //All tasks completed\\n});\\n```\\n\\n与往常一样，通过对这种模式的简单调整，我们可以将所有任务的结果收集到一个数组中，我们可以实现一个`mapping`算法，或者构建一个`filter`等等。\\n\\n> 上述这个模式使用循环动态地建立一个链式的Promise。\\n\\n### 并行执行\\n另一个适合用`Promise`的执行流程是并行执行流程。实际上，我们需要做的就是使用内置的`Promise.all()`。这个方法创造了另一个`Promise`对象，只有在输入中的所有`Promise`都`resolve`时才能`resolve`。这是一个并行执行，因为在其参数`Promise`对象的之间没有执行顺序可言。\\n\\n为了演示这一点，我们来看我们的`Web爬虫应用程序`的第三版，它将页面中的所有链接并行下载。让我们再次使用`Promise`更新`spiderLinks()`函数来实现并行流程：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return Promise.resolve();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  const promises = links.map(link => spider(link, nesting - 1));\\n  return Promise.all(promises);\\n}\\n```\\n\\n这里的模式在`elements.map()`迭代中产生一个数组，存放所有异步任务，之后便于同时启动`spider()`任务。这一次，在循环中，我们不等待以前的下载完成，然后开始一个新的下载任务：所有的下载任务在一个循环中一个接一个地开始。之后，我们利用`Promise.all()`方法，它返回一个新的`Promise`对象，当数组中的所有`Promise`对象都被`resolve`时，这个`Promise`对象将被`resolve`。换句话说，所有的下载任务完成，这正是我们想要的。\\n\\n### 限制并行执行\\n不幸的是，`ES2015`的`Promise API`并没有提供一种原生的方式来限制并发任务的数量，但是我们总是可以依靠我们所学到的有关用普通`JavaScript`来限制并发。事实上，我们在`TaskQueue`类中实现的模式可以很容易地被调整来支持返回承诺的任务。这很容易通过修改`next()`方法来完成：\\n\\n```javascript\\nclass TaskQueue {\\n  constructor(concurrency) {\\n    this.concurrency = concurrency;\\n    this.running = 0;\\n    this.queue = [];\\n  }\\n\\n  pushTask(task) {\\n    this.queue.push(task);\\n    this.next();\\n  }\\n\\n  next() {\\n    while (this.running < this.concurrency && this.queue.length) {\\n      const task = this.queue.shift();\\n      task().then(() => {\\n        this.running--;\\n        this.next();\\n      });\\n      this.running++;\\n    }\\n  }\\n}\\n```\\n\\n不同于使用一个回调函数来处理任务，我们简单地调用`Promise`的`then()`。\\n\\n让我们回到`spider.js`模块，并修改它以支持我们的新版本的`TaskQueue`类。首先，我们确保定义一个`TaskQueue`的新实例：\\n\\n```javascript\\nconst TaskQueue = require('./taskQueue');\\nconst downloadQueue = new TaskQueue(2);\\n```\\n\\n然后，是我们的`spiderLinks()`函数。这里的修改也是很简单：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return Promise.resolve();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  // 我们需要如下代码，用于创建Promise对象\\n  // 如果没有下列代码，当任务数量为0时，将永远不会resolve\\n  if (links.length === 0) {\\n    return Promise.resolve();\\n  }\\n  return new Promise((resolve, reject) => {\\n    let completed = 0;\\n    let errored = false;\\n    links.forEach(link => {\\n      let task = () => {\\n        return spider(link, nesting - 1)\\n          .then(() => {\\n            if (++completed === links.length) {\\n              resolve();\\n            }\\n          })\\n          .catch(() => {\\n            if (!errored) {\\n              errored = true;\\n              reject();\\n            }\\n          });\\n      };\\n      downloadQueue.pushTask(task);\\n    });\\n  });\\n}\\n```\\n\\n在上述代码中有几点值得我们注意的：\\n\\n* 首先，我们需要返回使用`Promise`构造函数创建的新的`Promise`对象。正如我们将看到的，这使我们能够在队列中的所有任务完成时手动`resolve`我们的`Promise`对象。\\n* 然后，我们应该看看我们如何定义任务。我们所做的是将一个`onFulfilled()`回调函数的调用添加到由`spider()`返回的`Promise`对象中，所以我们可以计算完成的下载任务的数量。当完成的下载量与当前页面中链接的数量相同时，我们知道任务已经处理完毕，所以我们可以调用外部`Promise`的`resolve()`函数。\\n\\n> Promises / A +规范规定，then()方法的onFulfilled()和onRejected()回调函数只能调用一次（仅调用onFulfilled()和onRejected()）。Promise接口的实现确保即使我们多次手动调用resolve或reject，Promise也仅可以被resolve或reject一次。\\n\\n现在，使用`Promise`的`Web爬虫应用程序`的第4版应该已经准备好了。我们可能再次注意到下载任务如何并行运行，并发数量限制为2。\\n\\n### 在公有API中暴露回调函数和Promise\\n正如我们在前面所学到的，`Promise`可以被用作回调函数的一个很好的替代品。它们使我们的代码更具可读性和易于理解。虽然`Promise`带来了许多优点，但也要求开发人员理解许多不易于理解的概念，以便正确和熟练地使用。由于这个原因和其他原因，在某些情况下，比起`Promise`来说，很多开发者更偏向于回调函数。\\n\\n现在让我们想象一下，我们想要构建一个执行异步操作的公共库。我们需要做什么？我们是创建了一个基于回调函数的`API`还是一个面向`Promise`的`API`？还是两者均有？\\n\\n这是许多知名的库所面临的问题，至少有两种方法值得一提，使我们能够提供一个多功能的`API`。\\n\\n像`request`，`redis`和`mysql`这样的库所使用的第一种方法是提供一个简单的基于回调函数的`API`，如果需要，开发人员可以选择公开函数。其中一些库提供工具函数来`Promise`化异步回调，但开发人员仍然需要以某种方式将暴露的`API`转换为能够使用`Promise`对象。\\n\\n第二种方法更透明。它还提供了一个面向回调的`API`，但它使回调参数可选。每当回调作为参数传递时，函数将正常运行，在完成时或失败时执行回调。当回调未被传递时，函数将立即返回一个`Promise`对象。这种方法有效地结合了回调函数和`Promise`，使得开发者可以在调用时选择采用什么接口，而不需要提前进行`Promise`化。许多库，如`mongoose`和`sequelize`，都支持这种方法。\\n\\n我们来看一个简单的例子。假设我们要实现一个异步执行除法的模块：\\n\\n```javascript\\nmodule.exports = function asyncDivision(dividend, divisor, cb) {\\n  return new Promise((resolve, reject) => { // [1]\\n    process.nextTick(() => {\\n      const result = dividend / divisor;\\n      if (isNaN(result) || !Number.isFinite(result)) {\\n        const error = new Error('Invalid operands');\\n        if (cb) {\\n          cb(error); // [2]\\n        }\\n        return reject(error);\\n      }\\n      if (cb) {\\n        cb(null, result); // [3]\\n      }\\n      resolve(result);\\n    });\\n  });\\n};\\n```\\n\\n该模块的代码非常简单，但是有一些值得强调的细节：\\n\\n* 首先，返回使用`Promise`的构造函数创建的新承诺。我们在构造函数参数函数内定义全部逻辑。\\n* 在发生错误的情况下，我们`reject`这个`Promise`，但如果回调函数在被调用时作为参数传递，我们也执行回调来进行错误传播。\\n* 在计算结果之后，我们`resolve`了这个`Promise`，但是如果有回调函数，我们也会将结果传播给回调函数。\\n\\n我们现在看如何用回调函数和`Promise`来使用这个模块：\\n\\n```javascript\\n// 回调函数的方式\\nasyncDivision(10, 2, (error, result) => {\\n  if (error) {\\n    return console.error(error);\\n  }\\n  console.log(result);\\n});\\n\\n// Promise化的调用方式\\nasyncDivision(22, 11)\\n  .then(result => console.log(result))\\n  .catch(error => console.error(error));\\n```\\n\\n应该很清楚的是，即将开始使用类似于上述的新模块的开发人员将很容易地选择最适合自己需求的风格，而无需在希望利用`Promise`时引入外部`promisification`功能。\\n\\n## Generators\\n`ES2015`规范引入了另外一种机制，除了其他新功能外，还可以用来简化`Node.js`应用程序的异步控制流程。我们正在谈论`Generator`，也被称为`semi-coroutines`。它们是子程序的一般化，可以有不同的入口点。在一个正常的函数中，实际上我们只能有一个入口点，这个入口点对应着函数本身的调用。`Generator`与一般函数类似，但是可以暂停（使用`yield`语句），然后在稍后继续执行。在实现迭代器时，`Generator`特别有用，因为我们已经讨论了如何使用迭代器来实现重要的异步控制流模式，如顺序执行和限制并行执行。\\n\\n### Generators基础\\n在我们探索使用`Generator`来实现异步控制流程之前，学习一些基本概念是很重要的。我们从语法开始吧。可以通过在函数关键字之后附加`*`（星号）运算符来声明`Generator`函数：\\n\\n```javascript\\nfunction* makeGenerator() {\\n  // body\\n}\\n```\\n\\n在`makeGenerator()`函数内部，我们可以使用关键字`yield`暂停执行并返回给调用者传递给它的值：\\n\\n```javascript\\nfunction* makeGenerator() {\\n  yield 'Hello World';\\n  console.log('Re-entered');\\n}\\n```\\n\\n在前面的代码中，`Generator`通过`yield`一个字符串`Hello World`暂停当前函数的执行。当`Generator`恢复时，执行将从下列语句开始：\\n\\n```javascript\\nconsole.log('Re-entered');\\n```\\n\\n`makeGenerator()`函数本质上是一个工厂，它在被调用时返回一个新的`Generator`对象：\\n\\n```javascript\\nconst gen = makeGenerator();\\n```\\n\\n生成器对象的最重要的方法是`next()`，它用于启动/恢复`Generator`的执行，并返回如下形式的对象：\\n\\n```\\n{\\n  value: <yielded value>\\n  done: <true if the execution reached the end>\\n}\\n```\\n\\n这个对象包含`Generator` `yield`的值和一个指示`Generator`是否已经完成执行的符号。\\n\\n### 一个简单的例子\\n为了演示`Generator`，我们来创建一个名为`fruitGenerator.js`的新模块：\\n\\n```javascript\\nfunction* fruitGenerator() {\\n  yield 'apple';\\n  yield 'orange';\\n  return 'watermelon';\\n}\\nconst newFruitGenerator = fruitGenerator();\\nconsole.log(newFruitGenerator.next()); // [1]\\nconsole.log(newFruitGenerator.next()); // [2]\\nconsole.log(newFruitGenerator.next()); // [3]\\n```\\n\\n前面的代码将打印下面的输出：\\n\\n```\\n{ value: 'apple', done: false }\\n{ value: 'orange', done: false }\\n{ value: 'watermelon', done: true }\\n```\\n\\n我们可以这么解释上述现象：\\n\\n* 第一次调用`newFruitGenerator.next()`时，`Generator`函数开始执行，直到达到第一个`yield`语句为止，该命令暂停`Generator`函数执行，并将值`apple`返回给调用者。\\n* 在第二次调用`newFruitGenerator.next()`时，`Generator`函数恢复执行，从第二个`yield`语句开始，这又使得执行暂停，同时将`orange`返回给调用者。\\n* `newFruitGenerator.next()`的最后一次调用导致`Generator`函数的执行从其最后的`yield`恢复，一个返回语句，它终止`Generator`函数，返回`watermelon`，并将结果对象中的`done`属性设置为`true`。\\n\\n### Generators作为迭代器\\n为了更好地理解为什么`Generator`函数对实现迭代器非常有用，我们来构建一个例子。在我们将调用`iteratorGenerator.js`的新模块中，我们编写下面的代码：\\n\\n```javascript\\nfunction* iteratorGenerator(arr) {\\n  for (let i = 0; i < arr.length; i++) {\\n    yield arr[i];\\n  }\\n}\\nconst iterator = iteratorGenerator(['apple', 'orange', 'watermelon']);\\nlet currentItem = iterator.next();\\nwhile (!currentItem.done) {\\n  console.log(currentItem.value);\\n  currentItem = iterator.next();\\n}\\n```\\n\\n此代码应按如下所示打印数组中的元素：\\n\\n```\\napple\\norange\\nwatermelon\\n```\\n\\n在这个例子中，每次我们调用`iterator.next()`时，我们都会恢复`Generator`函数的`for`循环，通过`yield`数组中的下一个项来运行另一个循环。这演示了如何在函数调用过程中维护`Generator`的状态。当继续执行时，循环和所有变量的值与`Generator`函数执行暂停时的状态完全相同。\\n\\n### 传值给Generators\\n现在我们继续研究`Generator`的基本功能，首先学习如何将值传递回`Generator`函数。这其实很简单，我们需要做的只是为`next()`方法提供一个参数，并且该值将作为`Generator`函数内的`yield`语句的返回值提供。\\n\\n为了展示这一点，我们来创建一个新的简单模块：\\n\\n```javascript\\nfunction* twoWayGenerator() {\\n  const what = yield null;\\n  console.log('Hello ' + what);\\n}\\nconst twoWay = twoWayGenerator();\\ntwoWay.next();\\ntwoWay.next('world');\\n```\\n\\n当执行时，前面的代码会输出`Hello world`。我们做如下的解释：\\n\\n* 第一次调用`next()`方法时，`Generator`函数到达第一个`yield`语句，然后暂停。\\n* 当`next('world')`被调用时，`Generator`函数从上次停止的位置，也就是上次的`yield`语句点恢复，但是这次我们有一个值传递到`Generator`函数。这个值将被赋值到`what`变量。生成器然后执行`console.log()`指令并终止。\\n\\n用类似的方式，我们可以强制`Generator`函数抛出异常。这可以通过使用`Generator`函数的`throw`方法来实现，如下例所示：\\n\\n```javascript\\nconst twoWay = twoWayGenerator();\\ntwoWay.next();\\ntwoWay.throw(new Error());\\n```\\n\\n在这个最后这段代码，`twoWayGenerator()`函数将在`yield`函数返回的时候抛出异常。这就好像从`Generator`函数内部抛出了一个异常一样，这意味着它可以像使用`try ... catch`块一样进行捕获和处理异常。\\n\\n### Generator实现异步控制流\\n你一定想知道`Generator`函数如何帮助我们处理异步操作。我们可以通过创建一个接受`Generator`函数作为参数的特殊函数来演示这一点，并允许我们在`Generator`函数内部使用异步代码。这个函数在异步操作完成时要注意恢复`Generator`函数的执行。我们将调用这个函数`asyncFlow()`：\\n\\n```javascript\\nfunction asyncFlow(generatorFunction) {\\n  function callback(err) {\\n    if (err) {\\n      return generator.throw(err);\\n    }\\n    const results = [].slice.call(arguments, 1);\\n    generator.next(results.length > 1 ? results : results[0]);\\n  }\\n  const generator = generatorFunction(callback);\\n  generator.next();\\n}\\n```\\n\\n前面的函数取一个`Generator`函数作为输入，然后立即调用：\\n\\n```javascript\\nconst generator = generatorFunction(callback);\\ngenerator.next();\\n```\\n\\n`generatorFunction()`接受一个特殊的回调函数作为参数，当`generator.throw()`如果接收到一个错误，便立即返回。另外，通过将在回调函数中接收的`results`传值回`Generator`函数继续`Generator`函数的执行:\\n\\n```javascript\\nif (err) {\\n  return generator.throw(err);\\n}\\nconst results = [].slice.call(arguments, 1);\\ngenerator.next(results.length > 1 ? results : results[0]);\\n```\\n\\n为了说明这个简单的辅助函数的强大，我们创建一个叫做`clone.js`的新模块，这个模块只是创建它本身的克隆。粘贴我们刚才创建的`asyncFlow()`函数，核心代码如下：\\n\\n```javascript\\nconst fs = require('fs');\\nconst path = require('path');\\nasyncFlow(function*(callback) {\\n  const fileName = path.basename(__filename);\\n  const myself = yield fs.readFile(fileName, 'utf8', callback);\\n  yield fs.writeFile(`clone_of_${filename}`, myself, callback);\\n  console.log('Clone created');\\n});\\n```\\n\\n明显地，有了`asyncFlow()`函数的帮助，我们可以像我们书写同步阻塞函数一样用同步的方式来书写异步代码了。并且这个结果背后的原理显得很清楚。一旦异步操作结束，传递给每个异步函数的回调函数将继续`Generator`函数的执行。没有什么复杂的，但是结果确实很令人意外。\\n\\n这个技术有其他两个变化，一个是`Promise`的使用，另外一个则是`thunks`。\\n\\n> 在基于Generator的控制流中使用的thunk只是一个简单的函数，它除了回调之外，部分地应用了原始函数的所有参数。返回值是另一个只接受回调作为参数的函数。例如，fs.readFile（）的thunkified版本如下所示：\\n\\n```javascript\\nfunction readFileThunk(filename, options) {\\n  return function(callback) {\\n    fs.readFile(filename, options, callback);\\n  }\\n}\\n```\\n\\n`thunk`和`Promise`都允许我们创建不需要回调的`Generator`函数作为参数传递，例如，使用`thunk`的`asyncFlow()`版本如下：\\n\\n```javascript\\nfunction asyncFlowWithThunks(generatorFunction) {\\n  function callback(err) {\\n    if (err) {\\n      return generator.throw(err);\\n    }\\n    const results = [].slice.call(arguments, 1);\\n    const thunk = generator.next(results.length > 1 ? results : results[0]).value;\\n    thunk && thunk(callback);\\n  }\\n  const generator = generatorFunction();\\n  const thunk = generator.next().value;\\n  thunk && thunk(callback);\\n}\\n```\\n\\n这个技巧是读取`generator.next()`的返回值，返回值中包含`thunk`。下一步是通过注入特殊的回调函数调用`thunk`本身。这允许我们写下面的代码：\\n\\n```javascript\\nasyncFlowWithThunk(function*() {\\n  const fileName = path.basename(__filename);\\n  const myself = yield readFileThunk(__filename, 'utf8');\\n  yield writeFileThunk(`clone_of_${fileName}`, myself);\\n  console.log(\\\"Clone created\\\")\\n});\\n```\\n\\n### 使用co的基于Gernator的控制流\\n你应该已经猜到了，`Node.js`生态系统会借助`Generator`函数来提供一些处理异步控制流的解决方案，例如，[suspend](https://npm/js.org/package/suspend)是其中一个最老的支持`Promise`、`thunks`和`Node.js`风格回调函数和正常风格的回调函数的 库。还有，大部分我们之前分析的`Promise`库都提供工具函数使得`Generator`和`Promise`可以一起使用。\\n\\n我们选择[co](https://npmjs.org/package/co)作为本章节的例子。它支持很多类型的`yieldables`，其中一些是：\\n\\n* `Thunks`\\n* `Promises`\\n* `Arrays`(并行执行)\\n* `Objects`(并行执行)\\n* `Generators`(委托)\\n* `Generator`函数(委托)\\n\\n还有很多框架或库是基于`co`生态系统的，包括以下一些：\\n\\n* `Web框架`，最流行的是[koa](https://npmjs.org/package/koa)\\n* 实现特定控制流模式的库\\n* 包装流行的`API`兼容`co`的库\\n\\n我们使用`co`重新实现我们的`Generator`版本的`Web爬虫应用程序`。\\n\\n为了将`Node.js`风格的函数转换成`thunks`，我们将会使用一个叫做[thunkify](https://npmjs.org/package/thunkify)的库。\\n\\n### 顺序执行\\n让我们通过修改`Web爬虫应用程序`的版本2开始我们对`Generator`函数和`co`的实际探索。我们要做的第一件事就是加载我们的依赖包，并生成我们要使用的函数的`thunkified`版本。这些将在`spider.js`模块的最开始进行：\\n\\n```javascript\\nconst thunkify = require('thunkify');\\nconst co = require('co');\\nconst request = thunkify(require('request'));\\nconst fs = require('fs');\\nconst mkdirp = thunkify(require('mkdirp'));\\nconst readFile = thunkify(fs.readFile);\\nconst writeFile = thunkify(fs.writeFile);\\nconst nextTick = thunkify(process.nextTick);\\n```\\n\\n看上述代码，我们可以注意到与本章前面`promisify`化的`API`的代码的一些相似之处。在这一点上，有意思的是，如果我们使用我们的`promisified`版本的函数来代替`thunkified`的版本，代码将保持完全一样，这要归功于`co`支持`thunk`和`Promise`对象作为`yieldable`对象。事实上，如果我们想，甚至可以在同一个应用程序中使用`thunk`和`Promise`，即使在同一个`Generator`函数中。就灵活性而言，这是一个巨大的优势，因为它使我们能够使用基于`Generator`函数的控制流来解决我们应用程序中的问题。\\n\\n好的，现在让我们开始将`download()`函数转换为一个`Generator`函数：\\n\\n```javascript\\nfunction* download(url, filename) {\\n  console.log(`Downloading ${url}`);\\n  const response = yield request(url);\\n  const body = response[1];\\n  yield mkdirp(path.dirname(filename));\\n  yield writeFile(filename, body);\\n  console.log(`Downloaded and saved ${url}`);\\n  return body;\\n}\\n```\\n\\n通过使用`Generator`和`co`，我们的`download()`函数变得简单多了。当我们需要做异步操作的时候，我们使用异步的`Generator`函数作为`thunk`来把之前的内容转化到`Generator`函数，并使用`yield`子句。\\n\\n然后我们开始实现我们的`spider()`函数：\\n\\n```javascript\\nfunction* spider(url, nesting) {\\n  cost filename = utilities.urlToFilename(url);\\n  let body;\\n  try {\\n    body = yield readFile(filename, 'utf8');\\n  } catch (err) {\\n    if (err.code !== 'ENOENT') {\\n      throw err;\\n    }\\n    body = yield download(url, filename);\\n  }\\n  yield spiderLinks(url, body, nesting);\\n}\\n```\\n\\n从上述代码中一个有趣的细节是我们可以使用`try...catch`语句块来处理异常。我们还可以使用`throw`来传播异常。另外一个细节是我们`yield`我们的`download()`函数，而这个函数既不是一个`thunk`，也不是一个`promisified`函数，只是另外的一个`Generator`函数。这也毫无问题，由于`co`也支持其他`Generators`作为`yieldables`。\\n\\n最后转换`spiderLinks()`，在这个函数中，我们递归下载一个网页的链接。在这个函数中使用`Generators`，显得简单多了：\\n\\n```javascript\\nfunction* spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return nextTick();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  for (let i = 0; i < links.length; i++) {\\n    yield spider(links[i], nesting - 1);\\n  }\\n}\\n```\\n\\n看上述代码。虽然顺序迭代没有什么模式可以展示。`Generator`和`co`辅助我们做了很多，方便了我们可以使用同步方式开书写异步代码。\\n\\n看最重要的部分，程序的入口：\\n\\n```javascript\\nco(function*() {\\n  try {\\n    yield spider(process.argv[2], 1);\\n    console.log(`Download complete`);\\n  } catch (err) {\\n    console.log(err);\\n  }\\n});\\n```\\n\\n这是唯一一处需要调用`co(...)`来封装的一个`Generator`。实际上，一旦我们这么做，`co`会自动封装我们传递给`yield`语句的任何`Generator`函数，并且这个过程是递归的，所以程序的剩余部分与我们是否使用`co`是完全无关的，虽然是被`co`封装在里面。\\n\\n现在应该可以运行使用`Generator`函数改写的`Web爬虫应用程序`了。\\n\\n### 并行执行\\n不幸的是，虽然`Generator`很方便地进行顺序执行，但是不能直接用来并行化执行一组任务，至少不能仅仅使用`yield`和`Generator`。之前，在种情况下我们使用的模式只是简单地依赖于一个基于回调或者`Promise`的函数，但使用了`Generator`函数后，一切会显得更简单。\\n\\n幸运的是，如果不限制并发数的并行执行，`co`已经可以通过`yield`一个`Promise`对象、`thunk`、`Generator`函数，甚至包含`Generator`函数的数组来实现。\\n\\n考虑到这一点，我们的`Web爬虫应用程序`第三版可以通过重写`spiderLinks()`函数来做如下改动：\\n\\n```javascript\\nfunction* spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return nextTick();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  const tasks = links.map(link => spider(link, nesting - 1));\\n  yield tasks;\\n}\\n```\\n\\n但是上述函数所做的只是拿到所有的任务，这些任务本质上都是通过`Generator`函数来实现异步的，如果在`co`的`thunk`内对一个包含`Generator`函数的数组使用`yield`，这些任务都会并行执行。外层的`Generator`函数会等到`yield`子句的所有异步任务并行执行后再继续执行。\\n\\n接下来我们看怎么用一个基于回调函数的方式来解决相同的并行流。我们用这种方式重写`spiderLinks()`函数：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return nextTick();\\n  }\\n  // 返回一个thunk\\n  return callback => {\\n    let completed = 0,\\n      hasErrors = false;\\n    const links = utilities.getPageLinks(currentUrl, body);\\n    if (links.length === 0) {\\n      return process.nextTick(callback);\\n    }\\n\\n    function done(err, result) {\\n      if (err && !hasErrors) {\\n        hasErrors = true;\\n        return callback(err);\\n      }\\n      if (++completed === links.length && !hasErrors) {\\n        callback();\\n      }\\n    }\\n    for (let i = 0; i < links.length; i++) {\\n      co(spider(links[i], nesting - 1)).then(done);\\n    }\\n  }\\n}\\n```\\n\\n我们使用`co`并行运行`spider()`函数，调用`Generator`函数返回了一个`Promise`对象。这样，等待`Promise`完成后调用`done()`函数。通常，基于`Generator`控制流的库都有这一功能，因此如果需要，你总是可以将一个`Generator`转换成一个基于回调或基于`Promise`的函数。\\n\\n为了并行开启多个下载任务，我们只要重用在前面定义的基于回调的并行执行的模式。我们应该也注意到我们将`spiderLinks()`转换成一个`thunk`(而不再是一个`Generator`函数)。这使得当全部并行任务完成时，我们有一个回调函数可以调用。\\n\\n> 上面讲到的是将一个Generator函数转换为一个thunk的模式，使之能够支持其他的基于回调或基于Promise的控制流算法，并可以通过同步阻塞的代码风格书写异步代码。\\n\\n### 限制并行执行\\n现在我们知道如何处理异步执行流程，应该很容易规划我们的`Web爬虫应用程序`的第四版的实现，这个版本对并发下载任务的数量施加了限制。我们有几个方案可以用来做到这一点。其中一些方案如下：\\n\\n* 使用先前实现的基于回调的`TaskQueue`类。我们只需要`thunkify`我们的`Generator`函数和其提供的回调函数即可。\\n* 使用基于`Promise`的`TaskQueue`类，并确保每个作为任务的`Generator`函数都被转换成一个返回`Promise`对象的函数。\\n* 使用`async`，`thunkify`我们打算使用的工具函数，此外还需要把我们用到的`Generator`函数转化为基于回调的模式，以便于能够被这个库较好地使用。\\n* 使用基于`co`的生态系统中的库，特别是专门为这种场景的库，如[co-limiter](https://npmjs.org/package/co-limiter)。\\n* 实现基于生产者 - 消费者模型的自定义算法，这与`co-limiter`的内部实现原理相同。\\n\\n为了学习，我们选择最后一个方案，甚至帮助我们可以更好地理解一种经常与协程(也和线程和进程)同步相关的模式。\\n\\n### 生产者 - 消费者模式\\n我们的目标是利用队列来提供固定数量的`workers`，与我们想要设置的并发级别一样多。为了实现这个算法，我们将基于本章前面定义的`TaskQueue`类改写：\\n\\n```javascript\\nclass TaskQueue {\\n  constructor(concurrency) {\\n    this.concurrency = concurrency;\\n    this.running = 0;\\n    this.taskQueue = [];\\n    this.consumerQueue = [];\\n    this.spawnWorkers(concurrency);\\n  }\\n  pushTask(task) {\\n    if (this.consumerQueue.length !== 0) {\\n      this.consumerQueue.shift()(null, task);\\n    } else {\\n      this.taskQueue.push(task);\\n    }\\n  }\\n  spawnWorkers(concurrency) {\\n    const self = this;\\n    for (let i = 0; i < concurrency; i++) {\\n      co(function*() {\\n        while (true) {\\n          const task = yield self.nextTask();\\n          yield task;\\n        }\\n      });\\n    }\\n  }\\n  nextTask() {\\n    return callback => {\\n      if (this.taskQueue.length !== 0) {\\n        return callback(null, this.taskQueue.shift());\\n      }\\n      this.consumerQueue.push(callback);\\n    }\\n  }\\n}\\n```\\n\\n让我们分析这个`TaskQueue`类的新实现。首先是在构造函数中。需要调用一次`this.spawnWorkers()`，因为这是启动`worker`的方法。\\n\\n我们的`worker`很简单，它们只是用`co()`包装的立即执行的`Generator`函数，所以每个`Generator`函数可以并行执行。在内部，每个`worker`正在运行在一个死循环（`while(true){}`）中，一直阻塞（`yield`）到新任务在队列中可用时（`yield self.nextTask()`），一旦可以执行新任务，`yield`这个异步任务直到其完成。您可能想知道我们如何能够限制并行执行，并让下一个任务在队列中处于等待状态。答案是在`nextTask()`方法中。我们来详细地看看在这个方法的原理：\\n\\n```javascript\\nnextTask() {\\n  return callback => {\\n    if (this.taskQueue.length !== 0) {\\n      return callback(null, this.taskQueue.shift());\\n    }\\n    this.consumerQueue.push(callback);\\n  }\\n}\\n```\\n\\n我们看这个函数内部发生了什么，这才是这个模式的核心：\\n\\n1. 这个方法返回一个对于`co`而言是一个合法的`yieldable`的`thunk`。\\n2. 只要`taskQueue`类生成的实例中还有下一个任务，`thunk`的回调函数会被立即调用。回调函数调用时，立马解锁一个`worker`的阻塞状态，`yield`这一个任务。\\n3. 如果队列中没有任务了，回调函数本身会被放入`consumerQueue`中。通过这种做法，我们将一个`worker`置于空闲（`idle`）的模式。一旦我们有一个新的任务来要处理，在`consumerQueue`队列中的回调函数会被调用，立马唤醒我们这一`worker`进行异步处理。\\n\\n现在，为了理解`consumerQueue`队列中的空闲`worker`是如何恢复工作的，我们需要分析`pushTask()`方法。如果当前有回调函数可用的话，`pushTask()`方法将调用`consumerQueue`队列中的第一个回调函数，从而将取消对`worker`的锁定。如果没有可用的回调函数，这意味着所有的`worker`都是工作状态，只需要添加一个新的任务到`taskQueue`任务队列中。\\n\\n在`TaskQueue`类中，`worker`充当消费者的角色，而调用`pushTask()`函数的角色可以被认为是生产者。这个模式向我们展示了一个`Generator`函数实际上可以跟一个线程或进程类似。实际上，生产者 - 消费者之间问题是研究进程间通信和同步时最常见的问题，但正如我们已经提到的那样，它对于进程和线程来说，也是一个常见的例子。\\n\\n### 限制下载任务的并发量\\n既然我们已经使用`Generator`函数和生产者 - 消费者模型实现一个限制并行算法，并且已经在`Web爬虫应用程序`第四版应用它来限制中下载任务的并发数。 首先，我们加载和初始化一个`TaskQueue`对象：\\n\\n```javascript\\nconst TaskQueue = require('./taskQueue');\\nconst downloadQueue = new TaskQueue(2);\\n```\\n\\n然后，修改`spiderLinks()`函数。和之前不限制并发的版本类似，所以这里我们只展示修改的部分，主要是通过调用新版本的`TaskQueue`类生成的实例的`pushTask()`方法来限制并行执行：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  //...\\n  return (callback) => {\\n    //...\\n    function done(err, result) {\\n      //...\\n    }\\n    links.forEach(function(link) {\\n      downloadQueue.pushTask(function*() {\\n        yield spider(link, nesting - 1);\\n        done();\\n      });\\n    });\\n  }\\n}\\n```\\n\\n在每个任务中，我们在下载完成后立即调用`done()`函数，因此我们可以计算下载了多少个链接，然后在完成下载时通知`thunk`的回调函数执行。\\n\\n## 配合Babel使用Async await新语法\\n回调函数、`Promise`和`Generator`函数都是用于处理`JavaScript`和`Node.js`异步问题的方式。正如我们所看到的，`Generator`的真正意义在于它提供了一种方式来暂停一个函数的执行，然后等待前面的任务完成后再继续执行。我们可以使用这样的特性来书写异步代码，并且让开发者用同步阻塞的代码风格来书写异步代码。等到异步操作的结果返回后才恢复当前函数的执行。\\n\\n但`Generator`函数是更多的是用来处理迭代器，然而迭代器在异步代码的使用显得有点笨重。代码可能难以理解，导致代码易读性和可维护性差。\\n\\n但在不远的将来会有一种更加简洁的语法。实际上，这个提议即将引入到`ESMASCript 2017`的规范中，这项规范定义了`async`函数语法。\\n\\n`async`函数规范引入两个关键字(`async`和`await`)到原生的`JavaScript`语言中，改进我们书写异步代码的方式。\\n\\n为了理解这项语法的用法和优势为，我们看一个简单的例子：\\n\\n```javascript\\nconst request = require('request');\\n\\nfunction getPageHtml(url) {\\n  return new Promise(function(resolve, reject) {\\n    request(url, function(error, response, body) {\\n      resolve(body);\\n    });\\n  });\\n}\\nasync function main() {\\n  const html = await getPageHtml('http://google.com');\\n  console.log(html);\\n}\\n\\nmain();\\nconsole.log('Loading...');\\n```\\n\\n在上述代码中，有两个函数：`getPageHtml`和`main`。第一个函数的作用是提取给定`URL`的一个远程网页的`HTML`文档代码。值得注意的是，这个函数返回一个`Promise`对象。\\n\\n重点在于`main`函数，因为在这里使用了`async`和`await`关键字。首先要注意的是函数要以`async`关键字为前缀。意思是这个函数执行的是异步代码并且允许它在函数体内使用`await`关键字。`await`关键字在`getPageHtml`调用之前，告诉`JavaScript`解释器在继续执行下一条指令之前，等待`getPageHtml`返回的`Promise`对象的结果。这样，`main`函数内部哪部分代码是异步的，它会等待异步代码的完成再继续执行后续操作，并且不会阻塞这段程序其余部分的正常执行。实际上，控制台会打印字符串`Loading...`，随后是Google主页的`HTML`代码。\\n\\n是不是这种方法的可读性更好并且更容易理解呢? 不幸地是，这个提议尚未定案，即使通过这个提议，我们需要等下一个版本\\n的`ECMAScript`规范出来并把它集成到`Node.js`后，才能使用这个新语法。 所以我们今天做了什么?只是漫无目的地等待?不是，当然不是！我们已经可以在我们的代码中使用`async await`语法，只要我们使用`Babel`。\\n\\n### 安装与运行Babel\\n`Babel`是一个`JavaScript`编译器(或翻译器)，能够使用语法转换器将高版本的`JavaScript`代码转换成其他`JavaScript`代码。语法转换器允许例如我们书写并使用`ES2015`，`ES2016`，`JSX`和其它的新语法，来翻译成往后兼容的代码，在`JavaScript`运行环境如浏览器或`Node.js`中都可以使用`Babel`。\\n\\n在项目中使用`npm`安装`Babel`，命令如下：\\n\\n```\\nnpm install --save-dev babel-cli\\n```\\n\\n我们还需要安装插件以支持`async await`语法的解释或翻译：\\n\\n```\\nnpm install --save-dev babel-plugin-syntax-async-functions babel-plugin-tranform-async-to-generator\\n```\\n\\n现在假设我们想运行我们之前的例子（称为`index.js`）。我们需要通过以下命令启动：\\n\\n```\\nnode_modules/.bin/babel-node --plugins \\\"syntax-async-functions,transform-async-to-generator\\\" index.js\\n```\\n\\n这样，我们使用支持`async await`的转换器动态地转换源代码。`Node.js`运行的实际是保存在内存中的往后兼容的代码。\\n\\n`Babel`也能被配置为一个代码构建工具，保存翻译或解释后的代码到本地文件系统中，便于我们部署和运行生成的代码。\\n\\n> 关于如何安装和配置Babel，可以到官方网站 https://babeljs.io 查阅相关文档。\\n\\n## 几种方式的比较\\n现在，我们应该对于怎么处理`JavaScript`的异步问题有了一个更好的认识和总结。在下面的表格中总结几大机制的优势和劣势：\\n\\n![](http://oczira72b.bkt.clouddn.com/17-11-7/55293366.jpg)\\n\\n> 值得一提的是，我们选择在本章中仅介绍处理异步控制流程的最受欢迎的解决方案，或者是广泛使用的解决方案，但是例如Fibers（ https://npmjs.org/package/fibers ）和Streamline（ https://npmjs.org/p ackage/streamline ）也是值得一看的。\\n\\n## 总结\\n在本章中，我们分析了一些处理异步控制流的方法，分析了`Promise`、`Generator`函数和即将到来的`async await`语法。\\n\\n我们学习了如何使用这些方法编写更简洁，更具有可读性的异步代码。我们讨论了这些方法的一些最重要的优点和缺点，并认识到即使它们非常有用，也需要一些时间来掌握。这就是这几种方式也没有完全取代在许多情况下仍然非常有用的回调的原因。作为一名开发人员，应该按照实际情况分析决定使用哪种解决方案。如果您正在构建执行异步操作的公共库，则应该提供易于使用的`API`，即使对于只想使用回调的开发人员也是如此。\\n\\n在下一章中，我们将探讨另一个与异步代码执行相关的机制，这也是整个`Node.js`生态系统中的另一个基本构建块：`streams`。\",\n        \"_id\": \"5a20d798b564820d22f6910a\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-12-01T04:16:24.262Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 5,\n    \"viewed\": 53,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:17:48.191] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/art/getArticleDetail?id=5a0e8b7949b148371be1f96e
request client ip:  ::1
request query:  {"id":"5a0e8b7949b148371be1f96e"}
response time: 7
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"_id\": \"5a0e8b7949b148371be1f96e\",\n    \"title\": \"fvf\",\n    \"content\": \"fvfv\",\n    \"author\": \"qichangjun\",\n    \"lastReplyTime\": \"2017-12-01T04:16:24.253Z\",\n    \"__v\": 0,\n    \"replyList\": [\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16847e98682e4e67834b7e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848198682e4e67834b80\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"hohoho\",\n        \"_id\": \"5a16848398682e4e67834b82\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"1111\",\n        \"_id\": \"5a179235954bda0eb0fb667e\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n      },\n      {\n        \"userName\": \"admin\",\n        \"content\": \"# Asynchronous Control Flow Patterns with ES2015 and Beyond\\n在上一章中，我们学习了如何使用回调处理异步代码，以及如何解决如回调地狱代码等异步问题。回调是`JavaScript`和`Node.js`中的异步编程的基础，但是现在，其他替代方案已经出现。这些替代方案更复杂，以便能够以更方便的方式处理异步代码。\\n\\n在本章中，我们将探讨一些代表性的替代方案，`Promise`和`Generator`。以及`async await`，这是一种创新的语法，可在高版本的`JavaScript`中提供，其也作为`ECMAScript 2017`发行版的一部分。\\n\\n我们将看到这些替代方案如何简化处理异步控制流的方式。最后，我们将比较所有这些方法，以了解所有这些方法的所有优点和缺点，并能够明智地选择最适合我们下一个`Node.js`项目要求的方法。\\n\\n## Promise\\n我们在前面的章节中提到，`CPS风格`不是编写异步代码的唯一方法。事实上，`JavaScript`生态系统为传统的回调模式提供了有趣的替代方案。最着名的选择之一是`Promise`，特别是现在它是`ECMAScript 2015`的一部分，并且现在可以在`Node.js`中可用。\\n\\n### 什么是Promise？\\n`Promise`是一种抽象的对象，我们通常允许函数返回一个名为`Promise`的对象，它表示异步操作的最终结果。通常情况下，我们说当异步操作尚未完成时，我们说`Promise`对象处于`pending`状态，当操作成功完成时，我们说`Promise`对象处于`resolve`状态，当操作错误终止时，我们说`Promise`对象处于`reject`状态。一旦`Promise`处于`resolve`或`reject`，我们认为当前异步操作结束。\\n\\n为了接收到异步操作的正确结果或错误捕获，我们可以使用`Promise`的`then`方法：\\n\\n```javascript\\npromise.then([onFulfilled], [onRejected])\\n```\\n\\n在前面的代码中，`onFulfilled()`是一个函数，最终会收到`Promise`的正确结果，而`onRejected()`是另一个函数，它将接收产生异常的原因（如果有的话）。两个参数都是可选的。\\n\\n要了解`Promise`如何转换我们的代码，让我们考虑以下几点：\\n\\n```javascript\\nasyncOperation(arg, (err, result) => {\\n  if (err) {\\n    // 错误处理\\n  }\\n  // 正常结果处理\\n});\\n```\\n\\n`Promise`允许我们将这个典型的`CPS`代码转换成更好的结构化和更优雅的代码，如下所示：\\n\\n```javascript\\nasyncOperation(arg)\\n  .then(result => {\\n    // 错误处理\\n  }, err => {\\n    // 正常结果处理\\n  });\\n```\\n\\n`then()`方法的一个关键特征是它同步地返回另一个`Promise`对象。如果`onFulfilled()`或`onRejected()`函数中的任何一个函数返回`x`，则`then()`方法返回的`Promise`对象将如下所示：\\n\\n* 如果`x`是一个值，则这个`Promise`对象会正确处理(`resolve`)`x`\\n* 如果`x`是一个`Promise`对象或`thenable`，则会正确处理(`resolve`)`x`\\n* 如果`x`是一个异常，则会捕获异常(`reject`)`x`\\n\\n> 注：thenable是一个具有then方法的类似于Promise的对象(Promise-like)。\\n\\n这个特点使我们能够链式构建`Promise`，允许轻松排列组合我们的异步操作。另外，如果我们没有指定一个`onFulfilled()`或`onRejected()`处理程序，则正确结果或异常捕获将自动转发到`Promise`链的下一个`Promise`。例如，这允许我们在整个链中自动传播错误，直到被`onRejected()`处理程序捕获。随着`Promise`链，任务的顺序执行突然变成简单多了：\\n\\n```javascript\\nasyncOperation(arg)\\n  .then(result1 => {\\n    // 返回另一个Promise\\n    return asyncOperation(arg2);\\n  })\\n  .then(result2 => {\\n    // 返回一个值\\n    return 'done';\\n  })\\n  .then(undefined, err => {\\n    // 捕获Promise链中的异常\\n  });\\n```\\n\\n下图展示了链式`Promise`如何工作：\\n\\n![](http://oczira72b.bkt.clouddn.com/17-10-31/46370382.jpg)\\n\\n`Promise`的另一个重要特性是`onFulfilled()`和`onRejected()`函数是异步调用的，如同上述的例子，在最后那个`then`函数`resolve`一个同步的`Promise`，它也是同步的。这种模式避免了`Zalgo`（参见`Chapter2-Node.js Essential Patterns`），使我们的异步代码更加一致和稳健。\\n\\n如果在`onFulfilled()`或`onRejected()`处理程序中抛出异常（使用`throw`语句），则`then()`方法返回的`Promise`将被自动地`reject`，抛出异常作为`reject`的原因。这相对于`CPS`来说是一个巨大的优势，因为它意味着有了`Promise`，异常将在整个链中自动传播，并且`throw`语句终于可以使用。\\n\\n在以前，许多不同的库实现了`Promise`，大多数时候它们之间不兼容，这意味着不可能在使用不同`Promise`库的`thenable`链式传播错误。\\n\\n`JavaScript`社区非常努力地解决了这个限制，这些努力导致了`Promises / A +`规范的创建。该规范详细描述了`then`方法的行为，提供了一个可互兼容的基础，这使得来自不同库的`Promise`对象能够彼此兼容，开箱即用。\\n\\n有关`Promises / A +`规范的详细说明，可以参考[Promises / A + 官方网站](https://promisesaplus.com)。\\n\\n### Promise / A + 的实施\\n在`JavaScript`中以及`Node.js`中，有几个实现`Promises / A +`规范的库。以下是最受欢迎的：\\n\\n* [Bluebird](https://npmjs.org/package/bluebird)\\n* [Q](https://npmjs.org/package/q)\\n* [RSVP](https://npmjs.org/package/rsvp)\\n* [Vow](https://npmjs.org/package/vow)\\n* [When.js](https://npmjs.org/package/when)\\n* ES2015 promises\\n\\n真正区别他们的是在`Promises / A +`标准之上提供的额外功能。正如我们上述所说的那样，该标准定义了`then()`方法和`Promise`解析过程的行为，但它没有指定其他功能，例如，如何从基于回调的异步函数创建`Promise`。\\n\\n在我们的示例中，我们将使用由`ES2015`的`Promise`，因为`Promise`对象自`Node.js 4`后即可使用，而不需要任何库来实现。\\n\\n作为参考，以下是`ES2015`的`Promise`提供的API：\\n\\n`constructor`(`new Promise（function（resolve, reject）{}）`)：创建了一个新的`Promise`，它基于作为传递两个类型为函数的参数来决定`resolve`或`reject`。构造函数的参数解释如下：\\n\\n* `resolve(obj)` ：`resolve`一个`Promise`，并带上一个参数`obj`，如果`obj`是一个值，这个值就是传递的异步操作成功的结果。如果`obj`是一个`Promise`或一个`thenable`，则会进行正确处理。\\n* `reject(err)`：`reject`一个`Promise`，并带上一个参数`err`。它是`Error`对象的一个实例。\\n\\n#### Promise对象的静态方法\\n* `Promise.resolve(obj)`： 将会创建一个`resolve`的`Promise`实例\\n* `Promise.reject(err)`： 将会创建一个`reject`的`Promise`实例\\n* `Promise.all(iterable)`：返回一个新的`Promise`实例，并且在`iterable`中所\\n有`Promise`状态为`reject`时, 返回的`Promise`实例的状态会被置为`reject`，如果`iterable`中至少有一个`Promise`状态为`reject`时, 返回的`Promise`实例状态也会被置为`reject`，并且`reject`的原因是第一个被`reject`的`Promise`对象的`reject`原因。\\n* `Promise.race(iterable)`：返回一个`Promise`实例，当`iterable`中任何一个`Promise`被`resolve`或被`reject`时， 返回的`Promise`实例以同样的原因`resolve`或`reject`。\\n\\n#### Promise实例方法\\n* `Promise.then(onFulfilled, onRejected)`：这是`Promise`的基本方法。它的行为与我们之前描述的`Promises / A +`标准兼容。\\n* `Promise.catch(onRejected)`：这只是`Promise.then(undefined，onRejected)`的语法糖。\\n\\n> 值得一提的是，一些Promise实现提供了另一种机制来创建新的Promise，称为deferreds。我们不会在这里描述，因为它不是ES2015标准的一部分，但是如果您想了解更多信息，可以阅读Q文档 (https://github.com/kriskowal/q#using-deferreds) 或When.js文档 (https://github.com/cujojs/when/wiki/Deferred) 。\\n\\n### Promisifying一个Node.js回调风格的函数\\n在`JavaScript`中，并不是所有的异步函数和库都支持开箱即用的`Promise`。大多数情况下，我们必须将一个典型的基于回调的函数转换成一个返回`Promise`的函数，这个过程也被称为`promisification`。\\n\\n幸运的是，`Node.js`中使用的回调约定允许我们创建一个可重用的函数，我们通过使用`Promise`对象的构造函数来简化任何`Node.js`风格的`API`。让我们创建一个名为`promisify()`的新函数，并将其包含到`utilities.js`模块中（以便稍后在我们的`Web爬虫应用程序`中使用它）：\\n\\n```javascript\\nmodule.exports.promisify = function(callbackBasedApi) {\\n  return function promisified() {\\n    const args = [].slice.call(arguments);\\n    return new Promise((resolve, reject) => {\\n      args.push((err, result) => {\\n        if (err) {\\n          return reject(err);\\n        }\\n        if (arguments.length <= 2) {\\n          resolve(result);\\n        } else {\\n          resolve([].slice.call(arguments, 1));\\n        }\\n      });\\n      callbackBasedApi.apply(null, args);\\n    });\\n  }\\n};\\n```\\n\\n前面的函数返回另一个名为`promisified()`的函数，它表示输入中给出的`callbackBasedApi`的`promisified`版本。以下展示它是如何工作的：\\n\\n1. `promisified()`函数使用`Promise`构造函数创建一个新的`Promise`对象，并立即将其返回给调用者。\\n2. 在传递给`Promise`构造函数的函数中，我们确保传递给`callbackBasedApi`，这是一个特殊的回调函数。由于我们知道回调总是最后调用的，我们只需将回调函数附加到提供给`promisified()`函数的参数列表里（`args`）。\\n3. 在特殊的回调中，如果我们收到错误，我们立即`reject`这个`Promise`。\\n4. 如果没有收到错误，我们使用一个值或一个数组值来`resolve`这个`Promise`，具体取决于传递给回调的结果数量。\\n5. 最后，我们只需使用我们构建的参数列表调用`callbackBasedApi`。\\n\\n> 大部分的Promise已经提供了一个开箱即用的接口来将一个Node.js风格的API转换成一个返回Promise的API。例如，Q有Q.denodeify()和Q.nbind()，Bluebird有Promise.promisify()，而When.js有node.lift()。\\n\\n### 顺序执行\\n在一些必要的理论之后，我们现在准备将我们的`Web爬虫应用程序`转换为使用`Promise`的形式。让我们直接从版本2开始，直接下载一个Web网页的链接。\\n\\n在`spider.js`模块中，第一步是加载我们的`Promise`实现（我们稍后会使用它）和`Promisifying`我们打算使用的基于回调的函数：\\n\\n```javascript\\nconst utilities = require('./utilities');\\nconst request = utilities.promisify(require('request'));\\nconst mkdirp = utilities.promisify(require('mkdirp'));\\nconst fs = require('fs');\\nconst readFile = utilities.promisify(fs.readFile);\\nconst writeFile = utilities.promisify(fs.writeFile);\\n```\\n\\n现在，我们开始更改我们的`download`函数：\\n\\n```javascript\\nfunction download(url, filename) {\\n  console.log(`Downloading ${url}`);\\n  let body;\\n  return request(url)\\n    .then(response => {\\n      body = response.body;\\n      return mkdirp(path.dirname(filename));\\n    })\\n    .then(() => writeFile(filename, body))\\n    .then(() => {\\n      console.log(`Downloaded and saved: ${url}`);\\n      return body;\\n    });\\n}\\n```\\n\\n这里要注意的到的最重要的是我们也为`readFile()`返回的`Promise`注册\\n一个`onRejected()`函数，用来处理一个网页没有被下载的情况(或文件不存在)。 还有，看我们如何使用`throw`来传递`onRejected()`函数中的错误的。\\n\\n既然我们已经更改我们的`spider()`函数，我们这么修改它的调用方式：\\n\\n```javascript\\nspider(process.argv[2], 1)\\n  .then(() => console.log('Download complete'))\\n  .catch(err => console.log(err));\\n```\\n\\n注意我们是如何第一次使用`Promise`的语法糖`catch`来处理源自`spider()`函数的任何错误情况。如果我们再看看迄今为止我们所写的所有代码，那么我们会惊喜的发现，我们没有包含任何错误传播逻辑，因为我们在使用回调函数时会被迫做这样的事情。这显然是一个巨大的优势，因为它极大地减少了我们代码中的样板文件以及丢失任何异步错误的机会。\\n\\n现在，完成我们唯一缺失的`Web爬虫应用程序`的第二版的`spiderLinks()`函数，我们将在稍后实现它。\\n\\n### 顺序迭代\\n到目前为止，`Web爬虫应用程序`代码库主要是对`Promise`是什么以及如何使用的概述，展示了使用`Promise`实现顺序执行流程的简单性和优雅性。但是，我们现在考虑的代码只涉及到一组已知的异步操作的执行。所以，完成我们对顺序执行流程的探索的缺失部分是看我们如何使用`Promise`来实现迭代。同样，网络蜘蛛第二版的`spiderLinks()`函数也是一个很好的例子。\\n\\n让我们添加缺少的这一块：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  let promise = Promise.resolve();\\n  if (nesting === 0) {\\n    return promise;\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  links.forEach(link => {\\n    promise = promise.then(() => spider(link, nesting - 1));\\n  });\\n  return promise;\\n}\\n```\\n\\n为了异步迭代一个网页的全部链接，我们必须动态创建一个`Promise`的迭代链。\\n\\n1. 首先，我们定义一个空的`Promise`，`resolve`为`undefined`。这个`Promise`只是用来作为`Promise`的迭代链的起始点。 \\n2. 然后，我们通过在循环中调用链中前一个`Promise`的`then()`方法获得的新的`Promise`来更新`Promise`变量。这就是我们使用`Promise`的异步迭代模式。\\n\\n这样，循环的结束，`promise`变量会包含循环中最后一个`then()`返回的`Promise`对象，所以它只有当`Promise`的迭代链中全部`Promise`对象被`resolve`后才能被`resolve`。\\n\\n> 注：在最后调用了这个then方法来resolve这个Promise对象\\n\\n通过这个，我们已使用`Promise`对象重写了我们的`Web爬虫应用程序`。我们现在应该可以运行它了。\\n\\n### 顺序迭代模式\\n为了总结这个顺序执行的部分，让我们提取一个模式来依次遍历一组`Promise`：\\n\\n```javascript\\nlet tasks = [ /* ... */ ]\\nlet promise = Promise.resolve();\\ntasks.forEach(task => {\\n  promise = promise.then(() => {\\n    return task();\\n  });\\n});\\npromise.then(() => {\\n  // 所有任务都完成\\n});\\n```\\n\\n使用`reduce()`方法来替代`forEach()`方法，允许我们写出更为简洁的代码：\\n\\n```javascript\\nlet tasks = [ /* ... */ ]\\nlet promise = tasks.reduce((prev, task) => {\\n  return prev.then(() => {\\n    return task();\\n  });\\n}, Promise.resolve());\\n\\npromise.then(() => {\\n  //All tasks completed\\n});\\n```\\n\\n与往常一样，通过对这种模式的简单调整，我们可以将所有任务的结果收集到一个数组中，我们可以实现一个`mapping`算法，或者构建一个`filter`等等。\\n\\n> 上述这个模式使用循环动态地建立一个链式的Promise。\\n\\n### 并行执行\\n另一个适合用`Promise`的执行流程是并行执行流程。实际上，我们需要做的就是使用内置的`Promise.all()`。这个方法创造了另一个`Promise`对象，只有在输入中的所有`Promise`都`resolve`时才能`resolve`。这是一个并行执行，因为在其参数`Promise`对象的之间没有执行顺序可言。\\n\\n为了演示这一点，我们来看我们的`Web爬虫应用程序`的第三版，它将页面中的所有链接并行下载。让我们再次使用`Promise`更新`spiderLinks()`函数来实现并行流程：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return Promise.resolve();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  const promises = links.map(link => spider(link, nesting - 1));\\n  return Promise.all(promises);\\n}\\n```\\n\\n这里的模式在`elements.map()`迭代中产生一个数组，存放所有异步任务，之后便于同时启动`spider()`任务。这一次，在循环中，我们不等待以前的下载完成，然后开始一个新的下载任务：所有的下载任务在一个循环中一个接一个地开始。之后，我们利用`Promise.all()`方法，它返回一个新的`Promise`对象，当数组中的所有`Promise`对象都被`resolve`时，这个`Promise`对象将被`resolve`。换句话说，所有的下载任务完成，这正是我们想要的。\\n\\n### 限制并行执行\\n不幸的是，`ES2015`的`Promise API`并没有提供一种原生的方式来限制并发任务的数量，但是我们总是可以依靠我们所学到的有关用普通`JavaScript`来限制并发。事实上，我们在`TaskQueue`类中实现的模式可以很容易地被调整来支持返回承诺的任务。这很容易通过修改`next()`方法来完成：\\n\\n```javascript\\nclass TaskQueue {\\n  constructor(concurrency) {\\n    this.concurrency = concurrency;\\n    this.running = 0;\\n    this.queue = [];\\n  }\\n\\n  pushTask(task) {\\n    this.queue.push(task);\\n    this.next();\\n  }\\n\\n  next() {\\n    while (this.running < this.concurrency && this.queue.length) {\\n      const task = this.queue.shift();\\n      task().then(() => {\\n        this.running--;\\n        this.next();\\n      });\\n      this.running++;\\n    }\\n  }\\n}\\n```\\n\\n不同于使用一个回调函数来处理任务，我们简单地调用`Promise`的`then()`。\\n\\n让我们回到`spider.js`模块，并修改它以支持我们的新版本的`TaskQueue`类。首先，我们确保定义一个`TaskQueue`的新实例：\\n\\n```javascript\\nconst TaskQueue = require('./taskQueue');\\nconst downloadQueue = new TaskQueue(2);\\n```\\n\\n然后，是我们的`spiderLinks()`函数。这里的修改也是很简单：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return Promise.resolve();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  // 我们需要如下代码，用于创建Promise对象\\n  // 如果没有下列代码，当任务数量为0时，将永远不会resolve\\n  if (links.length === 0) {\\n    return Promise.resolve();\\n  }\\n  return new Promise((resolve, reject) => {\\n    let completed = 0;\\n    let errored = false;\\n    links.forEach(link => {\\n      let task = () => {\\n        return spider(link, nesting - 1)\\n          .then(() => {\\n            if (++completed === links.length) {\\n              resolve();\\n            }\\n          })\\n          .catch(() => {\\n            if (!errored) {\\n              errored = true;\\n              reject();\\n            }\\n          });\\n      };\\n      downloadQueue.pushTask(task);\\n    });\\n  });\\n}\\n```\\n\\n在上述代码中有几点值得我们注意的：\\n\\n* 首先，我们需要返回使用`Promise`构造函数创建的新的`Promise`对象。正如我们将看到的，这使我们能够在队列中的所有任务完成时手动`resolve`我们的`Promise`对象。\\n* 然后，我们应该看看我们如何定义任务。我们所做的是将一个`onFulfilled()`回调函数的调用添加到由`spider()`返回的`Promise`对象中，所以我们可以计算完成的下载任务的数量。当完成的下载量与当前页面中链接的数量相同时，我们知道任务已经处理完毕，所以我们可以调用外部`Promise`的`resolve()`函数。\\n\\n> Promises / A +规范规定，then()方法的onFulfilled()和onRejected()回调函数只能调用一次（仅调用onFulfilled()和onRejected()）。Promise接口的实现确保即使我们多次手动调用resolve或reject，Promise也仅可以被resolve或reject一次。\\n\\n现在，使用`Promise`的`Web爬虫应用程序`的第4版应该已经准备好了。我们可能再次注意到下载任务如何并行运行，并发数量限制为2。\\n\\n### 在公有API中暴露回调函数和Promise\\n正如我们在前面所学到的，`Promise`可以被用作回调函数的一个很好的替代品。它们使我们的代码更具可读性和易于理解。虽然`Promise`带来了许多优点，但也要求开发人员理解许多不易于理解的概念，以便正确和熟练地使用。由于这个原因和其他原因，在某些情况下，比起`Promise`来说，很多开发者更偏向于回调函数。\\n\\n现在让我们想象一下，我们想要构建一个执行异步操作的公共库。我们需要做什么？我们是创建了一个基于回调函数的`API`还是一个面向`Promise`的`API`？还是两者均有？\\n\\n这是许多知名的库所面临的问题，至少有两种方法值得一提，使我们能够提供一个多功能的`API`。\\n\\n像`request`，`redis`和`mysql`这样的库所使用的第一种方法是提供一个简单的基于回调函数的`API`，如果需要，开发人员可以选择公开函数。其中一些库提供工具函数来`Promise`化异步回调，但开发人员仍然需要以某种方式将暴露的`API`转换为能够使用`Promise`对象。\\n\\n第二种方法更透明。它还提供了一个面向回调的`API`，但它使回调参数可选。每当回调作为参数传递时，函数将正常运行，在完成时或失败时执行回调。当回调未被传递时，函数将立即返回一个`Promise`对象。这种方法有效地结合了回调函数和`Promise`，使得开发者可以在调用时选择采用什么接口，而不需要提前进行`Promise`化。许多库，如`mongoose`和`sequelize`，都支持这种方法。\\n\\n我们来看一个简单的例子。假设我们要实现一个异步执行除法的模块：\\n\\n```javascript\\nmodule.exports = function asyncDivision(dividend, divisor, cb) {\\n  return new Promise((resolve, reject) => { // [1]\\n    process.nextTick(() => {\\n      const result = dividend / divisor;\\n      if (isNaN(result) || !Number.isFinite(result)) {\\n        const error = new Error('Invalid operands');\\n        if (cb) {\\n          cb(error); // [2]\\n        }\\n        return reject(error);\\n      }\\n      if (cb) {\\n        cb(null, result); // [3]\\n      }\\n      resolve(result);\\n    });\\n  });\\n};\\n```\\n\\n该模块的代码非常简单，但是有一些值得强调的细节：\\n\\n* 首先，返回使用`Promise`的构造函数创建的新承诺。我们在构造函数参数函数内定义全部逻辑。\\n* 在发生错误的情况下，我们`reject`这个`Promise`，但如果回调函数在被调用时作为参数传递，我们也执行回调来进行错误传播。\\n* 在计算结果之后，我们`resolve`了这个`Promise`，但是如果有回调函数，我们也会将结果传播给回调函数。\\n\\n我们现在看如何用回调函数和`Promise`来使用这个模块：\\n\\n```javascript\\n// 回调函数的方式\\nasyncDivision(10, 2, (error, result) => {\\n  if (error) {\\n    return console.error(error);\\n  }\\n  console.log(result);\\n});\\n\\n// Promise化的调用方式\\nasyncDivision(22, 11)\\n  .then(result => console.log(result))\\n  .catch(error => console.error(error));\\n```\\n\\n应该很清楚的是，即将开始使用类似于上述的新模块的开发人员将很容易地选择最适合自己需求的风格，而无需在希望利用`Promise`时引入外部`promisification`功能。\\n\\n## Generators\\n`ES2015`规范引入了另外一种机制，除了其他新功能外，还可以用来简化`Node.js`应用程序的异步控制流程。我们正在谈论`Generator`，也被称为`semi-coroutines`。它们是子程序的一般化，可以有不同的入口点。在一个正常的函数中，实际上我们只能有一个入口点，这个入口点对应着函数本身的调用。`Generator`与一般函数类似，但是可以暂停（使用`yield`语句），然后在稍后继续执行。在实现迭代器时，`Generator`特别有用，因为我们已经讨论了如何使用迭代器来实现重要的异步控制流模式，如顺序执行和限制并行执行。\\n\\n### Generators基础\\n在我们探索使用`Generator`来实现异步控制流程之前，学习一些基本概念是很重要的。我们从语法开始吧。可以通过在函数关键字之后附加`*`（星号）运算符来声明`Generator`函数：\\n\\n```javascript\\nfunction* makeGenerator() {\\n  // body\\n}\\n```\\n\\n在`makeGenerator()`函数内部，我们可以使用关键字`yield`暂停执行并返回给调用者传递给它的值：\\n\\n```javascript\\nfunction* makeGenerator() {\\n  yield 'Hello World';\\n  console.log('Re-entered');\\n}\\n```\\n\\n在前面的代码中，`Generator`通过`yield`一个字符串`Hello World`暂停当前函数的执行。当`Generator`恢复时，执行将从下列语句开始：\\n\\n```javascript\\nconsole.log('Re-entered');\\n```\\n\\n`makeGenerator()`函数本质上是一个工厂，它在被调用时返回一个新的`Generator`对象：\\n\\n```javascript\\nconst gen = makeGenerator();\\n```\\n\\n生成器对象的最重要的方法是`next()`，它用于启动/恢复`Generator`的执行，并返回如下形式的对象：\\n\\n```\\n{\\n  value: <yielded value>\\n  done: <true if the execution reached the end>\\n}\\n```\\n\\n这个对象包含`Generator` `yield`的值和一个指示`Generator`是否已经完成执行的符号。\\n\\n### 一个简单的例子\\n为了演示`Generator`，我们来创建一个名为`fruitGenerator.js`的新模块：\\n\\n```javascript\\nfunction* fruitGenerator() {\\n  yield 'apple';\\n  yield 'orange';\\n  return 'watermelon';\\n}\\nconst newFruitGenerator = fruitGenerator();\\nconsole.log(newFruitGenerator.next()); // [1]\\nconsole.log(newFruitGenerator.next()); // [2]\\nconsole.log(newFruitGenerator.next()); // [3]\\n```\\n\\n前面的代码将打印下面的输出：\\n\\n```\\n{ value: 'apple', done: false }\\n{ value: 'orange', done: false }\\n{ value: 'watermelon', done: true }\\n```\\n\\n我们可以这么解释上述现象：\\n\\n* 第一次调用`newFruitGenerator.next()`时，`Generator`函数开始执行，直到达到第一个`yield`语句为止，该命令暂停`Generator`函数执行，并将值`apple`返回给调用者。\\n* 在第二次调用`newFruitGenerator.next()`时，`Generator`函数恢复执行，从第二个`yield`语句开始，这又使得执行暂停，同时将`orange`返回给调用者。\\n* `newFruitGenerator.next()`的最后一次调用导致`Generator`函数的执行从其最后的`yield`恢复，一个返回语句，它终止`Generator`函数，返回`watermelon`，并将结果对象中的`done`属性设置为`true`。\\n\\n### Generators作为迭代器\\n为了更好地理解为什么`Generator`函数对实现迭代器非常有用，我们来构建一个例子。在我们将调用`iteratorGenerator.js`的新模块中，我们编写下面的代码：\\n\\n```javascript\\nfunction* iteratorGenerator(arr) {\\n  for (let i = 0; i < arr.length; i++) {\\n    yield arr[i];\\n  }\\n}\\nconst iterator = iteratorGenerator(['apple', 'orange', 'watermelon']);\\nlet currentItem = iterator.next();\\nwhile (!currentItem.done) {\\n  console.log(currentItem.value);\\n  currentItem = iterator.next();\\n}\\n```\\n\\n此代码应按如下所示打印数组中的元素：\\n\\n```\\napple\\norange\\nwatermelon\\n```\\n\\n在这个例子中，每次我们调用`iterator.next()`时，我们都会恢复`Generator`函数的`for`循环，通过`yield`数组中的下一个项来运行另一个循环。这演示了如何在函数调用过程中维护`Generator`的状态。当继续执行时，循环和所有变量的值与`Generator`函数执行暂停时的状态完全相同。\\n\\n### 传值给Generators\\n现在我们继续研究`Generator`的基本功能，首先学习如何将值传递回`Generator`函数。这其实很简单，我们需要做的只是为`next()`方法提供一个参数，并且该值将作为`Generator`函数内的`yield`语句的返回值提供。\\n\\n为了展示这一点，我们来创建一个新的简单模块：\\n\\n```javascript\\nfunction* twoWayGenerator() {\\n  const what = yield null;\\n  console.log('Hello ' + what);\\n}\\nconst twoWay = twoWayGenerator();\\ntwoWay.next();\\ntwoWay.next('world');\\n```\\n\\n当执行时，前面的代码会输出`Hello world`。我们做如下的解释：\\n\\n* 第一次调用`next()`方法时，`Generator`函数到达第一个`yield`语句，然后暂停。\\n* 当`next('world')`被调用时，`Generator`函数从上次停止的位置，也就是上次的`yield`语句点恢复，但是这次我们有一个值传递到`Generator`函数。这个值将被赋值到`what`变量。生成器然后执行`console.log()`指令并终止。\\n\\n用类似的方式，我们可以强制`Generator`函数抛出异常。这可以通过使用`Generator`函数的`throw`方法来实现，如下例所示：\\n\\n```javascript\\nconst twoWay = twoWayGenerator();\\ntwoWay.next();\\ntwoWay.throw(new Error());\\n```\\n\\n在这个最后这段代码，`twoWayGenerator()`函数将在`yield`函数返回的时候抛出异常。这就好像从`Generator`函数内部抛出了一个异常一样，这意味着它可以像使用`try ... catch`块一样进行捕获和处理异常。\\n\\n### Generator实现异步控制流\\n你一定想知道`Generator`函数如何帮助我们处理异步操作。我们可以通过创建一个接受`Generator`函数作为参数的特殊函数来演示这一点，并允许我们在`Generator`函数内部使用异步代码。这个函数在异步操作完成时要注意恢复`Generator`函数的执行。我们将调用这个函数`asyncFlow()`：\\n\\n```javascript\\nfunction asyncFlow(generatorFunction) {\\n  function callback(err) {\\n    if (err) {\\n      return generator.throw(err);\\n    }\\n    const results = [].slice.call(arguments, 1);\\n    generator.next(results.length > 1 ? results : results[0]);\\n  }\\n  const generator = generatorFunction(callback);\\n  generator.next();\\n}\\n```\\n\\n前面的函数取一个`Generator`函数作为输入，然后立即调用：\\n\\n```javascript\\nconst generator = generatorFunction(callback);\\ngenerator.next();\\n```\\n\\n`generatorFunction()`接受一个特殊的回调函数作为参数，当`generator.throw()`如果接收到一个错误，便立即返回。另外，通过将在回调函数中接收的`results`传值回`Generator`函数继续`Generator`函数的执行:\\n\\n```javascript\\nif (err) {\\n  return generator.throw(err);\\n}\\nconst results = [].slice.call(arguments, 1);\\ngenerator.next(results.length > 1 ? results : results[0]);\\n```\\n\\n为了说明这个简单的辅助函数的强大，我们创建一个叫做`clone.js`的新模块，这个模块只是创建它本身的克隆。粘贴我们刚才创建的`asyncFlow()`函数，核心代码如下：\\n\\n```javascript\\nconst fs = require('fs');\\nconst path = require('path');\\nasyncFlow(function*(callback) {\\n  const fileName = path.basename(__filename);\\n  const myself = yield fs.readFile(fileName, 'utf8', callback);\\n  yield fs.writeFile(`clone_of_${filename}`, myself, callback);\\n  console.log('Clone created');\\n});\\n```\\n\\n明显地，有了`asyncFlow()`函数的帮助，我们可以像我们书写同步阻塞函数一样用同步的方式来书写异步代码了。并且这个结果背后的原理显得很清楚。一旦异步操作结束，传递给每个异步函数的回调函数将继续`Generator`函数的执行。没有什么复杂的，但是结果确实很令人意外。\\n\\n这个技术有其他两个变化，一个是`Promise`的使用，另外一个则是`thunks`。\\n\\n> 在基于Generator的控制流中使用的thunk只是一个简单的函数，它除了回调之外，部分地应用了原始函数的所有参数。返回值是另一个只接受回调作为参数的函数。例如，fs.readFile（）的thunkified版本如下所示：\\n\\n```javascript\\nfunction readFileThunk(filename, options) {\\n  return function(callback) {\\n    fs.readFile(filename, options, callback);\\n  }\\n}\\n```\\n\\n`thunk`和`Promise`都允许我们创建不需要回调的`Generator`函数作为参数传递，例如，使用`thunk`的`asyncFlow()`版本如下：\\n\\n```javascript\\nfunction asyncFlowWithThunks(generatorFunction) {\\n  function callback(err) {\\n    if (err) {\\n      return generator.throw(err);\\n    }\\n    const results = [].slice.call(arguments, 1);\\n    const thunk = generator.next(results.length > 1 ? results : results[0]).value;\\n    thunk && thunk(callback);\\n  }\\n  const generator = generatorFunction();\\n  const thunk = generator.next().value;\\n  thunk && thunk(callback);\\n}\\n```\\n\\n这个技巧是读取`generator.next()`的返回值，返回值中包含`thunk`。下一步是通过注入特殊的回调函数调用`thunk`本身。这允许我们写下面的代码：\\n\\n```javascript\\nasyncFlowWithThunk(function*() {\\n  const fileName = path.basename(__filename);\\n  const myself = yield readFileThunk(__filename, 'utf8');\\n  yield writeFileThunk(`clone_of_${fileName}`, myself);\\n  console.log(\\\"Clone created\\\")\\n});\\n```\\n\\n### 使用co的基于Gernator的控制流\\n你应该已经猜到了，`Node.js`生态系统会借助`Generator`函数来提供一些处理异步控制流的解决方案，例如，[suspend](https://npm/js.org/package/suspend)是其中一个最老的支持`Promise`、`thunks`和`Node.js`风格回调函数和正常风格的回调函数的 库。还有，大部分我们之前分析的`Promise`库都提供工具函数使得`Generator`和`Promise`可以一起使用。\\n\\n我们选择[co](https://npmjs.org/package/co)作为本章节的例子。它支持很多类型的`yieldables`，其中一些是：\\n\\n* `Thunks`\\n* `Promises`\\n* `Arrays`(并行执行)\\n* `Objects`(并行执行)\\n* `Generators`(委托)\\n* `Generator`函数(委托)\\n\\n还有很多框架或库是基于`co`生态系统的，包括以下一些：\\n\\n* `Web框架`，最流行的是[koa](https://npmjs.org/package/koa)\\n* 实现特定控制流模式的库\\n* 包装流行的`API`兼容`co`的库\\n\\n我们使用`co`重新实现我们的`Generator`版本的`Web爬虫应用程序`。\\n\\n为了将`Node.js`风格的函数转换成`thunks`，我们将会使用一个叫做[thunkify](https://npmjs.org/package/thunkify)的库。\\n\\n### 顺序执行\\n让我们通过修改`Web爬虫应用程序`的版本2开始我们对`Generator`函数和`co`的实际探索。我们要做的第一件事就是加载我们的依赖包，并生成我们要使用的函数的`thunkified`版本。这些将在`spider.js`模块的最开始进行：\\n\\n```javascript\\nconst thunkify = require('thunkify');\\nconst co = require('co');\\nconst request = thunkify(require('request'));\\nconst fs = require('fs');\\nconst mkdirp = thunkify(require('mkdirp'));\\nconst readFile = thunkify(fs.readFile);\\nconst writeFile = thunkify(fs.writeFile);\\nconst nextTick = thunkify(process.nextTick);\\n```\\n\\n看上述代码，我们可以注意到与本章前面`promisify`化的`API`的代码的一些相似之处。在这一点上，有意思的是，如果我们使用我们的`promisified`版本的函数来代替`thunkified`的版本，代码将保持完全一样，这要归功于`co`支持`thunk`和`Promise`对象作为`yieldable`对象。事实上，如果我们想，甚至可以在同一个应用程序中使用`thunk`和`Promise`，即使在同一个`Generator`函数中。就灵活性而言，这是一个巨大的优势，因为它使我们能够使用基于`Generator`函数的控制流来解决我们应用程序中的问题。\\n\\n好的，现在让我们开始将`download()`函数转换为一个`Generator`函数：\\n\\n```javascript\\nfunction* download(url, filename) {\\n  console.log(`Downloading ${url}`);\\n  const response = yield request(url);\\n  const body = response[1];\\n  yield mkdirp(path.dirname(filename));\\n  yield writeFile(filename, body);\\n  console.log(`Downloaded and saved ${url}`);\\n  return body;\\n}\\n```\\n\\n通过使用`Generator`和`co`，我们的`download()`函数变得简单多了。当我们需要做异步操作的时候，我们使用异步的`Generator`函数作为`thunk`来把之前的内容转化到`Generator`函数，并使用`yield`子句。\\n\\n然后我们开始实现我们的`spider()`函数：\\n\\n```javascript\\nfunction* spider(url, nesting) {\\n  cost filename = utilities.urlToFilename(url);\\n  let body;\\n  try {\\n    body = yield readFile(filename, 'utf8');\\n  } catch (err) {\\n    if (err.code !== 'ENOENT') {\\n      throw err;\\n    }\\n    body = yield download(url, filename);\\n  }\\n  yield spiderLinks(url, body, nesting);\\n}\\n```\\n\\n从上述代码中一个有趣的细节是我们可以使用`try...catch`语句块来处理异常。我们还可以使用`throw`来传播异常。另外一个细节是我们`yield`我们的`download()`函数，而这个函数既不是一个`thunk`，也不是一个`promisified`函数，只是另外的一个`Generator`函数。这也毫无问题，由于`co`也支持其他`Generators`作为`yieldables`。\\n\\n最后转换`spiderLinks()`，在这个函数中，我们递归下载一个网页的链接。在这个函数中使用`Generators`，显得简单多了：\\n\\n```javascript\\nfunction* spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return nextTick();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  for (let i = 0; i < links.length; i++) {\\n    yield spider(links[i], nesting - 1);\\n  }\\n}\\n```\\n\\n看上述代码。虽然顺序迭代没有什么模式可以展示。`Generator`和`co`辅助我们做了很多，方便了我们可以使用同步方式开书写异步代码。\\n\\n看最重要的部分，程序的入口：\\n\\n```javascript\\nco(function*() {\\n  try {\\n    yield spider(process.argv[2], 1);\\n    console.log(`Download complete`);\\n  } catch (err) {\\n    console.log(err);\\n  }\\n});\\n```\\n\\n这是唯一一处需要调用`co(...)`来封装的一个`Generator`。实际上，一旦我们这么做，`co`会自动封装我们传递给`yield`语句的任何`Generator`函数，并且这个过程是递归的，所以程序的剩余部分与我们是否使用`co`是完全无关的，虽然是被`co`封装在里面。\\n\\n现在应该可以运行使用`Generator`函数改写的`Web爬虫应用程序`了。\\n\\n### 并行执行\\n不幸的是，虽然`Generator`很方便地进行顺序执行，但是不能直接用来并行化执行一组任务，至少不能仅仅使用`yield`和`Generator`。之前，在种情况下我们使用的模式只是简单地依赖于一个基于回调或者`Promise`的函数，但使用了`Generator`函数后，一切会显得更简单。\\n\\n幸运的是，如果不限制并发数的并行执行，`co`已经可以通过`yield`一个`Promise`对象、`thunk`、`Generator`函数，甚至包含`Generator`函数的数组来实现。\\n\\n考虑到这一点，我们的`Web爬虫应用程序`第三版可以通过重写`spiderLinks()`函数来做如下改动：\\n\\n```javascript\\nfunction* spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return nextTick();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  const tasks = links.map(link => spider(link, nesting - 1));\\n  yield tasks;\\n}\\n```\\n\\n但是上述函数所做的只是拿到所有的任务，这些任务本质上都是通过`Generator`函数来实现异步的，如果在`co`的`thunk`内对一个包含`Generator`函数的数组使用`yield`，这些任务都会并行执行。外层的`Generator`函数会等到`yield`子句的所有异步任务并行执行后再继续执行。\\n\\n接下来我们看怎么用一个基于回调函数的方式来解决相同的并行流。我们用这种方式重写`spiderLinks()`函数：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return nextTick();\\n  }\\n  // 返回一个thunk\\n  return callback => {\\n    let completed = 0,\\n      hasErrors = false;\\n    const links = utilities.getPageLinks(currentUrl, body);\\n    if (links.length === 0) {\\n      return process.nextTick(callback);\\n    }\\n\\n    function done(err, result) {\\n      if (err && !hasErrors) {\\n        hasErrors = true;\\n        return callback(err);\\n      }\\n      if (++completed === links.length && !hasErrors) {\\n        callback();\\n      }\\n    }\\n    for (let i = 0; i < links.length; i++) {\\n      co(spider(links[i], nesting - 1)).then(done);\\n    }\\n  }\\n}\\n```\\n\\n我们使用`co`并行运行`spider()`函数，调用`Generator`函数返回了一个`Promise`对象。这样，等待`Promise`完成后调用`done()`函数。通常，基于`Generator`控制流的库都有这一功能，因此如果需要，你总是可以将一个`Generator`转换成一个基于回调或基于`Promise`的函数。\\n\\n为了并行开启多个下载任务，我们只要重用在前面定义的基于回调的并行执行的模式。我们应该也注意到我们将`spiderLinks()`转换成一个`thunk`(而不再是一个`Generator`函数)。这使得当全部并行任务完成时，我们有一个回调函数可以调用。\\n\\n> 上面讲到的是将一个Generator函数转换为一个thunk的模式，使之能够支持其他的基于回调或基于Promise的控制流算法，并可以通过同步阻塞的代码风格书写异步代码。\\n\\n### 限制并行执行\\n现在我们知道如何处理异步执行流程，应该很容易规划我们的`Web爬虫应用程序`的第四版的实现，这个版本对并发下载任务的数量施加了限制。我们有几个方案可以用来做到这一点。其中一些方案如下：\\n\\n* 使用先前实现的基于回调的`TaskQueue`类。我们只需要`thunkify`我们的`Generator`函数和其提供的回调函数即可。\\n* 使用基于`Promise`的`TaskQueue`类，并确保每个作为任务的`Generator`函数都被转换成一个返回`Promise`对象的函数。\\n* 使用`async`，`thunkify`我们打算使用的工具函数，此外还需要把我们用到的`Generator`函数转化为基于回调的模式，以便于能够被这个库较好地使用。\\n* 使用基于`co`的生态系统中的库，特别是专门为这种场景的库，如[co-limiter](https://npmjs.org/package/co-limiter)。\\n* 实现基于生产者 - 消费者模型的自定义算法，这与`co-limiter`的内部实现原理相同。\\n\\n为了学习，我们选择最后一个方案，甚至帮助我们可以更好地理解一种经常与协程(也和线程和进程)同步相关的模式。\\n\\n### 生产者 - 消费者模式\\n我们的目标是利用队列来提供固定数量的`workers`，与我们想要设置的并发级别一样多。为了实现这个算法，我们将基于本章前面定义的`TaskQueue`类改写：\\n\\n```javascript\\nclass TaskQueue {\\n  constructor(concurrency) {\\n    this.concurrency = concurrency;\\n    this.running = 0;\\n    this.taskQueue = [];\\n    this.consumerQueue = [];\\n    this.spawnWorkers(concurrency);\\n  }\\n  pushTask(task) {\\n    if (this.consumerQueue.length !== 0) {\\n      this.consumerQueue.shift()(null, task);\\n    } else {\\n      this.taskQueue.push(task);\\n    }\\n  }\\n  spawnWorkers(concurrency) {\\n    const self = this;\\n    for (let i = 0; i < concurrency; i++) {\\n      co(function*() {\\n        while (true) {\\n          const task = yield self.nextTask();\\n          yield task;\\n        }\\n      });\\n    }\\n  }\\n  nextTask() {\\n    return callback => {\\n      if (this.taskQueue.length !== 0) {\\n        return callback(null, this.taskQueue.shift());\\n      }\\n      this.consumerQueue.push(callback);\\n    }\\n  }\\n}\\n```\\n\\n让我们分析这个`TaskQueue`类的新实现。首先是在构造函数中。需要调用一次`this.spawnWorkers()`，因为这是启动`worker`的方法。\\n\\n我们的`worker`很简单，它们只是用`co()`包装的立即执行的`Generator`函数，所以每个`Generator`函数可以并行执行。在内部，每个`worker`正在运行在一个死循环（`while(true){}`）中，一直阻塞（`yield`）到新任务在队列中可用时（`yield self.nextTask()`），一旦可以执行新任务，`yield`这个异步任务直到其完成。您可能想知道我们如何能够限制并行执行，并让下一个任务在队列中处于等待状态。答案是在`nextTask()`方法中。我们来详细地看看在这个方法的原理：\\n\\n```javascript\\nnextTask() {\\n  return callback => {\\n    if (this.taskQueue.length !== 0) {\\n      return callback(null, this.taskQueue.shift());\\n    }\\n    this.consumerQueue.push(callback);\\n  }\\n}\\n```\\n\\n我们看这个函数内部发生了什么，这才是这个模式的核心：\\n\\n1. 这个方法返回一个对于`co`而言是一个合法的`yieldable`的`thunk`。\\n2. 只要`taskQueue`类生成的实例中还有下一个任务，`thunk`的回调函数会被立即调用。回调函数调用时，立马解锁一个`worker`的阻塞状态，`yield`这一个任务。\\n3. 如果队列中没有任务了，回调函数本身会被放入`consumerQueue`中。通过这种做法，我们将一个`worker`置于空闲（`idle`）的模式。一旦我们有一个新的任务来要处理，在`consumerQueue`队列中的回调函数会被调用，立马唤醒我们这一`worker`进行异步处理。\\n\\n现在，为了理解`consumerQueue`队列中的空闲`worker`是如何恢复工作的，我们需要分析`pushTask()`方法。如果当前有回调函数可用的话，`pushTask()`方法将调用`consumerQueue`队列中的第一个回调函数，从而将取消对`worker`的锁定。如果没有可用的回调函数，这意味着所有的`worker`都是工作状态，只需要添加一个新的任务到`taskQueue`任务队列中。\\n\\n在`TaskQueue`类中，`worker`充当消费者的角色，而调用`pushTask()`函数的角色可以被认为是生产者。这个模式向我们展示了一个`Generator`函数实际上可以跟一个线程或进程类似。实际上，生产者 - 消费者之间问题是研究进程间通信和同步时最常见的问题，但正如我们已经提到的那样，它对于进程和线程来说，也是一个常见的例子。\\n\\n### 限制下载任务的并发量\\n既然我们已经使用`Generator`函数和生产者 - 消费者模型实现一个限制并行算法，并且已经在`Web爬虫应用程序`第四版应用它来限制中下载任务的并发数。 首先，我们加载和初始化一个`TaskQueue`对象：\\n\\n```javascript\\nconst TaskQueue = require('./taskQueue');\\nconst downloadQueue = new TaskQueue(2);\\n```\\n\\n然后，修改`spiderLinks()`函数。和之前不限制并发的版本类似，所以这里我们只展示修改的部分，主要是通过调用新版本的`TaskQueue`类生成的实例的`pushTask()`方法来限制并行执行：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  //...\\n  return (callback) => {\\n    //...\\n    function done(err, result) {\\n      //...\\n    }\\n    links.forEach(function(link) {\\n      downloadQueue.pushTask(function*() {\\n        yield spider(link, nesting - 1);\\n        done();\\n      });\\n    });\\n  }\\n}\\n```\\n\\n在每个任务中，我们在下载完成后立即调用`done()`函数，因此我们可以计算下载了多少个链接，然后在完成下载时通知`thunk`的回调函数执行。\\n\\n## 配合Babel使用Async await新语法\\n回调函数、`Promise`和`Generator`函数都是用于处理`JavaScript`和`Node.js`异步问题的方式。正如我们所看到的，`Generator`的真正意义在于它提供了一种方式来暂停一个函数的执行，然后等待前面的任务完成后再继续执行。我们可以使用这样的特性来书写异步代码，并且让开发者用同步阻塞的代码风格来书写异步代码。等到异步操作的结果返回后才恢复当前函数的执行。\\n\\n但`Generator`函数是更多的是用来处理迭代器，然而迭代器在异步代码的使用显得有点笨重。代码可能难以理解，导致代码易读性和可维护性差。\\n\\n但在不远的将来会有一种更加简洁的语法。实际上，这个提议即将引入到`ESMASCript 2017`的规范中，这项规范定义了`async`函数语法。\\n\\n`async`函数规范引入两个关键字(`async`和`await`)到原生的`JavaScript`语言中，改进我们书写异步代码的方式。\\n\\n为了理解这项语法的用法和优势为，我们看一个简单的例子：\\n\\n```javascript\\nconst request = require('request');\\n\\nfunction getPageHtml(url) {\\n  return new Promise(function(resolve, reject) {\\n    request(url, function(error, response, body) {\\n      resolve(body);\\n    });\\n  });\\n}\\nasync function main() {\\n  const html = await getPageHtml('http://google.com');\\n  console.log(html);\\n}\\n\\nmain();\\nconsole.log('Loading...');\\n```\\n\\n在上述代码中，有两个函数：`getPageHtml`和`main`。第一个函数的作用是提取给定`URL`的一个远程网页的`HTML`文档代码。值得注意的是，这个函数返回一个`Promise`对象。\\n\\n重点在于`main`函数，因为在这里使用了`async`和`await`关键字。首先要注意的是函数要以`async`关键字为前缀。意思是这个函数执行的是异步代码并且允许它在函数体内使用`await`关键字。`await`关键字在`getPageHtml`调用之前，告诉`JavaScript`解释器在继续执行下一条指令之前，等待`getPageHtml`返回的`Promise`对象的结果。这样，`main`函数内部哪部分代码是异步的，它会等待异步代码的完成再继续执行后续操作，并且不会阻塞这段程序其余部分的正常执行。实际上，控制台会打印字符串`Loading...`，随后是Google主页的`HTML`代码。\\n\\n是不是这种方法的可读性更好并且更容易理解呢? 不幸地是，这个提议尚未定案，即使通过这个提议，我们需要等下一个版本\\n的`ECMAScript`规范出来并把它集成到`Node.js`后，才能使用这个新语法。 所以我们今天做了什么?只是漫无目的地等待?不是，当然不是！我们已经可以在我们的代码中使用`async await`语法，只要我们使用`Babel`。\\n\\n### 安装与运行Babel\\n`Babel`是一个`JavaScript`编译器(或翻译器)，能够使用语法转换器将高版本的`JavaScript`代码转换成其他`JavaScript`代码。语法转换器允许例如我们书写并使用`ES2015`，`ES2016`，`JSX`和其它的新语法，来翻译成往后兼容的代码，在`JavaScript`运行环境如浏览器或`Node.js`中都可以使用`Babel`。\\n\\n在项目中使用`npm`安装`Babel`，命令如下：\\n\\n```\\nnpm install --save-dev babel-cli\\n```\\n\\n我们还需要安装插件以支持`async await`语法的解释或翻译：\\n\\n```\\nnpm install --save-dev babel-plugin-syntax-async-functions babel-plugin-tranform-async-to-generator\\n```\\n\\n现在假设我们想运行我们之前的例子（称为`index.js`）。我们需要通过以下命令启动：\\n\\n```\\nnode_modules/.bin/babel-node --plugins \\\"syntax-async-functions,transform-async-to-generator\\\" index.js\\n```\\n\\n这样，我们使用支持`async await`的转换器动态地转换源代码。`Node.js`运行的实际是保存在内存中的往后兼容的代码。\\n\\n`Babel`也能被配置为一个代码构建工具，保存翻译或解释后的代码到本地文件系统中，便于我们部署和运行生成的代码。\\n\\n> 关于如何安装和配置Babel，可以到官方网站 https://babeljs.io 查阅相关文档。\\n\\n## 几种方式的比较\\n现在，我们应该对于怎么处理`JavaScript`的异步问题有了一个更好的认识和总结。在下面的表格中总结几大机制的优势和劣势：\\n\\n![](http://oczira72b.bkt.clouddn.com/17-11-7/55293366.jpg)\\n\\n> 值得一提的是，我们选择在本章中仅介绍处理异步控制流程的最受欢迎的解决方案，或者是广泛使用的解决方案，但是例如Fibers（ https://npmjs.org/package/fibers ）和Streamline（ https://npmjs.org/p ackage/streamline ）也是值得一看的。\\n\\n## 总结\\n在本章中，我们分析了一些处理异步控制流的方法，分析了`Promise`、`Generator`函数和即将到来的`async await`语法。\\n\\n我们学习了如何使用这些方法编写更简洁，更具有可读性的异步代码。我们讨论了这些方法的一些最重要的优点和缺点，并认识到即使它们非常有用，也需要一些时间来掌握。这就是这几种方式也没有完全取代在许多情况下仍然非常有用的回调的原因。作为一名开发人员，应该按照实际情况分析决定使用哪种解决方案。如果您正在构建执行异步操作的公共库，则应该提供易于使用的`API`，即使对于只想使用回调的开发人员也是如此。\\n\\n在下一章中，我们将探讨另一个与异步代码执行相关的机制，这也是整个`Node.js`生态系统中的另一个基本构建块：`streams`。\",\n        \"_id\": \"5a20d798b564820d22f6910a\",\n        \"replyChildList\": [],\n        \"replyTime\": \"2017-12-01T04:16:24.262Z\"\n      }\n    ],\n    \"label\": [],\n    \"replyNum\": 5,\n    \"viewed\": 53,\n    \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n  }\n}"
*************** response log end ***************

[2017-12-01 12:17:52.890] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/art/getArticleLists
request client ip:  ::1
request body: 
{"currentPage":1,"pageSize":10,"sortField":"lastReplyTime","totalElement":1,"labels":[],"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxNTc2LCJleHAiOjE1MTIxNDQ3NzZ9.uKBuLKHhVqQEXpCm68cxufPp3HqLhF25sI_3iT0rBmI"}
response time: 10
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": {\n    \"data\": [\n      {\n        \"_id\": \"5a0e8b7949b148371be1f96e\",\n        \"title\": \"fvf\",\n        \"content\": \"fvfv\",\n        \"author\": \"qichangjun\",\n        \"lastReplyTime\": \"2017-12-01T04:16:24.253Z\",\n        \"__v\": 0,\n        \"replyList\": [\n          {\n            \"userName\": \"admin\",\n            \"content\": \"hohoho\",\n            \"_id\": \"5a16847e98682e4e67834b7e\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-23T08:19:10.056Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"hohoho\",\n            \"_id\": \"5a16848198682e4e67834b80\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-23T08:19:13.567Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"hohoho\",\n            \"_id\": \"5a16848398682e4e67834b82\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-23T08:19:15.183Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"1111\",\n            \"_id\": \"5a179235954bda0eb0fb667e\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-24T03:29:57.318Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"# Asynchronous Control Flow Patterns with ES2015 and Beyond\\n在上一章中，我们学习了如何使用回调处理异步代码，以及如何解决如回调地狱代码等异步问题。回调是`JavaScript`和`Node.js`中的异步编程的基础，但是现在，其他替代方案已经出现。这些替代方案更复杂，以便能够以更方便的方式处理异步代码。\\n\\n在本章中，我们将探讨一些代表性的替代方案，`Promise`和`Generator`。以及`async await`，这是一种创新的语法，可在高版本的`JavaScript`中提供，其也作为`ECMAScript 2017`发行版的一部分。\\n\\n我们将看到这些替代方案如何简化处理异步控制流的方式。最后，我们将比较所有这些方法，以了解所有这些方法的所有优点和缺点，并能够明智地选择最适合我们下一个`Node.js`项目要求的方法。\\n\\n## Promise\\n我们在前面的章节中提到，`CPS风格`不是编写异步代码的唯一方法。事实上，`JavaScript`生态系统为传统的回调模式提供了有趣的替代方案。最着名的选择之一是`Promise`，特别是现在它是`ECMAScript 2015`的一部分，并且现在可以在`Node.js`中可用。\\n\\n### 什么是Promise？\\n`Promise`是一种抽象的对象，我们通常允许函数返回一个名为`Promise`的对象，它表示异步操作的最终结果。通常情况下，我们说当异步操作尚未完成时，我们说`Promise`对象处于`pending`状态，当操作成功完成时，我们说`Promise`对象处于`resolve`状态，当操作错误终止时，我们说`Promise`对象处于`reject`状态。一旦`Promise`处于`resolve`或`reject`，我们认为当前异步操作结束。\\n\\n为了接收到异步操作的正确结果或错误捕获，我们可以使用`Promise`的`then`方法：\\n\\n```javascript\\npromise.then([onFulfilled], [onRejected])\\n```\\n\\n在前面的代码中，`onFulfilled()`是一个函数，最终会收到`Promise`的正确结果，而`onRejected()`是另一个函数，它将接收产生异常的原因（如果有的话）。两个参数都是可选的。\\n\\n要了解`Promise`如何转换我们的代码，让我们考虑以下几点：\\n\\n```javascript\\nasyncOperation(arg, (err, result) => {\\n  if (err) {\\n    // 错误处理\\n  }\\n  // 正常结果处理\\n});\\n```\\n\\n`Promise`允许我们将这个典型的`CPS`代码转换成更好的结构化和更优雅的代码，如下所示：\\n\\n```javascript\\nasyncOperation(arg)\\n  .then(result => {\\n    // 错误处理\\n  }, err => {\\n    // 正常结果处理\\n  });\\n```\\n\\n`then()`方法的一个关键特征是它同步地返回另一个`Promise`对象。如果`onFulfilled()`或`onRejected()`函数中的任何一个函数返回`x`，则`then()`方法返回的`Promise`对象将如下所示：\\n\\n* 如果`x`是一个值，则这个`Promise`对象会正确处理(`resolve`)`x`\\n* 如果`x`是一个`Promise`对象或`thenable`，则会正确处理(`resolve`)`x`\\n* 如果`x`是一个异常，则会捕获异常(`reject`)`x`\\n\\n> 注：thenable是一个具有then方法的类似于Promise的对象(Promise-like)。\\n\\n这个特点使我们能够链式构建`Promise`，允许轻松排列组合我们的异步操作。另外，如果我们没有指定一个`onFulfilled()`或`onRejected()`处理程序，则正确结果或异常捕获将自动转发到`Promise`链的下一个`Promise`。例如，这允许我们在整个链中自动传播错误，直到被`onRejected()`处理程序捕获。随着`Promise`链，任务的顺序执行突然变成简单多了：\\n\\n```javascript\\nasyncOperation(arg)\\n  .then(result1 => {\\n    // 返回另一个Promise\\n    return asyncOperation(arg2);\\n  })\\n  .then(result2 => {\\n    // 返回一个值\\n    return 'done';\\n  })\\n  .then(undefined, err => {\\n    // 捕获Promise链中的异常\\n  });\\n```\\n\\n下图展示了链式`Promise`如何工作：\\n\\n![](http://oczira72b.bkt.clouddn.com/17-10-31/46370382.jpg)\\n\\n`Promise`的另一个重要特性是`onFulfilled()`和`onRejected()`函数是异步调用的，如同上述的例子，在最后那个`then`函数`resolve`一个同步的`Promise`，它也是同步的。这种模式避免了`Zalgo`（参见`Chapter2-Node.js Essential Patterns`），使我们的异步代码更加一致和稳健。\\n\\n如果在`onFulfilled()`或`onRejected()`处理程序中抛出异常（使用`throw`语句），则`then()`方法返回的`Promise`将被自动地`reject`，抛出异常作为`reject`的原因。这相对于`CPS`来说是一个巨大的优势，因为它意味着有了`Promise`，异常将在整个链中自动传播，并且`throw`语句终于可以使用。\\n\\n在以前，许多不同的库实现了`Promise`，大多数时候它们之间不兼容，这意味着不可能在使用不同`Promise`库的`thenable`链式传播错误。\\n\\n`JavaScript`社区非常努力地解决了这个限制，这些努力导致了`Promises / A +`规范的创建。该规范详细描述了`then`方法的行为，提供了一个可互兼容的基础，这使得来自不同库的`Promise`对象能够彼此兼容，开箱即用。\\n\\n有关`Promises / A +`规范的详细说明，可以参考[Promises / A + 官方网站](https://promisesaplus.com)。\\n\\n### Promise / A + 的实施\\n在`JavaScript`中以及`Node.js`中，有几个实现`Promises / A +`规范的库。以下是最受欢迎的：\\n\\n* [Bluebird](https://npmjs.org/package/bluebird)\\n* [Q](https://npmjs.org/package/q)\\n* [RSVP](https://npmjs.org/package/rsvp)\\n* [Vow](https://npmjs.org/package/vow)\\n* [When.js](https://npmjs.org/package/when)\\n* ES2015 promises\\n\\n真正区别他们的是在`Promises / A +`标准之上提供的额外功能。正如我们上述所说的那样，该标准定义了`then()`方法和`Promise`解析过程的行为，但它没有指定其他功能，例如，如何从基于回调的异步函数创建`Promise`。\\n\\n在我们的示例中，我们将使用由`ES2015`的`Promise`，因为`Promise`对象自`Node.js 4`后即可使用，而不需要任何库来实现。\\n\\n作为参考，以下是`ES2015`的`Promise`提供的API：\\n\\n`constructor`(`new Promise（function（resolve, reject）{}）`)：创建了一个新的`Promise`，它基于作为传递两个类型为函数的参数来决定`resolve`或`reject`。构造函数的参数解释如下：\\n\\n* `resolve(obj)` ：`resolve`一个`Promise`，并带上一个参数`obj`，如果`obj`是一个值，这个值就是传递的异步操作成功的结果。如果`obj`是一个`Promise`或一个`thenable`，则会进行正确处理。\\n* `reject(err)`：`reject`一个`Promise`，并带上一个参数`err`。它是`Error`对象的一个实例。\\n\\n#### Promise对象的静态方法\\n* `Promise.resolve(obj)`： 将会创建一个`resolve`的`Promise`实例\\n* `Promise.reject(err)`： 将会创建一个`reject`的`Promise`实例\\n* `Promise.all(iterable)`：返回一个新的`Promise`实例，并且在`iterable`中所\\n有`Promise`状态为`reject`时, 返回的`Promise`实例的状态会被置为`reject`，如果`iterable`中至少有一个`Promise`状态为`reject`时, 返回的`Promise`实例状态也会被置为`reject`，并且`reject`的原因是第一个被`reject`的`Promise`对象的`reject`原因。\\n* `Promise.race(iterable)`：返回一个`Promise`实例，当`iterable`中任何一个`Promise`被`resolve`或被`reject`时， 返回的`Promise`实例以同样的原因`resolve`或`reject`。\\n\\n#### Promise实例方法\\n* `Promise.then(onFulfilled, onRejected)`：这是`Promise`的基本方法。它的行为与我们之前描述的`Promises / A +`标准兼容。\\n* `Promise.catch(onRejected)`：这只是`Promise.then(undefined，onRejected)`的语法糖。\\n\\n> 值得一提的是，一些Promise实现提供了另一种机制来创建新的Promise，称为deferreds。我们不会在这里描述，因为它不是ES2015标准的一部分，但是如果您想了解更多信息，可以阅读Q文档 (https://github.com/kriskowal/q#using-deferreds) 或When.js文档 (https://github.com/cujojs/when/wiki/Deferred) 。\\n\\n### Promisifying一个Node.js回调风格的函数\\n在`JavaScript`中，并不是所有的异步函数和库都支持开箱即用的`Promise`。大多数情况下，我们必须将一个典型的基于回调的函数转换成一个返回`Promise`的函数，这个过程也被称为`promisification`。\\n\\n幸运的是，`Node.js`中使用的回调约定允许我们创建一个可重用的函数，我们通过使用`Promise`对象的构造函数来简化任何`Node.js`风格的`API`。让我们创建一个名为`promisify()`的新函数，并将其包含到`utilities.js`模块中（以便稍后在我们的`Web爬虫应用程序`中使用它）：\\n\\n```javascript\\nmodule.exports.promisify = function(callbackBasedApi) {\\n  return function promisified() {\\n    const args = [].slice.call(arguments);\\n    return new Promise((resolve, reject) => {\\n      args.push((err, result) => {\\n        if (err) {\\n          return reject(err);\\n        }\\n        if (arguments.length <= 2) {\\n          resolve(result);\\n        } else {\\n          resolve([].slice.call(arguments, 1));\\n        }\\n      });\\n      callbackBasedApi.apply(null, args);\\n    });\\n  }\\n};\\n```\\n\\n前面的函数返回另一个名为`promisified()`的函数，它表示输入中给出的`callbackBasedApi`的`promisified`版本。以下展示它是如何工作的：\\n\\n1. `promisified()`函数使用`Promise`构造函数创建一个新的`Promise`对象，并立即将其返回给调用者。\\n2. 在传递给`Promise`构造函数的函数中，我们确保传递给`callbackBasedApi`，这是一个特殊的回调函数。由于我们知道回调总是最后调用的，我们只需将回调函数附加到提供给`promisified()`函数的参数列表里（`args`）。\\n3. 在特殊的回调中，如果我们收到错误，我们立即`reject`这个`Promise`。\\n4. 如果没有收到错误，我们使用一个值或一个数组值来`resolve`这个`Promise`，具体取决于传递给回调的结果数量。\\n5. 最后，我们只需使用我们构建的参数列表调用`callbackBasedApi`。\\n\\n> 大部分的Promise已经提供了一个开箱即用的接口来将一个Node.js风格的API转换成一个返回Promise的API。例如，Q有Q.denodeify()和Q.nbind()，Bluebird有Promise.promisify()，而When.js有node.lift()。\\n\\n### 顺序执行\\n在一些必要的理论之后，我们现在准备将我们的`Web爬虫应用程序`转换为使用`Promise`的形式。让我们直接从版本2开始，直接下载一个Web网页的链接。\\n\\n在`spider.js`模块中，第一步是加载我们的`Promise`实现（我们稍后会使用它）和`Promisifying`我们打算使用的基于回调的函数：\\n\\n```javascript\\nconst utilities = require('./utilities');\\nconst request = utilities.promisify(require('request'));\\nconst mkdirp = utilities.promisify(require('mkdirp'));\\nconst fs = require('fs');\\nconst readFile = utilities.promisify(fs.readFile);\\nconst writeFile = utilities.promisify(fs.writeFile);\\n```\\n\\n现在，我们开始更改我们的`download`函数：\\n\\n```javascript\\nfunction download(url, filename) {\\n  console.log(`Downloading ${url}`);\\n  let body;\\n  return request(url)\\n    .then(response => {\\n      body = response.body;\\n      return mkdirp(path.dirname(filename));\\n    })\\n    .then(() => writeFile(filename, body))\\n    .then(() => {\\n      console.log(`Downloaded and saved: ${url}`);\\n      return body;\\n    });\\n}\\n```\\n\\n这里要注意的到的最重要的是我们也为`readFile()`返回的`Promise`注册\\n一个`onRejected()`函数，用来处理一个网页没有被下载的情况(或文件不存在)。 还有，看我们如何使用`throw`来传递`onRejected()`函数中的错误的。\\n\\n既然我们已经更改我们的`spider()`函数，我们这么修改它的调用方式：\\n\\n```javascript\\nspider(process.argv[2], 1)\\n  .then(() => console.log('Download complete'))\\n  .catch(err => console.log(err));\\n```\\n\\n注意我们是如何第一次使用`Promise`的语法糖`catch`来处理源自`spider()`函数的任何错误情况。如果我们再看看迄今为止我们所写的所有代码，那么我们会惊喜的发现，我们没有包含任何错误传播逻辑，因为我们在使用回调函数时会被迫做这样的事情。这显然是一个巨大的优势，因为它极大地减少了我们代码中的样板文件以及丢失任何异步错误的机会。\\n\\n现在，完成我们唯一缺失的`Web爬虫应用程序`的第二版的`spiderLinks()`函数，我们将在稍后实现它。\\n\\n### 顺序迭代\\n到目前为止，`Web爬虫应用程序`代码库主要是对`Promise`是什么以及如何使用的概述，展示了使用`Promise`实现顺序执行流程的简单性和优雅性。但是，我们现在考虑的代码只涉及到一组已知的异步操作的执行。所以，完成我们对顺序执行流程的探索的缺失部分是看我们如何使用`Promise`来实现迭代。同样，网络蜘蛛第二版的`spiderLinks()`函数也是一个很好的例子。\\n\\n让我们添加缺少的这一块：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  let promise = Promise.resolve();\\n  if (nesting === 0) {\\n    return promise;\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  links.forEach(link => {\\n    promise = promise.then(() => spider(link, nesting - 1));\\n  });\\n  return promise;\\n}\\n```\\n\\n为了异步迭代一个网页的全部链接，我们必须动态创建一个`Promise`的迭代链。\\n\\n1. 首先，我们定义一个空的`Promise`，`resolve`为`undefined`。这个`Promise`只是用来作为`Promise`的迭代链的起始点。 \\n2. 然后，我们通过在循环中调用链中前一个`Promise`的`then()`方法获得的新的`Promise`来更新`Promise`变量。这就是我们使用`Promise`的异步迭代模式。\\n\\n这样，循环的结束，`promise`变量会包含循环中最后一个`then()`返回的`Promise`对象，所以它只有当`Promise`的迭代链中全部`Promise`对象被`resolve`后才能被`resolve`。\\n\\n> 注：在最后调用了这个then方法来resolve这个Promise对象\\n\\n通过这个，我们已使用`Promise`对象重写了我们的`Web爬虫应用程序`。我们现在应该可以运行它了。\\n\\n### 顺序迭代模式\\n为了总结这个顺序执行的部分，让我们提取一个模式来依次遍历一组`Promise`：\\n\\n```javascript\\nlet tasks = [ /* ... */ ]\\nlet promise = Promise.resolve();\\ntasks.forEach(task => {\\n  promise = promise.then(() => {\\n    return task();\\n  });\\n});\\npromise.then(() => {\\n  // 所有任务都完成\\n});\\n```\\n\\n使用`reduce()`方法来替代`forEach()`方法，允许我们写出更为简洁的代码：\\n\\n```javascript\\nlet tasks = [ /* ... */ ]\\nlet promise = tasks.reduce((prev, task) => {\\n  return prev.then(() => {\\n    return task();\\n  });\\n}, Promise.resolve());\\n\\npromise.then(() => {\\n  //All tasks completed\\n});\\n```\\n\\n与往常一样，通过对这种模式的简单调整，我们可以将所有任务的结果收集到一个数组中，我们可以实现一个`mapping`算法，或者构建一个`filter`等等。\\n\\n> 上述这个模式使用循环动态地建立一个链式的Promise。\\n\\n### 并行执行\\n另一个适合用`Promise`的执行流程是并行执行流程。实际上，我们需要做的就是使用内置的`Promise.all()`。这个方法创造了另一个`Promise`对象，只有在输入中的所有`Promise`都`resolve`时才能`resolve`。这是一个并行执行，因为在其参数`Promise`对象的之间没有执行顺序可言。\\n\\n为了演示这一点，我们来看我们的`Web爬虫应用程序`的第三版，它将页面中的所有链接并行下载。让我们再次使用`Promise`更新`spiderLinks()`函数来实现并行流程：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return Promise.resolve();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  const promises = links.map(link => spider(link, nesting - 1));\\n  return Promise.all(promises);\\n}\\n```\\n\\n这里的模式在`elements.map()`迭代中产生一个数组，存放所有异步任务，之后便于同时启动`spider()`任务。这一次，在循环中，我们不等待以前的下载完成，然后开始一个新的下载任务：所有的下载任务在一个循环中一个接一个地开始。之后，我们利用`Promise.all()`方法，它返回一个新的`Promise`对象，当数组中的所有`Promise`对象都被`resolve`时，这个`Promise`对象将被`resolve`。换句话说，所有的下载任务完成，这正是我们想要的。\\n\\n### 限制并行执行\\n不幸的是，`ES2015`的`Promise API`并没有提供一种原生的方式来限制并发任务的数量，但是我们总是可以依靠我们所学到的有关用普通`JavaScript`来限制并发。事实上，我们在`TaskQueue`类中实现的模式可以很容易地被调整来支持返回承诺的任务。这很容易通过修改`next()`方法来完成：\\n\\n```javascript\\nclass TaskQueue {\\n  constructor(concurrency) {\\n    this.concurrency = concurrency;\\n    this.running = 0;\\n    this.queue = [];\\n  }\\n\\n  pushTask(task) {\\n    this.queue.push(task);\\n    this.next();\\n  }\\n\\n  next() {\\n    while (this.running < this.concurrency && this.queue.length) {\\n      const task = this.queue.shift();\\n      task().then(() => {\\n        this.running--;\\n        this.next();\\n      });\\n      this.running++;\\n    }\\n  }\\n}\\n```\\n\\n不同于使用一个回调函数来处理任务，我们简单地调用`Promise`的`then()`。\\n\\n让我们回到`spider.js`模块，并修改它以支持我们的新版本的`TaskQueue`类。首先，我们确保定义一个`TaskQueue`的新实例：\\n\\n```javascript\\nconst TaskQueue = require('./taskQueue');\\nconst downloadQueue = new TaskQueue(2);\\n```\\n\\n然后，是我们的`spiderLinks()`函数。这里的修改也是很简单：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return Promise.resolve();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  // 我们需要如下代码，用于创建Promise对象\\n  // 如果没有下列代码，当任务数量为0时，将永远不会resolve\\n  if (links.length === 0) {\\n    return Promise.resolve();\\n  }\\n  return new Promise((resolve, reject) => {\\n    let completed = 0;\\n    let errored = false;\\n    links.forEach(link => {\\n      let task = () => {\\n        return spider(link, nesting - 1)\\n          .then(() => {\\n            if (++completed === links.length) {\\n              resolve();\\n            }\\n          })\\n          .catch(() => {\\n            if (!errored) {\\n              errored = true;\\n              reject();\\n            }\\n          });\\n      };\\n      downloadQueue.pushTask(task);\\n    });\\n  });\\n}\\n```\\n\\n在上述代码中有几点值得我们注意的：\\n\\n* 首先，我们需要返回使用`Promise`构造函数创建的新的`Promise`对象。正如我们将看到的，这使我们能够在队列中的所有任务完成时手动`resolve`我们的`Promise`对象。\\n* 然后，我们应该看看我们如何定义任务。我们所做的是将一个`onFulfilled()`回调函数的调用添加到由`spider()`返回的`Promise`对象中，所以我们可以计算完成的下载任务的数量。当完成的下载量与当前页面中链接的数量相同时，我们知道任务已经处理完毕，所以我们可以调用外部`Promise`的`resolve()`函数。\\n\\n> Promises / A +规范规定，then()方法的onFulfilled()和onRejected()回调函数只能调用一次（仅调用onFulfilled()和onRejected()）。Promise接口的实现确保即使我们多次手动调用resolve或reject，Promise也仅可以被resolve或reject一次。\\n\\n现在，使用`Promise`的`Web爬虫应用程序`的第4版应该已经准备好了。我们可能再次注意到下载任务如何并行运行，并发数量限制为2。\\n\\n### 在公有API中暴露回调函数和Promise\\n正如我们在前面所学到的，`Promise`可以被用作回调函数的一个很好的替代品。它们使我们的代码更具可读性和易于理解。虽然`Promise`带来了许多优点，但也要求开发人员理解许多不易于理解的概念，以便正确和熟练地使用。由于这个原因和其他原因，在某些情况下，比起`Promise`来说，很多开发者更偏向于回调函数。\\n\\n现在让我们想象一下，我们想要构建一个执行异步操作的公共库。我们需要做什么？我们是创建了一个基于回调函数的`API`还是一个面向`Promise`的`API`？还是两者均有？\\n\\n这是许多知名的库所面临的问题，至少有两种方法值得一提，使我们能够提供一个多功能的`API`。\\n\\n像`request`，`redis`和`mysql`这样的库所使用的第一种方法是提供一个简单的基于回调函数的`API`，如果需要，开发人员可以选择公开函数。其中一些库提供工具函数来`Promise`化异步回调，但开发人员仍然需要以某种方式将暴露的`API`转换为能够使用`Promise`对象。\\n\\n第二种方法更透明。它还提供了一个面向回调的`API`，但它使回调参数可选。每当回调作为参数传递时，函数将正常运行，在完成时或失败时执行回调。当回调未被传递时，函数将立即返回一个`Promise`对象。这种方法有效地结合了回调函数和`Promise`，使得开发者可以在调用时选择采用什么接口，而不需要提前进行`Promise`化。许多库，如`mongoose`和`sequelize`，都支持这种方法。\\n\\n我们来看一个简单的例子。假设我们要实现一个异步执行除法的模块：\\n\\n```javascript\\nmodule.exports = function asyncDivision(dividend, divisor, cb) {\\n  return new Promise((resolve, reject) => { // [1]\\n    process.nextTick(() => {\\n      const result = dividend / divisor;\\n      if (isNaN(result) || !Number.isFinite(result)) {\\n        const error = new Error('Invalid operands');\\n        if (cb) {\\n          cb(error); // [2]\\n        }\\n        return reject(error);\\n      }\\n      if (cb) {\\n        cb(null, result); // [3]\\n      }\\n      resolve(result);\\n    });\\n  });\\n};\\n```\\n\\n该模块的代码非常简单，但是有一些值得强调的细节：\\n\\n* 首先，返回使用`Promise`的构造函数创建的新承诺。我们在构造函数参数函数内定义全部逻辑。\\n* 在发生错误的情况下，我们`reject`这个`Promise`，但如果回调函数在被调用时作为参数传递，我们也执行回调来进行错误传播。\\n* 在计算结果之后，我们`resolve`了这个`Promise`，但是如果有回调函数，我们也会将结果传播给回调函数。\\n\\n我们现在看如何用回调函数和`Promise`来使用这个模块：\\n\\n```javascript\\n// 回调函数的方式\\nasyncDivision(10, 2, (error, result) => {\\n  if (error) {\\n    return console.error(error);\\n  }\\n  console.log(result);\\n});\\n\\n// Promise化的调用方式\\nasyncDivision(22, 11)\\n  .then(result => console.log(result))\\n  .catch(error => console.error(error));\\n```\\n\\n应该很清楚的是，即将开始使用类似于上述的新模块的开发人员将很容易地选择最适合自己需求的风格，而无需在希望利用`Promise`时引入外部`promisification`功能。\\n\\n## Generators\\n`ES2015`规范引入了另外一种机制，除了其他新功能外，还可以用来简化`Node.js`应用程序的异步控制流程。我们正在谈论`Generator`，也被称为`semi-coroutines`。它们是子程序的一般化，可以有不同的入口点。在一个正常的函数中，实际上我们只能有一个入口点，这个入口点对应着函数本身的调用。`Generator`与一般函数类似，但是可以暂停（使用`yield`语句），然后在稍后继续执行。在实现迭代器时，`Generator`特别有用，因为我们已经讨论了如何使用迭代器来实现重要的异步控制流模式，如顺序执行和限制并行执行。\\n\\n### Generators基础\\n在我们探索使用`Generator`来实现异步控制流程之前，学习一些基本概念是很重要的。我们从语法开始吧。可以通过在函数关键字之后附加`*`（星号）运算符来声明`Generator`函数：\\n\\n```javascript\\nfunction* makeGenerator() {\\n  // body\\n}\\n```\\n\\n在`makeGenerator()`函数内部，我们可以使用关键字`yield`暂停执行并返回给调用者传递给它的值：\\n\\n```javascript\\nfunction* makeGenerator() {\\n  yield 'Hello World';\\n  console.log('Re-entered');\\n}\\n```\\n\\n在前面的代码中，`Generator`通过`yield`一个字符串`Hello World`暂停当前函数的执行。当`Generator`恢复时，执行将从下列语句开始：\\n\\n```javascript\\nconsole.log('Re-entered');\\n```\\n\\n`makeGenerator()`函数本质上是一个工厂，它在被调用时返回一个新的`Generator`对象：\\n\\n```javascript\\nconst gen = makeGenerator();\\n```\\n\\n生成器对象的最重要的方法是`next()`，它用于启动/恢复`Generator`的执行，并返回如下形式的对象：\\n\\n```\\n{\\n  value: <yielded value>\\n  done: <true if the execution reached the end>\\n}\\n```\\n\\n这个对象包含`Generator` `yield`的值和一个指示`Generator`是否已经完成执行的符号。\\n\\n### 一个简单的例子\\n为了演示`Generator`，我们来创建一个名为`fruitGenerator.js`的新模块：\\n\\n```javascript\\nfunction* fruitGenerator() {\\n  yield 'apple';\\n  yield 'orange';\\n  return 'watermelon';\\n}\\nconst newFruitGenerator = fruitGenerator();\\nconsole.log(newFruitGenerator.next()); // [1]\\nconsole.log(newFruitGenerator.next()); // [2]\\nconsole.log(newFruitGenerator.next()); // [3]\\n```\\n\\n前面的代码将打印下面的输出：\\n\\n```\\n{ value: 'apple', done: false }\\n{ value: 'orange', done: false }\\n{ value: 'watermelon', done: true }\\n```\\n\\n我们可以这么解释上述现象：\\n\\n* 第一次调用`newFruitGenerator.next()`时，`Generator`函数开始执行，直到达到第一个`yield`语句为止，该命令暂停`Generator`函数执行，并将值`apple`返回给调用者。\\n* 在第二次调用`newFruitGenerator.next()`时，`Generator`函数恢复执行，从第二个`yield`语句开始，这又使得执行暂停，同时将`orange`返回给调用者。\\n* `newFruitGenerator.next()`的最后一次调用导致`Generator`函数的执行从其最后的`yield`恢复，一个返回语句，它终止`Generator`函数，返回`watermelon`，并将结果对象中的`done`属性设置为`true`。\\n\\n### Generators作为迭代器\\n为了更好地理解为什么`Generator`函数对实现迭代器非常有用，我们来构建一个例子。在我们将调用`iteratorGenerator.js`的新模块中，我们编写下面的代码：\\n\\n```javascript\\nfunction* iteratorGenerator(arr) {\\n  for (let i = 0; i < arr.length; i++) {\\n    yield arr[i];\\n  }\\n}\\nconst iterator = iteratorGenerator(['apple', 'orange', 'watermelon']);\\nlet currentItem = iterator.next();\\nwhile (!currentItem.done) {\\n  console.log(currentItem.value);\\n  currentItem = iterator.next();\\n}\\n```\\n\\n此代码应按如下所示打印数组中的元素：\\n\\n```\\napple\\norange\\nwatermelon\\n```\\n\\n在这个例子中，每次我们调用`iterator.next()`时，我们都会恢复`Generator`函数的`for`循环，通过`yield`数组中的下一个项来运行另一个循环。这演示了如何在函数调用过程中维护`Generator`的状态。当继续执行时，循环和所有变量的值与`Generator`函数执行暂停时的状态完全相同。\\n\\n### 传值给Generators\\n现在我们继续研究`Generator`的基本功能，首先学习如何将值传递回`Generator`函数。这其实很简单，我们需要做的只是为`next()`方法提供一个参数，并且该值将作为`Generator`函数内的`yield`语句的返回值提供。\\n\\n为了展示这一点，我们来创建一个新的简单模块：\\n\\n```javascript\\nfunction* twoWayGenerator() {\\n  const what = yield null;\\n  console.log('Hello ' + what);\\n}\\nconst twoWay = twoWayGenerator();\\ntwoWay.next();\\ntwoWay.next('world');\\n```\\n\\n当执行时，前面的代码会输出`Hello world`。我们做如下的解释：\\n\\n* 第一次调用`next()`方法时，`Generator`函数到达第一个`yield`语句，然后暂停。\\n* 当`next('world')`被调用时，`Generator`函数从上次停止的位置，也就是上次的`yield`语句点恢复，但是这次我们有一个值传递到`Generator`函数。这个值将被赋值到`what`变量。生成器然后执行`console.log()`指令并终止。\\n\\n用类似的方式，我们可以强制`Generator`函数抛出异常。这可以通过使用`Generator`函数的`throw`方法来实现，如下例所示：\\n\\n```javascript\\nconst twoWay = twoWayGenerator();\\ntwoWay.next();\\ntwoWay.throw(new Error());\\n```\\n\\n在这个最后这段代码，`twoWayGenerator()`函数将在`yield`函数返回的时候抛出异常。这就好像从`Generator`函数内部抛出了一个异常一样，这意味着它可以像使用`try ... catch`块一样进行捕获和处理异常。\\n\\n### Generator实现异步控制流\\n你一定想知道`Generator`函数如何帮助我们处理异步操作。我们可以通过创建一个接受`Generator`函数作为参数的特殊函数来演示这一点，并允许我们在`Generator`函数内部使用异步代码。这个函数在异步操作完成时要注意恢复`Generator`函数的执行。我们将调用这个函数`asyncFlow()`：\\n\\n```javascript\\nfunction asyncFlow(generatorFunction) {\\n  function callback(err) {\\n    if (err) {\\n      return generator.throw(err);\\n    }\\n    const results = [].slice.call(arguments, 1);\\n    generator.next(results.length > 1 ? results : results[0]);\\n  }\\n  const generator = generatorFunction(callback);\\n  generator.next();\\n}\\n```\\n\\n前面的函数取一个`Generator`函数作为输入，然后立即调用：\\n\\n```javascript\\nconst generator = generatorFunction(callback);\\ngenerator.next();\\n```\\n\\n`generatorFunction()`接受一个特殊的回调函数作为参数，当`generator.throw()`如果接收到一个错误，便立即返回。另外，通过将在回调函数中接收的`results`传值回`Generator`函数继续`Generator`函数的执行:\\n\\n```javascript\\nif (err) {\\n  return generator.throw(err);\\n}\\nconst results = [].slice.call(arguments, 1);\\ngenerator.next(results.length > 1 ? results : results[0]);\\n```\\n\\n为了说明这个简单的辅助函数的强大，我们创建一个叫做`clone.js`的新模块，这个模块只是创建它本身的克隆。粘贴我们刚才创建的`asyncFlow()`函数，核心代码如下：\\n\\n```javascript\\nconst fs = require('fs');\\nconst path = require('path');\\nasyncFlow(function*(callback) {\\n  const fileName = path.basename(__filename);\\n  const myself = yield fs.readFile(fileName, 'utf8', callback);\\n  yield fs.writeFile(`clone_of_${filename}`, myself, callback);\\n  console.log('Clone created');\\n});\\n```\\n\\n明显地，有了`asyncFlow()`函数的帮助，我们可以像我们书写同步阻塞函数一样用同步的方式来书写异步代码了。并且这个结果背后的原理显得很清楚。一旦异步操作结束，传递给每个异步函数的回调函数将继续`Generator`函数的执行。没有什么复杂的，但是结果确实很令人意外。\\n\\n这个技术有其他两个变化，一个是`Promise`的使用，另外一个则是`thunks`。\\n\\n> 在基于Generator的控制流中使用的thunk只是一个简单的函数，它除了回调之外，部分地应用了原始函数的所有参数。返回值是另一个只接受回调作为参数的函数。例如，fs.readFile（）的thunkified版本如下所示：\\n\\n```javascript\\nfunction readFileThunk(filename, options) {\\n  return function(callback) {\\n    fs.readFile(filename, options, callback);\\n  }\\n}\\n```\\n\\n`thunk`和`Promise`都允许我们创建不需要回调的`Generator`函数作为参数传递，例如，使用`thunk`的`asyncFlow()`版本如下：\\n\\n```javascript\\nfunction asyncFlowWithThunks(generatorFunction) {\\n  function callback(err) {\\n    if (err) {\\n      return generator.throw(err);\\n    }\\n    const results = [].slice.call(arguments, 1);\\n    const thunk = generator.next(results.length > 1 ? results : results[0]).value;\\n    thunk && thunk(callback);\\n  }\\n  const generator = generatorFunction();\\n  const thunk = generator.next().value;\\n  thunk && thunk(callback);\\n}\\n```\\n\\n这个技巧是读取`generator.next()`的返回值，返回值中包含`thunk`。下一步是通过注入特殊的回调函数调用`thunk`本身。这允许我们写下面的代码：\\n\\n```javascript\\nasyncFlowWithThunk(function*() {\\n  const fileName = path.basename(__filename);\\n  const myself = yield readFileThunk(__filename, 'utf8');\\n  yield writeFileThunk(`clone_of_${fileName}`, myself);\\n  console.log(\\\"Clone created\\\")\\n});\\n```\\n\\n### 使用co的基于Gernator的控制流\\n你应该已经猜到了，`Node.js`生态系统会借助`Generator`函数来提供一些处理异步控制流的解决方案，例如，[suspend](https://npm/js.org/package/suspend)是其中一个最老的支持`Promise`、`thunks`和`Node.js`风格回调函数和正常风格的回调函数的 库。还有，大部分我们之前分析的`Promise`库都提供工具函数使得`Generator`和`Promise`可以一起使用。\\n\\n我们选择[co](https://npmjs.org/package/co)作为本章节的例子。它支持很多类型的`yieldables`，其中一些是：\\n\\n* `Thunks`\\n* `Promises`\\n* `Arrays`(并行执行)\\n* `Objects`(并行执行)\\n* `Generators`(委托)\\n* `Generator`函数(委托)\\n\\n还有很多框架或库是基于`co`生态系统的，包括以下一些：\\n\\n* `Web框架`，最流行的是[koa](https://npmjs.org/package/koa)\\n* 实现特定控制流模式的库\\n* 包装流行的`API`兼容`co`的库\\n\\n我们使用`co`重新实现我们的`Generator`版本的`Web爬虫应用程序`。\\n\\n为了将`Node.js`风格的函数转换成`thunks`，我们将会使用一个叫做[thunkify](https://npmjs.org/package/thunkify)的库。\\n\\n### 顺序执行\\n让我们通过修改`Web爬虫应用程序`的版本2开始我们对`Generator`函数和`co`的实际探索。我们要做的第一件事就是加载我们的依赖包，并生成我们要使用的函数的`thunkified`版本。这些将在`spider.js`模块的最开始进行：\\n\\n```javascript\\nconst thunkify = require('thunkify');\\nconst co = require('co');\\nconst request = thunkify(require('request'));\\nconst fs = require('fs');\\nconst mkdirp = thunkify(require('mkdirp'));\\nconst readFile = thunkify(fs.readFile);\\nconst writeFile = thunkify(fs.writeFile);\\nconst nextTick = thunkify(process.nextTick);\\n```\\n\\n看上述代码，我们可以注意到与本章前面`promisify`化的`API`的代码的一些相似之处。在这一点上，有意思的是，如果我们使用我们的`promisified`版本的函数来代替`thunkified`的版本，代码将保持完全一样，这要归功于`co`支持`thunk`和`Promise`对象作为`yieldable`对象。事实上，如果我们想，甚至可以在同一个应用程序中使用`thunk`和`Promise`，即使在同一个`Generator`函数中。就灵活性而言，这是一个巨大的优势，因为它使我们能够使用基于`Generator`函数的控制流来解决我们应用程序中的问题。\\n\\n好的，现在让我们开始将`download()`函数转换为一个`Generator`函数：\\n\\n```javascript\\nfunction* download(url, filename) {\\n  console.log(`Downloading ${url}`);\\n  const response = yield request(url);\\n  const body = response[1];\\n  yield mkdirp(path.dirname(filename));\\n  yield writeFile(filename, body);\\n  console.log(`Downloaded and saved ${url}`);\\n  return body;\\n}\\n```\\n\\n通过使用`Generator`和`co`，我们的`download()`函数变得简单多了。当我们需要做异步操作的时候，我们使用异步的`Generator`函数作为`thunk`来把之前的内容转化到`Generator`函数，并使用`yield`子句。\\n\\n然后我们开始实现我们的`spider()`函数：\\n\\n```javascript\\nfunction* spider(url, nesting) {\\n  cost filename = utilities.urlToFilename(url);\\n  let body;\\n  try {\\n    body = yield readFile(filename, 'utf8');\\n  } catch (err) {\\n    if (err.code !== 'ENOENT') {\\n      throw err;\\n    }\\n    body = yield download(url, filename);\\n  }\\n  yield spiderLinks(url, body, nesting);\\n}\\n```\\n\\n从上述代码中一个有趣的细节是我们可以使用`try...catch`语句块来处理异常。我们还可以使用`throw`来传播异常。另外一个细节是我们`yield`我们的`download()`函数，而这个函数既不是一个`thunk`，也不是一个`promisified`函数，只是另外的一个`Generator`函数。这也毫无问题，由于`co`也支持其他`Generators`作为`yieldables`。\\n\\n最后转换`spiderLinks()`，在这个函数中，我们递归下载一个网页的链接。在这个函数中使用`Generators`，显得简单多了：\\n\\n```javascript\\nfunction* spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return nextTick();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  for (let i = 0; i < links.length; i++) {\\n    yield spider(links[i], nesting - 1);\\n  }\\n}\\n```\\n\\n看上述代码。虽然顺序迭代没有什么模式可以展示。`Generator`和`co`辅助我们做了很多，方便了我们可以使用同步方式开书写异步代码。\\n\\n看最重要的部分，程序的入口：\\n\\n```javascript\\nco(function*() {\\n  try {\\n    yield spider(process.argv[2], 1);\\n    console.log(`Download complete`);\\n  } catch (err) {\\n    console.log(err);\\n  }\\n});\\n```\\n\\n这是唯一一处需要调用`co(...)`来封装的一个`Generator`。实际上，一旦我们这么做，`co`会自动封装我们传递给`yield`语句的任何`Generator`函数，并且这个过程是递归的，所以程序的剩余部分与我们是否使用`co`是完全无关的，虽然是被`co`封装在里面。\\n\\n现在应该可以运行使用`Generator`函数改写的`Web爬虫应用程序`了。\\n\\n### 并行执行\\n不幸的是，虽然`Generator`很方便地进行顺序执行，但是不能直接用来并行化执行一组任务，至少不能仅仅使用`yield`和`Generator`。之前，在种情况下我们使用的模式只是简单地依赖于一个基于回调或者`Promise`的函数，但使用了`Generator`函数后，一切会显得更简单。\\n\\n幸运的是，如果不限制并发数的并行执行，`co`已经可以通过`yield`一个`Promise`对象、`thunk`、`Generator`函数，甚至包含`Generator`函数的数组来实现。\\n\\n考虑到这一点，我们的`Web爬虫应用程序`第三版可以通过重写`spiderLinks()`函数来做如下改动：\\n\\n```javascript\\nfunction* spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return nextTick();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  const tasks = links.map(link => spider(link, nesting - 1));\\n  yield tasks;\\n}\\n```\\n\\n但是上述函数所做的只是拿到所有的任务，这些任务本质上都是通过`Generator`函数来实现异步的，如果在`co`的`thunk`内对一个包含`Generator`函数的数组使用`yield`，这些任务都会并行执行。外层的`Generator`函数会等到`yield`子句的所有异步任务并行执行后再继续执行。\\n\\n接下来我们看怎么用一个基于回调函数的方式来解决相同的并行流。我们用这种方式重写`spiderLinks()`函数：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return nextTick();\\n  }\\n  // 返回一个thunk\\n  return callback => {\\n    let completed = 0,\\n      hasErrors = false;\\n    const links = utilities.getPageLinks(currentUrl, body);\\n    if (links.length === 0) {\\n      return process.nextTick(callback);\\n    }\\n\\n    function done(err, result) {\\n      if (err && !hasErrors) {\\n        hasErrors = true;\\n        return callback(err);\\n      }\\n      if (++completed === links.length && !hasErrors) {\\n        callback();\\n      }\\n    }\\n    for (let i = 0; i < links.length; i++) {\\n      co(spider(links[i], nesting - 1)).then(done);\\n    }\\n  }\\n}\\n```\\n\\n我们使用`co`并行运行`spider()`函数，调用`Generator`函数返回了一个`Promise`对象。这样，等待`Promise`完成后调用`done()`函数。通常，基于`Generator`控制流的库都有这一功能，因此如果需要，你总是可以将一个`Generator`转换成一个基于回调或基于`Promise`的函数。\\n\\n为了并行开启多个下载任务，我们只要重用在前面定义的基于回调的并行执行的模式。我们应该也注意到我们将`spiderLinks()`转换成一个`thunk`(而不再是一个`Generator`函数)。这使得当全部并行任务完成时，我们有一个回调函数可以调用。\\n\\n> 上面讲到的是将一个Generator函数转换为一个thunk的模式，使之能够支持其他的基于回调或基于Promise的控制流算法，并可以通过同步阻塞的代码风格书写异步代码。\\n\\n### 限制并行执行\\n现在我们知道如何处理异步执行流程，应该很容易规划我们的`Web爬虫应用程序`的第四版的实现，这个版本对并发下载任务的数量施加了限制。我们有几个方案可以用来做到这一点。其中一些方案如下：\\n\\n* 使用先前实现的基于回调的`TaskQueue`类。我们只需要`thunkify`我们的`Generator`函数和其提供的回调函数即可。\\n* 使用基于`Promise`的`TaskQueue`类，并确保每个作为任务的`Generator`函数都被转换成一个返回`Promise`对象的函数。\\n* 使用`async`，`thunkify`我们打算使用的工具函数，此外还需要把我们用到的`Generator`函数转化为基于回调的模式，以便于能够被这个库较好地使用。\\n* 使用基于`co`的生态系统中的库，特别是专门为这种场景的库，如[co-limiter](https://npmjs.org/package/co-limiter)。\\n* 实现基于生产者 - 消费者模型的自定义算法，这与`co-limiter`的内部实现原理相同。\\n\\n为了学习，我们选择最后一个方案，甚至帮助我们可以更好地理解一种经常与协程(也和线程和进程)同步相关的模式。\\n\\n### 生产者 - 消费者模式\\n我们的目标是利用队列来提供固定数量的`workers`，与我们想要设置的并发级别一样多。为了实现这个算法，我们将基于本章前面定义的`TaskQueue`类改写：\\n\\n```javascript\\nclass TaskQueue {\\n  constructor(concurrency) {\\n    this.concurrency = concurrency;\\n    this.running = 0;\\n    this.taskQueue = [];\\n    this.consumerQueue = [];\\n    this.spawnWorkers(concurrency);\\n  }\\n  pushTask(task) {\\n    if (this.consumerQueue.length !== 0) {\\n      this.consumerQueue.shift()(null, task);\\n    } else {\\n      this.taskQueue.push(task);\\n    }\\n  }\\n  spawnWorkers(concurrency) {\\n    const self = this;\\n    for (let i = 0; i < concurrency; i++) {\\n      co(function*() {\\n        while (true) {\\n          const task = yield self.nextTask();\\n          yield task;\\n        }\\n      });\\n    }\\n  }\\n  nextTask() {\\n    return callback => {\\n      if (this.taskQueue.length !== 0) {\\n        return callback(null, this.taskQueue.shift());\\n      }\\n      this.consumerQueue.push(callback);\\n    }\\n  }\\n}\\n```\\n\\n让我们分析这个`TaskQueue`类的新实现。首先是在构造函数中。需要调用一次`this.spawnWorkers()`，因为这是启动`worker`的方法。\\n\\n我们的`worker`很简单，它们只是用`co()`包装的立即执行的`Generator`函数，所以每个`Generator`函数可以并行执行。在内部，每个`worker`正在运行在一个死循环（`while(true){}`）中，一直阻塞（`yield`）到新任务在队列中可用时（`yield self.nextTask()`），一旦可以执行新任务，`yield`这个异步任务直到其完成。您可能想知道我们如何能够限制并行执行，并让下一个任务在队列中处于等待状态。答案是在`nextTask()`方法中。我们来详细地看看在这个方法的原理：\\n\\n```javascript\\nnextTask() {\\n  return callback => {\\n    if (this.taskQueue.length !== 0) {\\n      return callback(null, this.taskQueue.shift());\\n    }\\n    this.consumerQueue.push(callback);\\n  }\\n}\\n```\\n\\n我们看这个函数内部发生了什么，这才是这个模式的核心：\\n\\n1. 这个方法返回一个对于`co`而言是一个合法的`yieldable`的`thunk`。\\n2. 只要`taskQueue`类生成的实例中还有下一个任务，`thunk`的回调函数会被立即调用。回调函数调用时，立马解锁一个`worker`的阻塞状态，`yield`这一个任务。\\n3. 如果队列中没有任务了，回调函数本身会被放入`consumerQueue`中。通过这种做法，我们将一个`worker`置于空闲（`idle`）的模式。一旦我们有一个新的任务来要处理，在`consumerQueue`队列中的回调函数会被调用，立马唤醒我们这一`worker`进行异步处理。\\n\\n现在，为了理解`consumerQueue`队列中的空闲`worker`是如何恢复工作的，我们需要分析`pushTask()`方法。如果当前有回调函数可用的话，`pushTask()`方法将调用`consumerQueue`队列中的第一个回调函数，从而将取消对`worker`的锁定。如果没有可用的回调函数，这意味着所有的`worker`都是工作状态，只需要添加一个新的任务到`taskQueue`任务队列中。\\n\\n在`TaskQueue`类中，`worker`充当消费者的角色，而调用`pushTask()`函数的角色可以被认为是生产者。这个模式向我们展示了一个`Generator`函数实际上可以跟一个线程或进程类似。实际上，生产者 - 消费者之间问题是研究进程间通信和同步时最常见的问题，但正如我们已经提到的那样，它对于进程和线程来说，也是一个常见的例子。\\n\\n### 限制下载任务的并发量\\n既然我们已经使用`Generator`函数和生产者 - 消费者模型实现一个限制并行算法，并且已经在`Web爬虫应用程序`第四版应用它来限制中下载任务的并发数。 首先，我们加载和初始化一个`TaskQueue`对象：\\n\\n```javascript\\nconst TaskQueue = require('./taskQueue');\\nconst downloadQueue = new TaskQueue(2);\\n```\\n\\n然后，修改`spiderLinks()`函数。和之前不限制并发的版本类似，所以这里我们只展示修改的部分，主要是通过调用新版本的`TaskQueue`类生成的实例的`pushTask()`方法来限制并行执行：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  //...\\n  return (callback) => {\\n    //...\\n    function done(err, result) {\\n      //...\\n    }\\n    links.forEach(function(link) {\\n      downloadQueue.pushTask(function*() {\\n        yield spider(link, nesting - 1);\\n        done();\\n      });\\n    });\\n  }\\n}\\n```\\n\\n在每个任务中，我们在下载完成后立即调用`done()`函数，因此我们可以计算下载了多少个链接，然后在完成下载时通知`thunk`的回调函数执行。\\n\\n## 配合Babel使用Async await新语法\\n回调函数、`Promise`和`Generator`函数都是用于处理`JavaScript`和`Node.js`异步问题的方式。正如我们所看到的，`Generator`的真正意义在于它提供了一种方式来暂停一个函数的执行，然后等待前面的任务完成后再继续执行。我们可以使用这样的特性来书写异步代码，并且让开发者用同步阻塞的代码风格来书写异步代码。等到异步操作的结果返回后才恢复当前函数的执行。\\n\\n但`Generator`函数是更多的是用来处理迭代器，然而迭代器在异步代码的使用显得有点笨重。代码可能难以理解，导致代码易读性和可维护性差。\\n\\n但在不远的将来会有一种更加简洁的语法。实际上，这个提议即将引入到`ESMASCript 2017`的规范中，这项规范定义了`async`函数语法。\\n\\n`async`函数规范引入两个关键字(`async`和`await`)到原生的`JavaScript`语言中，改进我们书写异步代码的方式。\\n\\n为了理解这项语法的用法和优势为，我们看一个简单的例子：\\n\\n```javascript\\nconst request = require('request');\\n\\nfunction getPageHtml(url) {\\n  return new Promise(function(resolve, reject) {\\n    request(url, function(error, response, body) {\\n      resolve(body);\\n    });\\n  });\\n}\\nasync function main() {\\n  const html = await getPageHtml('http://google.com');\\n  console.log(html);\\n}\\n\\nmain();\\nconsole.log('Loading...');\\n```\\n\\n在上述代码中，有两个函数：`getPageHtml`和`main`。第一个函数的作用是提取给定`URL`的一个远程网页的`HTML`文档代码。值得注意的是，这个函数返回一个`Promise`对象。\\n\\n重点在于`main`函数，因为在这里使用了`async`和`await`关键字。首先要注意的是函数要以`async`关键字为前缀。意思是这个函数执行的是异步代码并且允许它在函数体内使用`await`关键字。`await`关键字在`getPageHtml`调用之前，告诉`JavaScript`解释器在继续执行下一条指令之前，等待`getPageHtml`返回的`Promise`对象的结果。这样，`main`函数内部哪部分代码是异步的，它会等待异步代码的完成再继续执行后续操作，并且不会阻塞这段程序其余部分的正常执行。实际上，控制台会打印字符串`Loading...`，随后是Google主页的`HTML`代码。\\n\\n是不是这种方法的可读性更好并且更容易理解呢? 不幸地是，这个提议尚未定案，即使通过这个提议，我们需要等下一个版本\\n的`ECMAScript`规范出来并把它集成到`Node.js`后，才能使用这个新语法。 所以我们今天做了什么?只是漫无目的地等待?不是，当然不是！我们已经可以在我们的代码中使用`async await`语法，只要我们使用`Babel`。\\n\\n### 安装与运行Babel\\n`Babel`是一个`JavaScript`编译器(或翻译器)，能够使用语法转换器将高版本的`JavaScript`代码转换成其他`JavaScript`代码。语法转换器允许例如我们书写并使用`ES2015`，`ES2016`，`JSX`和其它的新语法，来翻译成往后兼容的代码，在`JavaScript`运行环境如浏览器或`Node.js`中都可以使用`Babel`。\\n\\n在项目中使用`npm`安装`Babel`，命令如下：\\n\\n```\\nnpm install --save-dev babel-cli\\n```\\n\\n我们还需要安装插件以支持`async await`语法的解释或翻译：\\n\\n```\\nnpm install --save-dev babel-plugin-syntax-async-functions babel-plugin-tranform-async-to-generator\\n```\\n\\n现在假设我们想运行我们之前的例子（称为`index.js`）。我们需要通过以下命令启动：\\n\\n```\\nnode_modules/.bin/babel-node --plugins \\\"syntax-async-functions,transform-async-to-generator\\\" index.js\\n```\\n\\n这样，我们使用支持`async await`的转换器动态地转换源代码。`Node.js`运行的实际是保存在内存中的往后兼容的代码。\\n\\n`Babel`也能被配置为一个代码构建工具，保存翻译或解释后的代码到本地文件系统中，便于我们部署和运行生成的代码。\\n\\n> 关于如何安装和配置Babel，可以到官方网站 https://babeljs.io 查阅相关文档。\\n\\n## 几种方式的比较\\n现在，我们应该对于怎么处理`JavaScript`的异步问题有了一个更好的认识和总结。在下面的表格中总结几大机制的优势和劣势：\\n\\n![](http://oczira72b.bkt.clouddn.com/17-11-7/55293366.jpg)\\n\\n> 值得一提的是，我们选择在本章中仅介绍处理异步控制流程的最受欢迎的解决方案，或者是广泛使用的解决方案，但是例如Fibers（ https://npmjs.org/package/fibers ）和Streamline（ https://npmjs.org/p ackage/streamline ）也是值得一看的。\\n\\n## 总结\\n在本章中，我们分析了一些处理异步控制流的方法，分析了`Promise`、`Generator`函数和即将到来的`async await`语法。\\n\\n我们学习了如何使用这些方法编写更简洁，更具有可读性的异步代码。我们讨论了这些方法的一些最重要的优点和缺点，并认识到即使它们非常有用，也需要一些时间来掌握。这就是这几种方式也没有完全取代在许多情况下仍然非常有用的回调的原因。作为一名开发人员，应该按照实际情况分析决定使用哪种解决方案。如果您正在构建执行异步操作的公共库，则应该提供易于使用的`API`，即使对于只想使用回调的开发人员也是如此。\\n\\n在下一章中，我们将探讨另一个与异步代码执行相关的机制，这也是整个`Node.js`生态系统中的另一个基本构建块：`streams`。\",\n            \"_id\": \"5a20d798b564820d22f6910a\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-12-01T04:16:24.262Z\"\n          }\n        ],\n        \"label\": [],\n        \"replyNum\": 5,\n        \"viewed\": 53,\n        \"creatDate\": \"2017-11-17T07:10:49.242Z\"\n      },\n      {\n        \"_id\": \"5a1785b3bbb11c04f3f739ea\",\n        \"title\": \"asd\",\n        \"content\": \"sadsads\",\n        \"author\": \"admin\",\n        \"lastReplyTime\": \"2017-11-24T02:36:35.619Z\",\n        \"__v\": 0,\n        \"replyList\": [],\n        \"label\": [\n          \"111\",\n          \"222\"\n        ],\n        \"replyNum\": 0,\n        \"viewed\": 1,\n        \"creatDate\": \"2017-11-24T02:36:35.619Z\"\n      },\n      {\n        \"_id\": \"5a0e8b7f49b148371be1f96f\",\n        \"title\": \"vedvde\",\n        \"content\": \"vdve\",\n        \"author\": \"qichangjun\",\n        \"lastReplyTime\": \"2017-11-23T08:18:03.507Z\",\n        \"__v\": 0,\n        \"replyList\": [\n          {\n            \"userName\": \"qichangjun\",\n            \"content\": \"dd\",\n            \"_id\": \"5a0e8cd449b148371be1f971\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-17T07:16:36.427Z\"\n          },\n          {\n            \"userName\": \"qichangjun\",\n            \"content\": \"ddcc\",\n            \"_id\": \"5a0e8cd849b148371be1f972\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-17T07:16:40.748Z\"\n          },\n          {\n            \"userName\": \"qichangjun\",\n            \"content\": \"ddccxxsa\",\n            \"_id\": \"5a0e8cdb49b148371be1f973\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-17T07:16:43.954Z\"\n          },\n          {\n            \"userName\": \"qichangjun\",\n            \"content\": \"![32f8b3d82fc63.jpg](http://7xpyje.com1.z0.glb.clouddn.com/32f8b3d82fc63.jpg)\",\n            \"_id\": \"5a0e956027648c3bc64a8f77\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-17T07:53:04.705Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"![1edca434719e2.png](http://7xpyje.com1.z0.glb.clouddn.com/1edca434719e2.png?imageView2/1/w/400/h/400/q/75|watermark/2/text/5bCP5LiD5Y2a5a6i/font/5a6L5L2T/fontsize/400/fill/I0RBQ0RDRA==/dissolve/48/gravity/SouthEast/dx/10/dy/10|imageslim)\",\n            \"_id\": \"5a1230b76b9523050f9cff65\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-20T01:32:39.609Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"hahaha\",\n            \"_id\": \"5a16843b98682e4e67834b7c\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-23T08:18:03.507Z\"\n          }\n        ],\n        \"label\": [],\n        \"replyNum\": 6,\n        \"viewed\": 31,\n        \"creatDate\": \"2017-11-17T07:10:55.336Z\"\n      },\n      {\n        \"_id\": \"5a14ddccfcab6103ee8315f8\",\n        \"title\": \"aaaa\",\n        \"content\": \"![0c88904a90297.png](http://7xpyje.com1.z0.glb.clouddn.com/0c88904a90297.png?imageView2/1/w/400/h/400/q/75|watermark/2/text/5bCP5LiD5Y2a5a6i/font/5a6L5L2T/fontsize/400/fill/I0RBQ0RDRA==/dissolve/48/gravity/SouthEast/dx/10/dy/10|imageslim)\",\n        \"author\": \"admin\",\n        \"lastReplyTime\": \"2017-11-23T08:17:45.908Z\",\n        \"__v\": 0,\n        \"replyList\": [\n          {\n            \"userName\": \"admin\",\n            \"content\": \" \\n[aaaa](http://baidu.com)\",\n            \"_id\": \"5a14ef1afcab6103ee8315fb\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-22T03:29:30.148Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"abc\",\n            \"_id\": \"5a1679e2fc7df847971b2c10\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-23T07:33:54.750Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"bdcd\",\n            \"_id\": \"5a167a45b5e32e47bd287713\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-23T07:35:33.273Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"bdea\",\n            \"_id\": \"5a167ac7149269481c27a09d\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-23T07:37:43.576Z\"\n          },\n          {\n            \"userName\": \"admin\",\n            \"content\": \"bdba\",\n            \"_id\": \"5a16842998682e4e67834b7b\",\n            \"replyChildList\": [],\n            \"replyTime\": \"2017-11-23T08:17:45.908Z\"\n          }\n        ],\n        \"label\": [],\n        \"replyNum\": 5,\n        \"viewed\": 112,\n        \"creatDate\": \"2017-11-22T02:15:40.492Z\"\n      },\n      {\n        \"_id\": \"5a13dd0b2874a8757e13e9ed\",\n        \"title\": \"ghhhh\",\n        \"content\": \"gggerge\",\n        \"author\": \"admin\",\n        \"lastReplyTime\": \"2017-11-21T08:00:11.544Z\",\n        \"__v\": 0,\n        \"replyList\": [],\n        \"label\": [\n          \"angular\"\n        ],\n        \"replyNum\": 0,\n        \"viewed\": 49,\n        \"creatDate\": \"2017-11-21T08:00:11.544Z\"\n      },\n      {\n        \"_id\": \"5a13dcea314c147535a700b7\",\n        \"title\": \"ghhhh\",\n        \"content\": \"gggerge\",\n        \"author\": \"admin\",\n        \"lastReplyTime\": \"2017-11-21T07:59:38.425Z\",\n        \"__v\": 0,\n        \"replyList\": [],\n        \"label\": [\n          \"angular\"\n        ],\n        \"replyNum\": 0,\n        \"viewed\": 1,\n        \"creatDate\": \"2017-11-21T07:59:38.425Z\"\n      },\n      {\n        \"_id\": \"5a13dcca314c147535a700b4\",\n        \"title\": \"测试标签\",\n        \"content\": \"测试标签\",\n        \"author\": \"admin\",\n        \"lastReplyTime\": \"2017-11-21T07:59:06.772Z\",\n        \"__v\": 0,\n        \"replyList\": [],\n        \"label\": [\n          \"angular\",\n          \"javascript\"\n        ],\n        \"replyNum\": 0,\n        \"viewed\": 1,\n        \"creatDate\": \"2017-11-21T07:59:06.772Z\"\n      },\n      {\n        \"_id\": \"5a13dbfb49a16c75252cc059\",\n        \"title\": \"cd\",\n        \"content\": \"cdcd\",\n        \"author\": \"admin\",\n        \"lastReplyTime\": \"2017-11-21T07:55:39.191Z\",\n        \"__v\": 0,\n        \"replyList\": [],\n        \"label\": [\n          \"111\",\n          \"222\"\n        ],\n        \"replyNum\": 0,\n        \"viewed\": 0,\n        \"creatDate\": \"2017-11-21T07:55:39.191Z\"\n      },\n      {\n        \"_id\": \"5a13daee318f07746f106f06\",\n        \"title\": \"测试测试标签\",\n        \"content\": \"sss\",\n        \"author\": \"admin\",\n        \"lastReplyTime\": \"2017-11-21T07:51:10.817Z\",\n        \"__v\": 0,\n        \"replyList\": [],\n        \"label\": [\n          \"angular\",\n          \"javascript\"\n        ],\n        \"replyNum\": 0,\n        \"viewed\": 0,\n        \"creatDate\": \"2017-11-21T07:51:10.817Z\"\n      },\n      {\n        \"_id\": \"5a13da0771bb24738eaa2364\",\n        \"title\": \"hhh\",\n        \"content\": \"hhhh\",\n        \"author\": \"admin\",\n        \"lastReplyTime\": \"2017-11-21T07:47:19.202Z\",\n        \"__v\": 0,\n        \"replyList\": [],\n        \"label\": [\n          \"angular\",\n          \"javascript\"\n        ],\n        \"replyNum\": 0,\n        \"viewed\": 0,\n        \"creatDate\": \"2017-11-21T07:47:19.202Z\"\n      }\n    ],\n    \"totalElement\": 27\n  }\n}"
*************** response log end ***************

[2017-12-01 12:17:52.895] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/label/getLabelLists
request client ip:  ::1
request body: 
{"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiNTlmYmNmNmJjZTg4MDkwN2MyMGI1OWNkIiwiaWF0IjoxNTEyMTAxNTc2LCJleHAiOjE1MTIxNDQ3NzZ9.uKBuLKHhVqQEXpCm68cxufPp3HqLhF25sI_3iT0rBmI","keyword":""}
response time: 2
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"操作成功\",\n  \"data\": [\n    {\n      \"_id\": \"5a13dcca314c147535a700b5\",\n      \"name\": \"angular\",\n      \"__v\": 0,\n      \"number\": 2\n    },\n    {\n      \"_id\": \"5a13dcca314c147535a700b6\",\n      \"name\": \"javascript\",\n      \"__v\": 0,\n      \"number\": 1\n    },\n    {\n      \"_id\": \"5a1785b3bbb11c04f3f739eb\",\n      \"name\": \"111\",\n      \"__v\": 0,\n      \"number\": 1\n    },\n    {\n      \"_id\": \"5a1785b3bbb11c04f3f739ec\",\n      \"name\": \"222\",\n      \"__v\": 0,\n      \"number\": 1\n    }\n  ]\n}"
*************** response log end ***************

[2017-12-01 12:17:57.443] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/upload/getMdFileContent
request client ip:  ::1
request body: 
{}
response time: 2
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"解析成功\",\n  \"data\": \"# Asynchronous Control Flow Patterns with ES2015 and Beyond\\n在上一章中，我们学习了如何使用回调处理异步代码，以及如何解决如回调地狱代码等异步问题。回调是`JavaScript`和`Node.js`中的异步编程的基础，但是现在，其他替代方案已经出现。这些替代方案更复杂，以便能够以更方便的方式处理异步代码。\\n\\n在本章中，我们将探讨一些代表性的替代方案，`Promise`和`Generator`。以及`async await`，这是一种创新的语法，可在高版本的`JavaScript`中提供，其也作为`ECMAScript 2017`发行版的一部分。\\n\\n我们将看到这些替代方案如何简化处理异步控制流的方式。最后，我们将比较所有这些方法，以了解所有这些方法的所有优点和缺点，并能够明智地选择最适合我们下一个`Node.js`项目要求的方法。\\n\\n## Promise\\n我们在前面的章节中提到，`CPS风格`不是编写异步代码的唯一方法。事实上，`JavaScript`生态系统为传统的回调模式提供了有趣的替代方案。最着名的选择之一是`Promise`，特别是现在它是`ECMAScript 2015`的一部分，并且现在可以在`Node.js`中可用。\\n\\n### 什么是Promise？\\n`Promise`是一种抽象的对象，我们通常允许函数返回一个名为`Promise`的对象，它表示异步操作的最终结果。通常情况下，我们说当异步操作尚未完成时，我们说`Promise`对象处于`pending`状态，当操作成功完成时，我们说`Promise`对象处于`resolve`状态，当操作错误终止时，我们说`Promise`对象处于`reject`状态。一旦`Promise`处于`resolve`或`reject`，我们认为当前异步操作结束。\\n\\n为了接收到异步操作的正确结果或错误捕获，我们可以使用`Promise`的`then`方法：\\n\\n```javascript\\npromise.then([onFulfilled], [onRejected])\\n```\\n\\n在前面的代码中，`onFulfilled()`是一个函数，最终会收到`Promise`的正确结果，而`onRejected()`是另一个函数，它将接收产生异常的原因（如果有的话）。两个参数都是可选的。\\n\\n要了解`Promise`如何转换我们的代码，让我们考虑以下几点：\\n\\n```javascript\\nasyncOperation(arg, (err, result) => {\\n  if (err) {\\n    // 错误处理\\n  }\\n  // 正常结果处理\\n});\\n```\\n\\n`Promise`允许我们将这个典型的`CPS`代码转换成更好的结构化和更优雅的代码，如下所示：\\n\\n```javascript\\nasyncOperation(arg)\\n  .then(result => {\\n    // 错误处理\\n  }, err => {\\n    // 正常结果处理\\n  });\\n```\\n\\n`then()`方法的一个关键特征是它同步地返回另一个`Promise`对象。如果`onFulfilled()`或`onRejected()`函数中的任何一个函数返回`x`，则`then()`方法返回的`Promise`对象将如下所示：\\n\\n* 如果`x`是一个值，则这个`Promise`对象会正确处理(`resolve`)`x`\\n* 如果`x`是一个`Promise`对象或`thenable`，则会正确处理(`resolve`)`x`\\n* 如果`x`是一个异常，则会捕获异常(`reject`)`x`\\n\\n> 注：thenable是一个具有then方法的类似于Promise的对象(Promise-like)。\\n\\n这个特点使我们能够链式构建`Promise`，允许轻松排列组合我们的异步操作。另外，如果我们没有指定一个`onFulfilled()`或`onRejected()`处理程序，则正确结果或异常捕获将自动转发到`Promise`链的下一个`Promise`。例如，这允许我们在整个链中自动传播错误，直到被`onRejected()`处理程序捕获。随着`Promise`链，任务的顺序执行突然变成简单多了：\\n\\n```javascript\\nasyncOperation(arg)\\n  .then(result1 => {\\n    // 返回另一个Promise\\n    return asyncOperation(arg2);\\n  })\\n  .then(result2 => {\\n    // 返回一个值\\n    return 'done';\\n  })\\n  .then(undefined, err => {\\n    // 捕获Promise链中的异常\\n  });\\n```\\n\\n下图展示了链式`Promise`如何工作：\\n\\n![](http://oczira72b.bkt.clouddn.com/17-10-31/46370382.jpg)\\n\\n`Promise`的另一个重要特性是`onFulfilled()`和`onRejected()`函数是异步调用的，如同上述的例子，在最后那个`then`函数`resolve`一个同步的`Promise`，它也是同步的。这种模式避免了`Zalgo`（参见`Chapter2-Node.js Essential Patterns`），使我们的异步代码更加一致和稳健。\\n\\n如果在`onFulfilled()`或`onRejected()`处理程序中抛出异常（使用`throw`语句），则`then()`方法返回的`Promise`将被自动地`reject`，抛出异常作为`reject`的原因。这相对于`CPS`来说是一个巨大的优势，因为它意味着有了`Promise`，异常将在整个链中自动传播，并且`throw`语句终于可以使用。\\n\\n在以前，许多不同的库实现了`Promise`，大多数时候它们之间不兼容，这意味着不可能在使用不同`Promise`库的`thenable`链式传播错误。\\n\\n`JavaScript`社区非常努力地解决了这个限制，这些努力导致了`Promises / A +`规范的创建。该规范详细描述了`then`方法的行为，提供了一个可互兼容的基础，这使得来自不同库的`Promise`对象能够彼此兼容，开箱即用。\\n\\n有关`Promises / A +`规范的详细说明，可以参考[Promises / A + 官方网站](https://promisesaplus.com)。\\n\\n### Promise / A + 的实施\\n在`JavaScript`中以及`Node.js`中，有几个实现`Promises / A +`规范的库。以下是最受欢迎的：\\n\\n* [Bluebird](https://npmjs.org/package/bluebird)\\n* [Q](https://npmjs.org/package/q)\\n* [RSVP](https://npmjs.org/package/rsvp)\\n* [Vow](https://npmjs.org/package/vow)\\n* [When.js](https://npmjs.org/package/when)\\n* ES2015 promises\\n\\n真正区别他们的是在`Promises / A +`标准之上提供的额外功能。正如我们上述所说的那样，该标准定义了`then()`方法和`Promise`解析过程的行为，但它没有指定其他功能，例如，如何从基于回调的异步函数创建`Promise`。\\n\\n在我们的示例中，我们将使用由`ES2015`的`Promise`，因为`Promise`对象自`Node.js 4`后即可使用，而不需要任何库来实现。\\n\\n作为参考，以下是`ES2015`的`Promise`提供的API：\\n\\n`constructor`(`new Promise（function（resolve, reject）{}）`)：创建了一个新的`Promise`，它基于作为传递两个类型为函数的参数来决定`resolve`或`reject`。构造函数的参数解释如下：\\n\\n* `resolve(obj)` ：`resolve`一个`Promise`，并带上一个参数`obj`，如果`obj`是一个值，这个值就是传递的异步操作成功的结果。如果`obj`是一个`Promise`或一个`thenable`，则会进行正确处理。\\n* `reject(err)`：`reject`一个`Promise`，并带上一个参数`err`。它是`Error`对象的一个实例。\\n\\n#### Promise对象的静态方法\\n* `Promise.resolve(obj)`： 将会创建一个`resolve`的`Promise`实例\\n* `Promise.reject(err)`： 将会创建一个`reject`的`Promise`实例\\n* `Promise.all(iterable)`：返回一个新的`Promise`实例，并且在`iterable`中所\\n有`Promise`状态为`reject`时, 返回的`Promise`实例的状态会被置为`reject`，如果`iterable`中至少有一个`Promise`状态为`reject`时, 返回的`Promise`实例状态也会被置为`reject`，并且`reject`的原因是第一个被`reject`的`Promise`对象的`reject`原因。\\n* `Promise.race(iterable)`：返回一个`Promise`实例，当`iterable`中任何一个`Promise`被`resolve`或被`reject`时， 返回的`Promise`实例以同样的原因`resolve`或`reject`。\\n\\n#### Promise实例方法\\n* `Promise.then(onFulfilled, onRejected)`：这是`Promise`的基本方法。它的行为与我们之前描述的`Promises / A +`标准兼容。\\n* `Promise.catch(onRejected)`：这只是`Promise.then(undefined，onRejected)`的语法糖。\\n\\n> 值得一提的是，一些Promise实现提供了另一种机制来创建新的Promise，称为deferreds。我们不会在这里描述，因为它不是ES2015标准的一部分，但是如果您想了解更多信息，可以阅读Q文档 (https://github.com/kriskowal/q#using-deferreds) 或When.js文档 (https://github.com/cujojs/when/wiki/Deferred) 。\\n\\n### Promisifying一个Node.js回调风格的函数\\n在`JavaScript`中，并不是所有的异步函数和库都支持开箱即用的`Promise`。大多数情况下，我们必须将一个典型的基于回调的函数转换成一个返回`Promise`的函数，这个过程也被称为`promisification`。\\n\\n幸运的是，`Node.js`中使用的回调约定允许我们创建一个可重用的函数，我们通过使用`Promise`对象的构造函数来简化任何`Node.js`风格的`API`。让我们创建一个名为`promisify()`的新函数，并将其包含到`utilities.js`模块中（以便稍后在我们的`Web爬虫应用程序`中使用它）：\\n\\n```javascript\\nmodule.exports.promisify = function(callbackBasedApi) {\\n  return function promisified() {\\n    const args = [].slice.call(arguments);\\n    return new Promise((resolve, reject) => {\\n      args.push((err, result) => {\\n        if (err) {\\n          return reject(err);\\n        }\\n        if (arguments.length <= 2) {\\n          resolve(result);\\n        } else {\\n          resolve([].slice.call(arguments, 1));\\n        }\\n      });\\n      callbackBasedApi.apply(null, args);\\n    });\\n  }\\n};\\n```\\n\\n前面的函数返回另一个名为`promisified()`的函数，它表示输入中给出的`callbackBasedApi`的`promisified`版本。以下展示它是如何工作的：\\n\\n1. `promisified()`函数使用`Promise`构造函数创建一个新的`Promise`对象，并立即将其返回给调用者。\\n2. 在传递给`Promise`构造函数的函数中，我们确保传递给`callbackBasedApi`，这是一个特殊的回调函数。由于我们知道回调总是最后调用的，我们只需将回调函数附加到提供给`promisified()`函数的参数列表里（`args`）。\\n3. 在特殊的回调中，如果我们收到错误，我们立即`reject`这个`Promise`。\\n4. 如果没有收到错误，我们使用一个值或一个数组值来`resolve`这个`Promise`，具体取决于传递给回调的结果数量。\\n5. 最后，我们只需使用我们构建的参数列表调用`callbackBasedApi`。\\n\\n> 大部分的Promise已经提供了一个开箱即用的接口来将一个Node.js风格的API转换成一个返回Promise的API。例如，Q有Q.denodeify()和Q.nbind()，Bluebird有Promise.promisify()，而When.js有node.lift()。\\n\\n### 顺序执行\\n在一些必要的理论之后，我们现在准备将我们的`Web爬虫应用程序`转换为使用`Promise`的形式。让我们直接从版本2开始，直接下载一个Web网页的链接。\\n\\n在`spider.js`模块中，第一步是加载我们的`Promise`实现（我们稍后会使用它）和`Promisifying`我们打算使用的基于回调的函数：\\n\\n```javascript\\nconst utilities = require('./utilities');\\nconst request = utilities.promisify(require('request'));\\nconst mkdirp = utilities.promisify(require('mkdirp'));\\nconst fs = require('fs');\\nconst readFile = utilities.promisify(fs.readFile);\\nconst writeFile = utilities.promisify(fs.writeFile);\\n```\\n\\n现在，我们开始更改我们的`download`函数：\\n\\n```javascript\\nfunction download(url, filename) {\\n  console.log(`Downloading ${url}`);\\n  let body;\\n  return request(url)\\n    .then(response => {\\n      body = response.body;\\n      return mkdirp(path.dirname(filename));\\n    })\\n    .then(() => writeFile(filename, body))\\n    .then(() => {\\n      console.log(`Downloaded and saved: ${url}`);\\n      return body;\\n    });\\n}\\n```\\n\\n这里要注意的到的最重要的是我们也为`readFile()`返回的`Promise`注册\\n一个`onRejected()`函数，用来处理一个网页没有被下载的情况(或文件不存在)。 还有，看我们如何使用`throw`来传递`onRejected()`函数中的错误的。\\n\\n既然我们已经更改我们的`spider()`函数，我们这么修改它的调用方式：\\n\\n```javascript\\nspider(process.argv[2], 1)\\n  .then(() => console.log('Download complete'))\\n  .catch(err => console.log(err));\\n```\\n\\n注意我们是如何第一次使用`Promise`的语法糖`catch`来处理源自`spider()`函数的任何错误情况。如果我们再看看迄今为止我们所写的所有代码，那么我们会惊喜的发现，我们没有包含任何错误传播逻辑，因为我们在使用回调函数时会被迫做这样的事情。这显然是一个巨大的优势，因为它极大地减少了我们代码中的样板文件以及丢失任何异步错误的机会。\\n\\n现在，完成我们唯一缺失的`Web爬虫应用程序`的第二版的`spiderLinks()`函数，我们将在稍后实现它。\\n\\n### 顺序迭代\\n到目前为止，`Web爬虫应用程序`代码库主要是对`Promise`是什么以及如何使用的概述，展示了使用`Promise`实现顺序执行流程的简单性和优雅性。但是，我们现在考虑的代码只涉及到一组已知的异步操作的执行。所以，完成我们对顺序执行流程的探索的缺失部分是看我们如何使用`Promise`来实现迭代。同样，网络蜘蛛第二版的`spiderLinks()`函数也是一个很好的例子。\\n\\n让我们添加缺少的这一块：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  let promise = Promise.resolve();\\n  if (nesting === 0) {\\n    return promise;\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  links.forEach(link => {\\n    promise = promise.then(() => spider(link, nesting - 1));\\n  });\\n  return promise;\\n}\\n```\\n\\n为了异步迭代一个网页的全部链接，我们必须动态创建一个`Promise`的迭代链。\\n\\n1. 首先，我们定义一个空的`Promise`，`resolve`为`undefined`。这个`Promise`只是用来作为`Promise`的迭代链的起始点。 \\n2. 然后，我们通过在循环中调用链中前一个`Promise`的`then()`方法获得的新的`Promise`来更新`Promise`变量。这就是我们使用`Promise`的异步迭代模式。\\n\\n这样，循环的结束，`promise`变量会包含循环中最后一个`then()`返回的`Promise`对象，所以它只有当`Promise`的迭代链中全部`Promise`对象被`resolve`后才能被`resolve`。\\n\\n> 注：在最后调用了这个then方法来resolve这个Promise对象\\n\\n通过这个，我们已使用`Promise`对象重写了我们的`Web爬虫应用程序`。我们现在应该可以运行它了。\\n\\n### 顺序迭代模式\\n为了总结这个顺序执行的部分，让我们提取一个模式来依次遍历一组`Promise`：\\n\\n```javascript\\nlet tasks = [ /* ... */ ]\\nlet promise = Promise.resolve();\\ntasks.forEach(task => {\\n  promise = promise.then(() => {\\n    return task();\\n  });\\n});\\npromise.then(() => {\\n  // 所有任务都完成\\n});\\n```\\n\\n使用`reduce()`方法来替代`forEach()`方法，允许我们写出更为简洁的代码：\\n\\n```javascript\\nlet tasks = [ /* ... */ ]\\nlet promise = tasks.reduce((prev, task) => {\\n  return prev.then(() => {\\n    return task();\\n  });\\n}, Promise.resolve());\\n\\npromise.then(() => {\\n  //All tasks completed\\n});\\n```\\n\\n与往常一样，通过对这种模式的简单调整，我们可以将所有任务的结果收集到一个数组中，我们可以实现一个`mapping`算法，或者构建一个`filter`等等。\\n\\n> 上述这个模式使用循环动态地建立一个链式的Promise。\\n\\n### 并行执行\\n另一个适合用`Promise`的执行流程是并行执行流程。实际上，我们需要做的就是使用内置的`Promise.all()`。这个方法创造了另一个`Promise`对象，只有在输入中的所有`Promise`都`resolve`时才能`resolve`。这是一个并行执行，因为在其参数`Promise`对象的之间没有执行顺序可言。\\n\\n为了演示这一点，我们来看我们的`Web爬虫应用程序`的第三版，它将页面中的所有链接并行下载。让我们再次使用`Promise`更新`spiderLinks()`函数来实现并行流程：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return Promise.resolve();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  const promises = links.map(link => spider(link, nesting - 1));\\n  return Promise.all(promises);\\n}\\n```\\n\\n这里的模式在`elements.map()`迭代中产生一个数组，存放所有异步任务，之后便于同时启动`spider()`任务。这一次，在循环中，我们不等待以前的下载完成，然后开始一个新的下载任务：所有的下载任务在一个循环中一个接一个地开始。之后，我们利用`Promise.all()`方法，它返回一个新的`Promise`对象，当数组中的所有`Promise`对象都被`resolve`时，这个`Promise`对象将被`resolve`。换句话说，所有的下载任务完成，这正是我们想要的。\\n\\n### 限制并行执行\\n不幸的是，`ES2015`的`Promise API`并没有提供一种原生的方式来限制并发任务的数量，但是我们总是可以依靠我们所学到的有关用普通`JavaScript`来限制并发。事实上，我们在`TaskQueue`类中实现的模式可以很容易地被调整来支持返回承诺的任务。这很容易通过修改`next()`方法来完成：\\n\\n```javascript\\nclass TaskQueue {\\n  constructor(concurrency) {\\n    this.concurrency = concurrency;\\n    this.running = 0;\\n    this.queue = [];\\n  }\\n\\n  pushTask(task) {\\n    this.queue.push(task);\\n    this.next();\\n  }\\n\\n  next() {\\n    while (this.running < this.concurrency && this.queue.length) {\\n      const task = this.queue.shift();\\n      task().then(() => {\\n        this.running--;\\n        this.next();\\n      });\\n      this.running++;\\n    }\\n  }\\n}\\n```\\n\\n不同于使用一个回调函数来处理任务，我们简单地调用`Promise`的`then()`。\\n\\n让我们回到`spider.js`模块，并修改它以支持我们的新版本的`TaskQueue`类。首先，我们确保定义一个`TaskQueue`的新实例：\\n\\n```javascript\\nconst TaskQueue = require('./taskQueue');\\nconst downloadQueue = new TaskQueue(2);\\n```\\n\\n然后，是我们的`spiderLinks()`函数。这里的修改也是很简单：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return Promise.resolve();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  // 我们需要如下代码，用于创建Promise对象\\n  // 如果没有下列代码，当任务数量为0时，将永远不会resolve\\n  if (links.length === 0) {\\n    return Promise.resolve();\\n  }\\n  return new Promise((resolve, reject) => {\\n    let completed = 0;\\n    let errored = false;\\n    links.forEach(link => {\\n      let task = () => {\\n        return spider(link, nesting - 1)\\n          .then(() => {\\n            if (++completed === links.length) {\\n              resolve();\\n            }\\n          })\\n          .catch(() => {\\n            if (!errored) {\\n              errored = true;\\n              reject();\\n            }\\n          });\\n      };\\n      downloadQueue.pushTask(task);\\n    });\\n  });\\n}\\n```\\n\\n在上述代码中有几点值得我们注意的：\\n\\n* 首先，我们需要返回使用`Promise`构造函数创建的新的`Promise`对象。正如我们将看到的，这使我们能够在队列中的所有任务完成时手动`resolve`我们的`Promise`对象。\\n* 然后，我们应该看看我们如何定义任务。我们所做的是将一个`onFulfilled()`回调函数的调用添加到由`spider()`返回的`Promise`对象中，所以我们可以计算完成的下载任务的数量。当完成的下载量与当前页面中链接的数量相同时，我们知道任务已经处理完毕，所以我们可以调用外部`Promise`的`resolve()`函数。\\n\\n> Promises / A +规范规定，then()方法的onFulfilled()和onRejected()回调函数只能调用一次（仅调用onFulfilled()和onRejected()）。Promise接口的实现确保即使我们多次手动调用resolve或reject，Promise也仅可以被resolve或reject一次。\\n\\n现在，使用`Promise`的`Web爬虫应用程序`的第4版应该已经准备好了。我们可能再次注意到下载任务如何并行运行，并发数量限制为2。\\n\\n### 在公有API中暴露回调函数和Promise\\n正如我们在前面所学到的，`Promise`可以被用作回调函数的一个很好的替代品。它们使我们的代码更具可读性和易于理解。虽然`Promise`带来了许多优点，但也要求开发人员理解许多不易于理解的概念，以便正确和熟练地使用。由于这个原因和其他原因，在某些情况下，比起`Promise`来说，很多开发者更偏向于回调函数。\\n\\n现在让我们想象一下，我们想要构建一个执行异步操作的公共库。我们需要做什么？我们是创建了一个基于回调函数的`API`还是一个面向`Promise`的`API`？还是两者均有？\\n\\n这是许多知名的库所面临的问题，至少有两种方法值得一提，使我们能够提供一个多功能的`API`。\\n\\n像`request`，`redis`和`mysql`这样的库所使用的第一种方法是提供一个简单的基于回调函数的`API`，如果需要，开发人员可以选择公开函数。其中一些库提供工具函数来`Promise`化异步回调，但开发人员仍然需要以某种方式将暴露的`API`转换为能够使用`Promise`对象。\\n\\n第二种方法更透明。它还提供了一个面向回调的`API`，但它使回调参数可选。每当回调作为参数传递时，函数将正常运行，在完成时或失败时执行回调。当回调未被传递时，函数将立即返回一个`Promise`对象。这种方法有效地结合了回调函数和`Promise`，使得开发者可以在调用时选择采用什么接口，而不需要提前进行`Promise`化。许多库，如`mongoose`和`sequelize`，都支持这种方法。\\n\\n我们来看一个简单的例子。假设我们要实现一个异步执行除法的模块：\\n\\n```javascript\\nmodule.exports = function asyncDivision(dividend, divisor, cb) {\\n  return new Promise((resolve, reject) => { // [1]\\n    process.nextTick(() => {\\n      const result = dividend / divisor;\\n      if (isNaN(result) || !Number.isFinite(result)) {\\n        const error = new Error('Invalid operands');\\n        if (cb) {\\n          cb(error); // [2]\\n        }\\n        return reject(error);\\n      }\\n      if (cb) {\\n        cb(null, result); // [3]\\n      }\\n      resolve(result);\\n    });\\n  });\\n};\\n```\\n\\n该模块的代码非常简单，但是有一些值得强调的细节：\\n\\n* 首先，返回使用`Promise`的构造函数创建的新承诺。我们在构造函数参数函数内定义全部逻辑。\\n* 在发生错误的情况下，我们`reject`这个`Promise`，但如果回调函数在被调用时作为参数传递，我们也执行回调来进行错误传播。\\n* 在计算结果之后，我们`resolve`了这个`Promise`，但是如果有回调函数，我们也会将结果传播给回调函数。\\n\\n我们现在看如何用回调函数和`Promise`来使用这个模块：\\n\\n```javascript\\n// 回调函数的方式\\nasyncDivision(10, 2, (error, result) => {\\n  if (error) {\\n    return console.error(error);\\n  }\\n  console.log(result);\\n});\\n\\n// Promise化的调用方式\\nasyncDivision(22, 11)\\n  .then(result => console.log(result))\\n  .catch(error => console.error(error));\\n```\\n\\n应该很清楚的是，即将开始使用类似于上述的新模块的开发人员将很容易地选择最适合自己需求的风格，而无需在希望利用`Promise`时引入外部`promisification`功能。\\n\\n## Generators\\n`ES2015`规范引入了另外一种机制，除了其他新功能外，还可以用来简化`Node.js`应用程序的异步控制流程。我们正在谈论`Generator`，也被称为`semi-coroutines`。它们是子程序的一般化，可以有不同的入口点。在一个正常的函数中，实际上我们只能有一个入口点，这个入口点对应着函数本身的调用。`Generator`与一般函数类似，但是可以暂停（使用`yield`语句），然后在稍后继续执行。在实现迭代器时，`Generator`特别有用，因为我们已经讨论了如何使用迭代器来实现重要的异步控制流模式，如顺序执行和限制并行执行。\\n\\n### Generators基础\\n在我们探索使用`Generator`来实现异步控制流程之前，学习一些基本概念是很重要的。我们从语法开始吧。可以通过在函数关键字之后附加`*`（星号）运算符来声明`Generator`函数：\\n\\n```javascript\\nfunction* makeGenerator() {\\n  // body\\n}\\n```\\n\\n在`makeGenerator()`函数内部，我们可以使用关键字`yield`暂停执行并返回给调用者传递给它的值：\\n\\n```javascript\\nfunction* makeGenerator() {\\n  yield 'Hello World';\\n  console.log('Re-entered');\\n}\\n```\\n\\n在前面的代码中，`Generator`通过`yield`一个字符串`Hello World`暂停当前函数的执行。当`Generator`恢复时，执行将从下列语句开始：\\n\\n```javascript\\nconsole.log('Re-entered');\\n```\\n\\n`makeGenerator()`函数本质上是一个工厂，它在被调用时返回一个新的`Generator`对象：\\n\\n```javascript\\nconst gen = makeGenerator();\\n```\\n\\n生成器对象的最重要的方法是`next()`，它用于启动/恢复`Generator`的执行，并返回如下形式的对象：\\n\\n```\\n{\\n  value: <yielded value>\\n  done: <true if the execution reached the end>\\n}\\n```\\n\\n这个对象包含`Generator` `yield`的值和一个指示`Generator`是否已经完成执行的符号。\\n\\n### 一个简单的例子\\n为了演示`Generator`，我们来创建一个名为`fruitGenerator.js`的新模块：\\n\\n```javascript\\nfunction* fruitGenerator() {\\n  yield 'apple';\\n  yield 'orange';\\n  return 'watermelon';\\n}\\nconst newFruitGenerator = fruitGenerator();\\nconsole.log(newFruitGenerator.next()); // [1]\\nconsole.log(newFruitGenerator.next()); // [2]\\nconsole.log(newFruitGenerator.next()); // [3]\\n```\\n\\n前面的代码将打印下面的输出：\\n\\n```\\n{ value: 'apple', done: false }\\n{ value: 'orange', done: false }\\n{ value: 'watermelon', done: true }\\n```\\n\\n我们可以这么解释上述现象：\\n\\n* 第一次调用`newFruitGenerator.next()`时，`Generator`函数开始执行，直到达到第一个`yield`语句为止，该命令暂停`Generator`函数执行，并将值`apple`返回给调用者。\\n* 在第二次调用`newFruitGenerator.next()`时，`Generator`函数恢复执行，从第二个`yield`语句开始，这又使得执行暂停，同时将`orange`返回给调用者。\\n* `newFruitGenerator.next()`的最后一次调用导致`Generator`函数的执行从其最后的`yield`恢复，一个返回语句，它终止`Generator`函数，返回`watermelon`，并将结果对象中的`done`属性设置为`true`。\\n\\n### Generators作为迭代器\\n为了更好地理解为什么`Generator`函数对实现迭代器非常有用，我们来构建一个例子。在我们将调用`iteratorGenerator.js`的新模块中，我们编写下面的代码：\\n\\n```javascript\\nfunction* iteratorGenerator(arr) {\\n  for (let i = 0; i < arr.length; i++) {\\n    yield arr[i];\\n  }\\n}\\nconst iterator = iteratorGenerator(['apple', 'orange', 'watermelon']);\\nlet currentItem = iterator.next();\\nwhile (!currentItem.done) {\\n  console.log(currentItem.value);\\n  currentItem = iterator.next();\\n}\\n```\\n\\n此代码应按如下所示打印数组中的元素：\\n\\n```\\napple\\norange\\nwatermelon\\n```\\n\\n在这个例子中，每次我们调用`iterator.next()`时，我们都会恢复`Generator`函数的`for`循环，通过`yield`数组中的下一个项来运行另一个循环。这演示了如何在函数调用过程中维护`Generator`的状态。当继续执行时，循环和所有变量的值与`Generator`函数执行暂停时的状态完全相同。\\n\\n### 传值给Generators\\n现在我们继续研究`Generator`的基本功能，首先学习如何将值传递回`Generator`函数。这其实很简单，我们需要做的只是为`next()`方法提供一个参数，并且该值将作为`Generator`函数内的`yield`语句的返回值提供。\\n\\n为了展示这一点，我们来创建一个新的简单模块：\\n\\n```javascript\\nfunction* twoWayGenerator() {\\n  const what = yield null;\\n  console.log('Hello ' + what);\\n}\\nconst twoWay = twoWayGenerator();\\ntwoWay.next();\\ntwoWay.next('world');\\n```\\n\\n当执行时，前面的代码会输出`Hello world`。我们做如下的解释：\\n\\n* 第一次调用`next()`方法时，`Generator`函数到达第一个`yield`语句，然后暂停。\\n* 当`next('world')`被调用时，`Generator`函数从上次停止的位置，也就是上次的`yield`语句点恢复，但是这次我们有一个值传递到`Generator`函数。这个值将被赋值到`what`变量。生成器然后执行`console.log()`指令并终止。\\n\\n用类似的方式，我们可以强制`Generator`函数抛出异常。这可以通过使用`Generator`函数的`throw`方法来实现，如下例所示：\\n\\n```javascript\\nconst twoWay = twoWayGenerator();\\ntwoWay.next();\\ntwoWay.throw(new Error());\\n```\\n\\n在这个最后这段代码，`twoWayGenerator()`函数将在`yield`函数返回的时候抛出异常。这就好像从`Generator`函数内部抛出了一个异常一样，这意味着它可以像使用`try ... catch`块一样进行捕获和处理异常。\\n\\n### Generator实现异步控制流\\n你一定想知道`Generator`函数如何帮助我们处理异步操作。我们可以通过创建一个接受`Generator`函数作为参数的特殊函数来演示这一点，并允许我们在`Generator`函数内部使用异步代码。这个函数在异步操作完成时要注意恢复`Generator`函数的执行。我们将调用这个函数`asyncFlow()`：\\n\\n```javascript\\nfunction asyncFlow(generatorFunction) {\\n  function callback(err) {\\n    if (err) {\\n      return generator.throw(err);\\n    }\\n    const results = [].slice.call(arguments, 1);\\n    generator.next(results.length > 1 ? results : results[0]);\\n  }\\n  const generator = generatorFunction(callback);\\n  generator.next();\\n}\\n```\\n\\n前面的函数取一个`Generator`函数作为输入，然后立即调用：\\n\\n```javascript\\nconst generator = generatorFunction(callback);\\ngenerator.next();\\n```\\n\\n`generatorFunction()`接受一个特殊的回调函数作为参数，当`generator.throw()`如果接收到一个错误，便立即返回。另外，通过将在回调函数中接收的`results`传值回`Generator`函数继续`Generator`函数的执行:\\n\\n```javascript\\nif (err) {\\n  return generator.throw(err);\\n}\\nconst results = [].slice.call(arguments, 1);\\ngenerator.next(results.length > 1 ? results : results[0]);\\n```\\n\\n为了说明这个简单的辅助函数的强大，我们创建一个叫做`clone.js`的新模块，这个模块只是创建它本身的克隆。粘贴我们刚才创建的`asyncFlow()`函数，核心代码如下：\\n\\n```javascript\\nconst fs = require('fs');\\nconst path = require('path');\\nasyncFlow(function*(callback) {\\n  const fileName = path.basename(__filename);\\n  const myself = yield fs.readFile(fileName, 'utf8', callback);\\n  yield fs.writeFile(`clone_of_${filename}`, myself, callback);\\n  console.log('Clone created');\\n});\\n```\\n\\n明显地，有了`asyncFlow()`函数的帮助，我们可以像我们书写同步阻塞函数一样用同步的方式来书写异步代码了。并且这个结果背后的原理显得很清楚。一旦异步操作结束，传递给每个异步函数的回调函数将继续`Generator`函数的执行。没有什么复杂的，但是结果确实很令人意外。\\n\\n这个技术有其他两个变化，一个是`Promise`的使用，另外一个则是`thunks`。\\n\\n> 在基于Generator的控制流中使用的thunk只是一个简单的函数，它除了回调之外，部分地应用了原始函数的所有参数。返回值是另一个只接受回调作为参数的函数。例如，fs.readFile（）的thunkified版本如下所示：\\n\\n```javascript\\nfunction readFileThunk(filename, options) {\\n  return function(callback) {\\n    fs.readFile(filename, options, callback);\\n  }\\n}\\n```\\n\\n`thunk`和`Promise`都允许我们创建不需要回调的`Generator`函数作为参数传递，例如，使用`thunk`的`asyncFlow()`版本如下：\\n\\n```javascript\\nfunction asyncFlowWithThunks(generatorFunction) {\\n  function callback(err) {\\n    if (err) {\\n      return generator.throw(err);\\n    }\\n    const results = [].slice.call(arguments, 1);\\n    const thunk = generator.next(results.length > 1 ? results : results[0]).value;\\n    thunk && thunk(callback);\\n  }\\n  const generator = generatorFunction();\\n  const thunk = generator.next().value;\\n  thunk && thunk(callback);\\n}\\n```\\n\\n这个技巧是读取`generator.next()`的返回值，返回值中包含`thunk`。下一步是通过注入特殊的回调函数调用`thunk`本身。这允许我们写下面的代码：\\n\\n```javascript\\nasyncFlowWithThunk(function*() {\\n  const fileName = path.basename(__filename);\\n  const myself = yield readFileThunk(__filename, 'utf8');\\n  yield writeFileThunk(`clone_of_${fileName}`, myself);\\n  console.log(\\\"Clone created\\\")\\n});\\n```\\n\\n### 使用co的基于Gernator的控制流\\n你应该已经猜到了，`Node.js`生态系统会借助`Generator`函数来提供一些处理异步控制流的解决方案，例如，[suspend](https://npm/js.org/package/suspend)是其中一个最老的支持`Promise`、`thunks`和`Node.js`风格回调函数和正常风格的回调函数的 库。还有，大部分我们之前分析的`Promise`库都提供工具函数使得`Generator`和`Promise`可以一起使用。\\n\\n我们选择[co](https://npmjs.org/package/co)作为本章节的例子。它支持很多类型的`yieldables`，其中一些是：\\n\\n* `Thunks`\\n* `Promises`\\n* `Arrays`(并行执行)\\n* `Objects`(并行执行)\\n* `Generators`(委托)\\n* `Generator`函数(委托)\\n\\n还有很多框架或库是基于`co`生态系统的，包括以下一些：\\n\\n* `Web框架`，最流行的是[koa](https://npmjs.org/package/koa)\\n* 实现特定控制流模式的库\\n* 包装流行的`API`兼容`co`的库\\n\\n我们使用`co`重新实现我们的`Generator`版本的`Web爬虫应用程序`。\\n\\n为了将`Node.js`风格的函数转换成`thunks`，我们将会使用一个叫做[thunkify](https://npmjs.org/package/thunkify)的库。\\n\\n### 顺序执行\\n让我们通过修改`Web爬虫应用程序`的版本2开始我们对`Generator`函数和`co`的实际探索。我们要做的第一件事就是加载我们的依赖包，并生成我们要使用的函数的`thunkified`版本。这些将在`spider.js`模块的最开始进行：\\n\\n```javascript\\nconst thunkify = require('thunkify');\\nconst co = require('co');\\nconst request = thunkify(require('request'));\\nconst fs = require('fs');\\nconst mkdirp = thunkify(require('mkdirp'));\\nconst readFile = thunkify(fs.readFile);\\nconst writeFile = thunkify(fs.writeFile);\\nconst nextTick = thunkify(process.nextTick);\\n```\\n\\n看上述代码，我们可以注意到与本章前面`promisify`化的`API`的代码的一些相似之处。在这一点上，有意思的是，如果我们使用我们的`promisified`版本的函数来代替`thunkified`的版本，代码将保持完全一样，这要归功于`co`支持`thunk`和`Promise`对象作为`yieldable`对象。事实上，如果我们想，甚至可以在同一个应用程序中使用`thunk`和`Promise`，即使在同一个`Generator`函数中。就灵活性而言，这是一个巨大的优势，因为它使我们能够使用基于`Generator`函数的控制流来解决我们应用程序中的问题。\\n\\n好的，现在让我们开始将`download()`函数转换为一个`Generator`函数：\\n\\n```javascript\\nfunction* download(url, filename) {\\n  console.log(`Downloading ${url}`);\\n  const response = yield request(url);\\n  const body = response[1];\\n  yield mkdirp(path.dirname(filename));\\n  yield writeFile(filename, body);\\n  console.log(`Downloaded and saved ${url}`);\\n  return body;\\n}\\n```\\n\\n通过使用`Generator`和`co`，我们的`download()`函数变得简单多了。当我们需要做异步操作的时候，我们使用异步的`Generator`函数作为`thunk`来把之前的内容转化到`Generator`函数，并使用`yield`子句。\\n\\n然后我们开始实现我们的`spider()`函数：\\n\\n```javascript\\nfunction* spider(url, nesting) {\\n  cost filename = utilities.urlToFilename(url);\\n  let body;\\n  try {\\n    body = yield readFile(filename, 'utf8');\\n  } catch (err) {\\n    if (err.code !== 'ENOENT') {\\n      throw err;\\n    }\\n    body = yield download(url, filename);\\n  }\\n  yield spiderLinks(url, body, nesting);\\n}\\n```\\n\\n从上述代码中一个有趣的细节是我们可以使用`try...catch`语句块来处理异常。我们还可以使用`throw`来传播异常。另外一个细节是我们`yield`我们的`download()`函数，而这个函数既不是一个`thunk`，也不是一个`promisified`函数，只是另外的一个`Generator`函数。这也毫无问题，由于`co`也支持其他`Generators`作为`yieldables`。\\n\\n最后转换`spiderLinks()`，在这个函数中，我们递归下载一个网页的链接。在这个函数中使用`Generators`，显得简单多了：\\n\\n```javascript\\nfunction* spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return nextTick();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  for (let i = 0; i < links.length; i++) {\\n    yield spider(links[i], nesting - 1);\\n  }\\n}\\n```\\n\\n看上述代码。虽然顺序迭代没有什么模式可以展示。`Generator`和`co`辅助我们做了很多，方便了我们可以使用同步方式开书写异步代码。\\n\\n看最重要的部分，程序的入口：\\n\\n```javascript\\nco(function*() {\\n  try {\\n    yield spider(process.argv[2], 1);\\n    console.log(`Download complete`);\\n  } catch (err) {\\n    console.log(err);\\n  }\\n});\\n```\\n\\n这是唯一一处需要调用`co(...)`来封装的一个`Generator`。实际上，一旦我们这么做，`co`会自动封装我们传递给`yield`语句的任何`Generator`函数，并且这个过程是递归的，所以程序的剩余部分与我们是否使用`co`是完全无关的，虽然是被`co`封装在里面。\\n\\n现在应该可以运行使用`Generator`函数改写的`Web爬虫应用程序`了。\\n\\n### 并行执行\\n不幸的是，虽然`Generator`很方便地进行顺序执行，但是不能直接用来并行化执行一组任务，至少不能仅仅使用`yield`和`Generator`。之前，在种情况下我们使用的模式只是简单地依赖于一个基于回调或者`Promise`的函数，但使用了`Generator`函数后，一切会显得更简单。\\n\\n幸运的是，如果不限制并发数的并行执行，`co`已经可以通过`yield`一个`Promise`对象、`thunk`、`Generator`函数，甚至包含`Generator`函数的数组来实现。\\n\\n考虑到这一点，我们的`Web爬虫应用程序`第三版可以通过重写`spiderLinks()`函数来做如下改动：\\n\\n```javascript\\nfunction* spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return nextTick();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  const tasks = links.map(link => spider(link, nesting - 1));\\n  yield tasks;\\n}\\n```\\n\\n但是上述函数所做的只是拿到所有的任务，这些任务本质上都是通过`Generator`函数来实现异步的，如果在`co`的`thunk`内对一个包含`Generator`函数的数组使用`yield`，这些任务都会并行执行。外层的`Generator`函数会等到`yield`子句的所有异步任务并行执行后再继续执行。\\n\\n接下来我们看怎么用一个基于回调函数的方式来解决相同的并行流。我们用这种方式重写`spiderLinks()`函数：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return nextTick();\\n  }\\n  // 返回一个thunk\\n  return callback => {\\n    let completed = 0,\\n      hasErrors = false;\\n    const links = utilities.getPageLinks(currentUrl, body);\\n    if (links.length === 0) {\\n      return process.nextTick(callback);\\n    }\\n\\n    function done(err, result) {\\n      if (err && !hasErrors) {\\n        hasErrors = true;\\n        return callback(err);\\n      }\\n      if (++completed === links.length && !hasErrors) {\\n        callback();\\n      }\\n    }\\n    for (let i = 0; i < links.length; i++) {\\n      co(spider(links[i], nesting - 1)).then(done);\\n    }\\n  }\\n}\\n```\\n\\n我们使用`co`并行运行`spider()`函数，调用`Generator`函数返回了一个`Promise`对象。这样，等待`Promise`完成后调用`done()`函数。通常，基于`Generator`控制流的库都有这一功能，因此如果需要，你总是可以将一个`Generator`转换成一个基于回调或基于`Promise`的函数。\\n\\n为了并行开启多个下载任务，我们只要重用在前面定义的基于回调的并行执行的模式。我们应该也注意到我们将`spiderLinks()`转换成一个`thunk`(而不再是一个`Generator`函数)。这使得当全部并行任务完成时，我们有一个回调函数可以调用。\\n\\n> 上面讲到的是将一个Generator函数转换为一个thunk的模式，使之能够支持其他的基于回调或基于Promise的控制流算法，并可以通过同步阻塞的代码风格书写异步代码。\\n\\n### 限制并行执行\\n现在我们知道如何处理异步执行流程，应该很容易规划我们的`Web爬虫应用程序`的第四版的实现，这个版本对并发下载任务的数量施加了限制。我们有几个方案可以用来做到这一点。其中一些方案如下：\\n\\n* 使用先前实现的基于回调的`TaskQueue`类。我们只需要`thunkify`我们的`Generator`函数和其提供的回调函数即可。\\n* 使用基于`Promise`的`TaskQueue`类，并确保每个作为任务的`Generator`函数都被转换成一个返回`Promise`对象的函数。\\n* 使用`async`，`thunkify`我们打算使用的工具函数，此外还需要把我们用到的`Generator`函数转化为基于回调的模式，以便于能够被这个库较好地使用。\\n* 使用基于`co`的生态系统中的库，特别是专门为这种场景的库，如[co-limiter](https://npmjs.org/package/co-limiter)。\\n* 实现基于生产者 - 消费者模型的自定义算法，这与`co-limiter`的内部实现原理相同。\\n\\n为了学习，我们选择最后一个方案，甚至帮助我们可以更好地理解一种经常与协程(也和线程和进程)同步相关的模式。\\n\\n### 生产者 - 消费者模式\\n我们的目标是利用队列来提供固定数量的`workers`，与我们想要设置的并发级别一样多。为了实现这个算法，我们将基于本章前面定义的`TaskQueue`类改写：\\n\\n```javascript\\nclass TaskQueue {\\n  constructor(concurrency) {\\n    this.concurrency = concurrency;\\n    this.running = 0;\\n    this.taskQueue = [];\\n    this.consumerQueue = [];\\n    this.spawnWorkers(concurrency);\\n  }\\n  pushTask(task) {\\n    if (this.consumerQueue.length !== 0) {\\n      this.consumerQueue.shift()(null, task);\\n    } else {\\n      this.taskQueue.push(task);\\n    }\\n  }\\n  spawnWorkers(concurrency) {\\n    const self = this;\\n    for (let i = 0; i < concurrency; i++) {\\n      co(function*() {\\n        while (true) {\\n          const task = yield self.nextTask();\\n          yield task;\\n        }\\n      });\\n    }\\n  }\\n  nextTask() {\\n    return callback => {\\n      if (this.taskQueue.length !== 0) {\\n        return callback(null, this.taskQueue.shift());\\n      }\\n      this.consumerQueue.push(callback);\\n    }\\n  }\\n}\\n```\\n\\n让我们分析这个`TaskQueue`类的新实现。首先是在构造函数中。需要调用一次`this.spawnWorkers()`，因为这是启动`worker`的方法。\\n\\n我们的`worker`很简单，它们只是用`co()`包装的立即执行的`Generator`函数，所以每个`Generator`函数可以并行执行。在内部，每个`worker`正在运行在一个死循环（`while(true){}`）中，一直阻塞（`yield`）到新任务在队列中可用时（`yield self.nextTask()`），一旦可以执行新任务，`yield`这个异步任务直到其完成。您可能想知道我们如何能够限制并行执行，并让下一个任务在队列中处于等待状态。答案是在`nextTask()`方法中。我们来详细地看看在这个方法的原理：\\n\\n```javascript\\nnextTask() {\\n  return callback => {\\n    if (this.taskQueue.length !== 0) {\\n      return callback(null, this.taskQueue.shift());\\n    }\\n    this.consumerQueue.push(callback);\\n  }\\n}\\n```\\n\\n我们看这个函数内部发生了什么，这才是这个模式的核心：\\n\\n1. 这个方法返回一个对于`co`而言是一个合法的`yieldable`的`thunk`。\\n2. 只要`taskQueue`类生成的实例中还有下一个任务，`thunk`的回调函数会被立即调用。回调函数调用时，立马解锁一个`worker`的阻塞状态，`yield`这一个任务。\\n3. 如果队列中没有任务了，回调函数本身会被放入`consumerQueue`中。通过这种做法，我们将一个`worker`置于空闲（`idle`）的模式。一旦我们有一个新的任务来要处理，在`consumerQueue`队列中的回调函数会被调用，立马唤醒我们这一`worker`进行异步处理。\\n\\n现在，为了理解`consumerQueue`队列中的空闲`worker`是如何恢复工作的，我们需要分析`pushTask()`方法。如果当前有回调函数可用的话，`pushTask()`方法将调用`consumerQueue`队列中的第一个回调函数，从而将取消对`worker`的锁定。如果没有可用的回调函数，这意味着所有的`worker`都是工作状态，只需要添加一个新的任务到`taskQueue`任务队列中。\\n\\n在`TaskQueue`类中，`worker`充当消费者的角色，而调用`pushTask()`函数的角色可以被认为是生产者。这个模式向我们展示了一个`Generator`函数实际上可以跟一个线程或进程类似。实际上，生产者 - 消费者之间问题是研究进程间通信和同步时最常见的问题，但正如我们已经提到的那样，它对于进程和线程来说，也是一个常见的例子。\\n\\n### 限制下载任务的并发量\\n既然我们已经使用`Generator`函数和生产者 - 消费者模型实现一个限制并行算法，并且已经在`Web爬虫应用程序`第四版应用它来限制中下载任务的并发数。 首先，我们加载和初始化一个`TaskQueue`对象：\\n\\n```javascript\\nconst TaskQueue = require('./taskQueue');\\nconst downloadQueue = new TaskQueue(2);\\n```\\n\\n然后，修改`spiderLinks()`函数。和之前不限制并发的版本类似，所以这里我们只展示修改的部分，主要是通过调用新版本的`TaskQueue`类生成的实例的`pushTask()`方法来限制并行执行：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  //...\\n  return (callback) => {\\n    //...\\n    function done(err, result) {\\n      //...\\n    }\\n    links.forEach(function(link) {\\n      downloadQueue.pushTask(function*() {\\n        yield spider(link, nesting - 1);\\n        done();\\n      });\\n    });\\n  }\\n}\\n```\\n\\n在每个任务中，我们在下载完成后立即调用`done()`函数，因此我们可以计算下载了多少个链接，然后在完成下载时通知`thunk`的回调函数执行。\\n\\n## 配合Babel使用Async await新语法\\n回调函数、`Promise`和`Generator`函数都是用于处理`JavaScript`和`Node.js`异步问题的方式。正如我们所看到的，`Generator`的真正意义在于它提供了一种方式来暂停一个函数的执行，然后等待前面的任务完成后再继续执行。我们可以使用这样的特性来书写异步代码，并且让开发者用同步阻塞的代码风格来书写异步代码。等到异步操作的结果返回后才恢复当前函数的执行。\\n\\n但`Generator`函数是更多的是用来处理迭代器，然而迭代器在异步代码的使用显得有点笨重。代码可能难以理解，导致代码易读性和可维护性差。\\n\\n但在不远的将来会有一种更加简洁的语法。实际上，这个提议即将引入到`ESMASCript 2017`的规范中，这项规范定义了`async`函数语法。\\n\\n`async`函数规范引入两个关键字(`async`和`await`)到原生的`JavaScript`语言中，改进我们书写异步代码的方式。\\n\\n为了理解这项语法的用法和优势为，我们看一个简单的例子：\\n\\n```javascript\\nconst request = require('request');\\n\\nfunction getPageHtml(url) {\\n  return new Promise(function(resolve, reject) {\\n    request(url, function(error, response, body) {\\n      resolve(body);\\n    });\\n  });\\n}\\nasync function main() {\\n  const html = await getPageHtml('http://google.com');\\n  console.log(html);\\n}\\n\\nmain();\\nconsole.log('Loading...');\\n```\\n\\n在上述代码中，有两个函数：`getPageHtml`和`main`。第一个函数的作用是提取给定`URL`的一个远程网页的`HTML`文档代码。值得注意的是，这个函数返回一个`Promise`对象。\\n\\n重点在于`main`函数，因为在这里使用了`async`和`await`关键字。首先要注意的是函数要以`async`关键字为前缀。意思是这个函数执行的是异步代码并且允许它在函数体内使用`await`关键字。`await`关键字在`getPageHtml`调用之前，告诉`JavaScript`解释器在继续执行下一条指令之前，等待`getPageHtml`返回的`Promise`对象的结果。这样，`main`函数内部哪部分代码是异步的，它会等待异步代码的完成再继续执行后续操作，并且不会阻塞这段程序其余部分的正常执行。实际上，控制台会打印字符串`Loading...`，随后是Google主页的`HTML`代码。\\n\\n是不是这种方法的可读性更好并且更容易理解呢? 不幸地是，这个提议尚未定案，即使通过这个提议，我们需要等下一个版本\\n的`ECMAScript`规范出来并把它集成到`Node.js`后，才能使用这个新语法。 所以我们今天做了什么?只是漫无目的地等待?不是，当然不是！我们已经可以在我们的代码中使用`async await`语法，只要我们使用`Babel`。\\n\\n### 安装与运行Babel\\n`Babel`是一个`JavaScript`编译器(或翻译器)，能够使用语法转换器将高版本的`JavaScript`代码转换成其他`JavaScript`代码。语法转换器允许例如我们书写并使用`ES2015`，`ES2016`，`JSX`和其它的新语法，来翻译成往后兼容的代码，在`JavaScript`运行环境如浏览器或`Node.js`中都可以使用`Babel`。\\n\\n在项目中使用`npm`安装`Babel`，命令如下：\\n\\n```\\nnpm install --save-dev babel-cli\\n```\\n\\n我们还需要安装插件以支持`async await`语法的解释或翻译：\\n\\n```\\nnpm install --save-dev babel-plugin-syntax-async-functions babel-plugin-tranform-async-to-generator\\n```\\n\\n现在假设我们想运行我们之前的例子（称为`index.js`）。我们需要通过以下命令启动：\\n\\n```\\nnode_modules/.bin/babel-node --plugins \\\"syntax-async-functions,transform-async-to-generator\\\" index.js\\n```\\n\\n这样，我们使用支持`async await`的转换器动态地转换源代码。`Node.js`运行的实际是保存在内存中的往后兼容的代码。\\n\\n`Babel`也能被配置为一个代码构建工具，保存翻译或解释后的代码到本地文件系统中，便于我们部署和运行生成的代码。\\n\\n> 关于如何安装和配置Babel，可以到官方网站 https://babeljs.io 查阅相关文档。\\n\\n## 几种方式的比较\\n现在，我们应该对于怎么处理`JavaScript`的异步问题有了一个更好的认识和总结。在下面的表格中总结几大机制的优势和劣势：\\n\\n![](http://oczira72b.bkt.clouddn.com/17-11-7/55293366.jpg)\\n\\n> 值得一提的是，我们选择在本章中仅介绍处理异步控制流程的最受欢迎的解决方案，或者是广泛使用的解决方案，但是例如Fibers（ https://npmjs.org/package/fibers ）和Streamline（ https://npmjs.org/p ackage/streamline ）也是值得一看的。\\n\\n## 总结\\n在本章中，我们分析了一些处理异步控制流的方法，分析了`Promise`、`Generator`函数和即将到来的`async await`语法。\\n\\n我们学习了如何使用这些方法编写更简洁，更具有可读性的异步代码。我们讨论了这些方法的一些最重要的优点和缺点，并认识到即使它们非常有用，也需要一些时间来掌握。这就是这几种方式也没有完全取代在许多情况下仍然非常有用的回调的原因。作为一名开发人员，应该按照实际情况分析决定使用哪种解决方案。如果您正在构建执行异步操作的公共库，则应该提供易于使用的`API`，即使对于只想使用回调的开发人员也是如此。\\n\\n在下一章中，我们将探讨另一个与异步代码执行相关的机制，这也是整个`Node.js`生态系统中的另一个基本构建块：`streams`。\"\n}"
*************** response log end ***************

[2017-12-01 12:18:09.900] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/users/getUserInfo?userName=admin
request client ip:  ::1
request query:  {"userName":"admin"}
response time: 2
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"回复成功\",\n  \"data\": {\n    \"userName\": \"admin\",\n    \"registerTime\": \"2017-11-23T07:36:51.931Z\",\n    \"message\": []\n  }\n}"
*************** response log end ***************

[2017-12-01 12:18:27.006] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/users/getUserInfo?userName=admin
request client ip:  ::1
request query:  {"userName":"admin"}
response time: 2
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"回复成功\",\n  \"data\": {\n    \"userName\": \"admin\",\n    \"registerTime\": \"2017-11-23T07:36:51.931Z\",\n    \"message\": []\n  }\n}"
*************** response log end ***************

[2017-12-01 12:19:05.434] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/users/getUserInfo?userName=admin
request client ip:  ::1
request query:  {"userName":"admin"}
response time: 2
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"回复成功\",\n  \"data\": {\n    \"userName\": \"admin\",\n    \"registerTime\": \"2017-11-23T07:36:51.931Z\",\n    \"message\": []\n  }\n}"
*************** response log end ***************

[2017-12-01 12:19:09.187] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/users/getUserInfo?userName=admin
request client ip:  ::1
request query:  {"userName":"admin"}
response time: 2
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"回复成功\",\n  \"data\": {\n    \"userName\": \"admin\",\n    \"registerTime\": \"2017-11-23T07:36:51.931Z\",\n    \"message\": []\n  }\n}"
*************** response log end ***************

[2017-12-01 12:19:16.306] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/upload/getMdFileContent
request client ip:  ::1
request body: 
{}
response time: 4
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"解析成功\",\n  \"data\": \"# Asynchronous Control Flow Patterns with ES2015 and Beyond\\n在上一章中，我们学习了如何使用回调处理异步代码，以及如何解决如回调地狱代码等异步问题。回调是`JavaScript`和`Node.js`中的异步编程的基础，但是现在，其他替代方案已经出现。这些替代方案更复杂，以便能够以更方便的方式处理异步代码。\\n\\n在本章中，我们将探讨一些代表性的替代方案，`Promise`和`Generator`。以及`async await`，这是一种创新的语法，可在高版本的`JavaScript`中提供，其也作为`ECMAScript 2017`发行版的一部分。\\n\\n我们将看到这些替代方案如何简化处理异步控制流的方式。最后，我们将比较所有这些方法，以了解所有这些方法的所有优点和缺点，并能够明智地选择最适合我们下一个`Node.js`项目要求的方法。\\n\\n## Promise\\n我们在前面的章节中提到，`CPS风格`不是编写异步代码的唯一方法。事实上，`JavaScript`生态系统为传统的回调模式提供了有趣的替代方案。最着名的选择之一是`Promise`，特别是现在它是`ECMAScript 2015`的一部分，并且现在可以在`Node.js`中可用。\\n\\n### 什么是Promise？\\n`Promise`是一种抽象的对象，我们通常允许函数返回一个名为`Promise`的对象，它表示异步操作的最终结果。通常情况下，我们说当异步操作尚未完成时，我们说`Promise`对象处于`pending`状态，当操作成功完成时，我们说`Promise`对象处于`resolve`状态，当操作错误终止时，我们说`Promise`对象处于`reject`状态。一旦`Promise`处于`resolve`或`reject`，我们认为当前异步操作结束。\\n\\n为了接收到异步操作的正确结果或错误捕获，我们可以使用`Promise`的`then`方法：\\n\\n```javascript\\npromise.then([onFulfilled], [onRejected])\\n```\\n\\n在前面的代码中，`onFulfilled()`是一个函数，最终会收到`Promise`的正确结果，而`onRejected()`是另一个函数，它将接收产生异常的原因（如果有的话）。两个参数都是可选的。\\n\\n要了解`Promise`如何转换我们的代码，让我们考虑以下几点：\\n\\n```javascript\\nasyncOperation(arg, (err, result) => {\\n  if (err) {\\n    // 错误处理\\n  }\\n  // 正常结果处理\\n});\\n```\\n\\n`Promise`允许我们将这个典型的`CPS`代码转换成更好的结构化和更优雅的代码，如下所示：\\n\\n```javascript\\nasyncOperation(arg)\\n  .then(result => {\\n    // 错误处理\\n  }, err => {\\n    // 正常结果处理\\n  });\\n```\\n\\n`then()`方法的一个关键特征是它同步地返回另一个`Promise`对象。如果`onFulfilled()`或`onRejected()`函数中的任何一个函数返回`x`，则`then()`方法返回的`Promise`对象将如下所示：\\n\\n* 如果`x`是一个值，则这个`Promise`对象会正确处理(`resolve`)`x`\\n* 如果`x`是一个`Promise`对象或`thenable`，则会正确处理(`resolve`)`x`\\n* 如果`x`是一个异常，则会捕获异常(`reject`)`x`\\n\\n> 注：thenable是一个具有then方法的类似于Promise的对象(Promise-like)。\\n\\n这个特点使我们能够链式构建`Promise`，允许轻松排列组合我们的异步操作。另外，如果我们没有指定一个`onFulfilled()`或`onRejected()`处理程序，则正确结果或异常捕获将自动转发到`Promise`链的下一个`Promise`。例如，这允许我们在整个链中自动传播错误，直到被`onRejected()`处理程序捕获。随着`Promise`链，任务的顺序执行突然变成简单多了：\\n\\n```javascript\\nasyncOperation(arg)\\n  .then(result1 => {\\n    // 返回另一个Promise\\n    return asyncOperation(arg2);\\n  })\\n  .then(result2 => {\\n    // 返回一个值\\n    return 'done';\\n  })\\n  .then(undefined, err => {\\n    // 捕获Promise链中的异常\\n  });\\n```\\n\\n下图展示了链式`Promise`如何工作：\\n\\n![](http://oczira72b.bkt.clouddn.com/17-10-31/46370382.jpg)\\n\\n`Promise`的另一个重要特性是`onFulfilled()`和`onRejected()`函数是异步调用的，如同上述的例子，在最后那个`then`函数`resolve`一个同步的`Promise`，它也是同步的。这种模式避免了`Zalgo`（参见`Chapter2-Node.js Essential Patterns`），使我们的异步代码更加一致和稳健。\\n\\n如果在`onFulfilled()`或`onRejected()`处理程序中抛出异常（使用`throw`语句），则`then()`方法返回的`Promise`将被自动地`reject`，抛出异常作为`reject`的原因。这相对于`CPS`来说是一个巨大的优势，因为它意味着有了`Promise`，异常将在整个链中自动传播，并且`throw`语句终于可以使用。\\n\\n在以前，许多不同的库实现了`Promise`，大多数时候它们之间不兼容，这意味着不可能在使用不同`Promise`库的`thenable`链式传播错误。\\n\\n`JavaScript`社区非常努力地解决了这个限制，这些努力导致了`Promises / A +`规范的创建。该规范详细描述了`then`方法的行为，提供了一个可互兼容的基础，这使得来自不同库的`Promise`对象能够彼此兼容，开箱即用。\\n\\n有关`Promises / A +`规范的详细说明，可以参考[Promises / A + 官方网站](https://promisesaplus.com)。\\n\\n### Promise / A + 的实施\\n在`JavaScript`中以及`Node.js`中，有几个实现`Promises / A +`规范的库。以下是最受欢迎的：\\n\\n* [Bluebird](https://npmjs.org/package/bluebird)\\n* [Q](https://npmjs.org/package/q)\\n* [RSVP](https://npmjs.org/package/rsvp)\\n* [Vow](https://npmjs.org/package/vow)\\n* [When.js](https://npmjs.org/package/when)\\n* ES2015 promises\\n\\n真正区别他们的是在`Promises / A +`标准之上提供的额外功能。正如我们上述所说的那样，该标准定义了`then()`方法和`Promise`解析过程的行为，但它没有指定其他功能，例如，如何从基于回调的异步函数创建`Promise`。\\n\\n在我们的示例中，我们将使用由`ES2015`的`Promise`，因为`Promise`对象自`Node.js 4`后即可使用，而不需要任何库来实现。\\n\\n作为参考，以下是`ES2015`的`Promise`提供的API：\\n\\n`constructor`(`new Promise（function（resolve, reject）{}）`)：创建了一个新的`Promise`，它基于作为传递两个类型为函数的参数来决定`resolve`或`reject`。构造函数的参数解释如下：\\n\\n* `resolve(obj)` ：`resolve`一个`Promise`，并带上一个参数`obj`，如果`obj`是一个值，这个值就是传递的异步操作成功的结果。如果`obj`是一个`Promise`或一个`thenable`，则会进行正确处理。\\n* `reject(err)`：`reject`一个`Promise`，并带上一个参数`err`。它是`Error`对象的一个实例。\\n\\n#### Promise对象的静态方法\\n* `Promise.resolve(obj)`： 将会创建一个`resolve`的`Promise`实例\\n* `Promise.reject(err)`： 将会创建一个`reject`的`Promise`实例\\n* `Promise.all(iterable)`：返回一个新的`Promise`实例，并且在`iterable`中所\\n有`Promise`状态为`reject`时, 返回的`Promise`实例的状态会被置为`reject`，如果`iterable`中至少有一个`Promise`状态为`reject`时, 返回的`Promise`实例状态也会被置为`reject`，并且`reject`的原因是第一个被`reject`的`Promise`对象的`reject`原因。\\n* `Promise.race(iterable)`：返回一个`Promise`实例，当`iterable`中任何一个`Promise`被`resolve`或被`reject`时， 返回的`Promise`实例以同样的原因`resolve`或`reject`。\\n\\n#### Promise实例方法\\n* `Promise.then(onFulfilled, onRejected)`：这是`Promise`的基本方法。它的行为与我们之前描述的`Promises / A +`标准兼容。\\n* `Promise.catch(onRejected)`：这只是`Promise.then(undefined，onRejected)`的语法糖。\\n\\n> 值得一提的是，一些Promise实现提供了另一种机制来创建新的Promise，称为deferreds。我们不会在这里描述，因为它不是ES2015标准的一部分，但是如果您想了解更多信息，可以阅读Q文档 (https://github.com/kriskowal/q#using-deferreds) 或When.js文档 (https://github.com/cujojs/when/wiki/Deferred) 。\\n\\n### Promisifying一个Node.js回调风格的函数\\n在`JavaScript`中，并不是所有的异步函数和库都支持开箱即用的`Promise`。大多数情况下，我们必须将一个典型的基于回调的函数转换成一个返回`Promise`的函数，这个过程也被称为`promisification`。\\n\\n幸运的是，`Node.js`中使用的回调约定允许我们创建一个可重用的函数，我们通过使用`Promise`对象的构造函数来简化任何`Node.js`风格的`API`。让我们创建一个名为`promisify()`的新函数，并将其包含到`utilities.js`模块中（以便稍后在我们的`Web爬虫应用程序`中使用它）：\\n\\n```javascript\\nmodule.exports.promisify = function(callbackBasedApi) {\\n  return function promisified() {\\n    const args = [].slice.call(arguments);\\n    return new Promise((resolve, reject) => {\\n      args.push((err, result) => {\\n        if (err) {\\n          return reject(err);\\n        }\\n        if (arguments.length <= 2) {\\n          resolve(result);\\n        } else {\\n          resolve([].slice.call(arguments, 1));\\n        }\\n      });\\n      callbackBasedApi.apply(null, args);\\n    });\\n  }\\n};\\n```\\n\\n前面的函数返回另一个名为`promisified()`的函数，它表示输入中给出的`callbackBasedApi`的`promisified`版本。以下展示它是如何工作的：\\n\\n1. `promisified()`函数使用`Promise`构造函数创建一个新的`Promise`对象，并立即将其返回给调用者。\\n2. 在传递给`Promise`构造函数的函数中，我们确保传递给`callbackBasedApi`，这是一个特殊的回调函数。由于我们知道回调总是最后调用的，我们只需将回调函数附加到提供给`promisified()`函数的参数列表里（`args`）。\\n3. 在特殊的回调中，如果我们收到错误，我们立即`reject`这个`Promise`。\\n4. 如果没有收到错误，我们使用一个值或一个数组值来`resolve`这个`Promise`，具体取决于传递给回调的结果数量。\\n5. 最后，我们只需使用我们构建的参数列表调用`callbackBasedApi`。\\n\\n> 大部分的Promise已经提供了一个开箱即用的接口来将一个Node.js风格的API转换成一个返回Promise的API。例如，Q有Q.denodeify()和Q.nbind()，Bluebird有Promise.promisify()，而When.js有node.lift()。\\n\\n### 顺序执行\\n在一些必要的理论之后，我们现在准备将我们的`Web爬虫应用程序`转换为使用`Promise`的形式。让我们直接从版本2开始，直接下载一个Web网页的链接。\\n\\n在`spider.js`模块中，第一步是加载我们的`Promise`实现（我们稍后会使用它）和`Promisifying`我们打算使用的基于回调的函数：\\n\\n```javascript\\nconst utilities = require('./utilities');\\nconst request = utilities.promisify(require('request'));\\nconst mkdirp = utilities.promisify(require('mkdirp'));\\nconst fs = require('fs');\\nconst readFile = utilities.promisify(fs.readFile);\\nconst writeFile = utilities.promisify(fs.writeFile);\\n```\\n\\n现在，我们开始更改我们的`download`函数：\\n\\n```javascript\\nfunction download(url, filename) {\\n  console.log(`Downloading ${url}`);\\n  let body;\\n  return request(url)\\n    .then(response => {\\n      body = response.body;\\n      return mkdirp(path.dirname(filename));\\n    })\\n    .then(() => writeFile(filename, body))\\n    .then(() => {\\n      console.log(`Downloaded and saved: ${url}`);\\n      return body;\\n    });\\n}\\n```\\n\\n这里要注意的到的最重要的是我们也为`readFile()`返回的`Promise`注册\\n一个`onRejected()`函数，用来处理一个网页没有被下载的情况(或文件不存在)。 还有，看我们如何使用`throw`来传递`onRejected()`函数中的错误的。\\n\\n既然我们已经更改我们的`spider()`函数，我们这么修改它的调用方式：\\n\\n```javascript\\nspider(process.argv[2], 1)\\n  .then(() => console.log('Download complete'))\\n  .catch(err => console.log(err));\\n```\\n\\n注意我们是如何第一次使用`Promise`的语法糖`catch`来处理源自`spider()`函数的任何错误情况。如果我们再看看迄今为止我们所写的所有代码，那么我们会惊喜的发现，我们没有包含任何错误传播逻辑，因为我们在使用回调函数时会被迫做这样的事情。这显然是一个巨大的优势，因为它极大地减少了我们代码中的样板文件以及丢失任何异步错误的机会。\\n\\n现在，完成我们唯一缺失的`Web爬虫应用程序`的第二版的`spiderLinks()`函数，我们将在稍后实现它。\\n\\n### 顺序迭代\\n到目前为止，`Web爬虫应用程序`代码库主要是对`Promise`是什么以及如何使用的概述，展示了使用`Promise`实现顺序执行流程的简单性和优雅性。但是，我们现在考虑的代码只涉及到一组已知的异步操作的执行。所以，完成我们对顺序执行流程的探索的缺失部分是看我们如何使用`Promise`来实现迭代。同样，网络蜘蛛第二版的`spiderLinks()`函数也是一个很好的例子。\\n\\n让我们添加缺少的这一块：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  let promise = Promise.resolve();\\n  if (nesting === 0) {\\n    return promise;\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  links.forEach(link => {\\n    promise = promise.then(() => spider(link, nesting - 1));\\n  });\\n  return promise;\\n}\\n```\\n\\n为了异步迭代一个网页的全部链接，我们必须动态创建一个`Promise`的迭代链。\\n\\n1. 首先，我们定义一个空的`Promise`，`resolve`为`undefined`。这个`Promise`只是用来作为`Promise`的迭代链的起始点。 \\n2. 然后，我们通过在循环中调用链中前一个`Promise`的`then()`方法获得的新的`Promise`来更新`Promise`变量。这就是我们使用`Promise`的异步迭代模式。\\n\\n这样，循环的结束，`promise`变量会包含循环中最后一个`then()`返回的`Promise`对象，所以它只有当`Promise`的迭代链中全部`Promise`对象被`resolve`后才能被`resolve`。\\n\\n> 注：在最后调用了这个then方法来resolve这个Promise对象\\n\\n通过这个，我们已使用`Promise`对象重写了我们的`Web爬虫应用程序`。我们现在应该可以运行它了。\\n\\n### 顺序迭代模式\\n为了总结这个顺序执行的部分，让我们提取一个模式来依次遍历一组`Promise`：\\n\\n```javascript\\nlet tasks = [ /* ... */ ]\\nlet promise = Promise.resolve();\\ntasks.forEach(task => {\\n  promise = promise.then(() => {\\n    return task();\\n  });\\n});\\npromise.then(() => {\\n  // 所有任务都完成\\n});\\n```\\n\\n使用`reduce()`方法来替代`forEach()`方法，允许我们写出更为简洁的代码：\\n\\n```javascript\\nlet tasks = [ /* ... */ ]\\nlet promise = tasks.reduce((prev, task) => {\\n  return prev.then(() => {\\n    return task();\\n  });\\n}, Promise.resolve());\\n\\npromise.then(() => {\\n  //All tasks completed\\n});\\n```\\n\\n与往常一样，通过对这种模式的简单调整，我们可以将所有任务的结果收集到一个数组中，我们可以实现一个`mapping`算法，或者构建一个`filter`等等。\\n\\n> 上述这个模式使用循环动态地建立一个链式的Promise。\\n\\n### 并行执行\\n另一个适合用`Promise`的执行流程是并行执行流程。实际上，我们需要做的就是使用内置的`Promise.all()`。这个方法创造了另一个`Promise`对象，只有在输入中的所有`Promise`都`resolve`时才能`resolve`。这是一个并行执行，因为在其参数`Promise`对象的之间没有执行顺序可言。\\n\\n为了演示这一点，我们来看我们的`Web爬虫应用程序`的第三版，它将页面中的所有链接并行下载。让我们再次使用`Promise`更新`spiderLinks()`函数来实现并行流程：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return Promise.resolve();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  const promises = links.map(link => spider(link, nesting - 1));\\n  return Promise.all(promises);\\n}\\n```\\n\\n这里的模式在`elements.map()`迭代中产生一个数组，存放所有异步任务，之后便于同时启动`spider()`任务。这一次，在循环中，我们不等待以前的下载完成，然后开始一个新的下载任务：所有的下载任务在一个循环中一个接一个地开始。之后，我们利用`Promise.all()`方法，它返回一个新的`Promise`对象，当数组中的所有`Promise`对象都被`resolve`时，这个`Promise`对象将被`resolve`。换句话说，所有的下载任务完成，这正是我们想要的。\\n\\n### 限制并行执行\\n不幸的是，`ES2015`的`Promise API`并没有提供一种原生的方式来限制并发任务的数量，但是我们总是可以依靠我们所学到的有关用普通`JavaScript`来限制并发。事实上，我们在`TaskQueue`类中实现的模式可以很容易地被调整来支持返回承诺的任务。这很容易通过修改`next()`方法来完成：\\n\\n```javascript\\nclass TaskQueue {\\n  constructor(concurrency) {\\n    this.concurrency = concurrency;\\n    this.running = 0;\\n    this.queue = [];\\n  }\\n\\n  pushTask(task) {\\n    this.queue.push(task);\\n    this.next();\\n  }\\n\\n  next() {\\n    while (this.running < this.concurrency && this.queue.length) {\\n      const task = this.queue.shift();\\n      task().then(() => {\\n        this.running--;\\n        this.next();\\n      });\\n      this.running++;\\n    }\\n  }\\n}\\n```\\n\\n不同于使用一个回调函数来处理任务，我们简单地调用`Promise`的`then()`。\\n\\n让我们回到`spider.js`模块，并修改它以支持我们的新版本的`TaskQueue`类。首先，我们确保定义一个`TaskQueue`的新实例：\\n\\n```javascript\\nconst TaskQueue = require('./taskQueue');\\nconst downloadQueue = new TaskQueue(2);\\n```\\n\\n然后，是我们的`spiderLinks()`函数。这里的修改也是很简单：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return Promise.resolve();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  // 我们需要如下代码，用于创建Promise对象\\n  // 如果没有下列代码，当任务数量为0时，将永远不会resolve\\n  if (links.length === 0) {\\n    return Promise.resolve();\\n  }\\n  return new Promise((resolve, reject) => {\\n    let completed = 0;\\n    let errored = false;\\n    links.forEach(link => {\\n      let task = () => {\\n        return spider(link, nesting - 1)\\n          .then(() => {\\n            if (++completed === links.length) {\\n              resolve();\\n            }\\n          })\\n          .catch(() => {\\n            if (!errored) {\\n              errored = true;\\n              reject();\\n            }\\n          });\\n      };\\n      downloadQueue.pushTask(task);\\n    });\\n  });\\n}\\n```\\n\\n在上述代码中有几点值得我们注意的：\\n\\n* 首先，我们需要返回使用`Promise`构造函数创建的新的`Promise`对象。正如我们将看到的，这使我们能够在队列中的所有任务完成时手动`resolve`我们的`Promise`对象。\\n* 然后，我们应该看看我们如何定义任务。我们所做的是将一个`onFulfilled()`回调函数的调用添加到由`spider()`返回的`Promise`对象中，所以我们可以计算完成的下载任务的数量。当完成的下载量与当前页面中链接的数量相同时，我们知道任务已经处理完毕，所以我们可以调用外部`Promise`的`resolve()`函数。\\n\\n> Promises / A +规范规定，then()方法的onFulfilled()和onRejected()回调函数只能调用一次（仅调用onFulfilled()和onRejected()）。Promise接口的实现确保即使我们多次手动调用resolve或reject，Promise也仅可以被resolve或reject一次。\\n\\n现在，使用`Promise`的`Web爬虫应用程序`的第4版应该已经准备好了。我们可能再次注意到下载任务如何并行运行，并发数量限制为2。\\n\\n### 在公有API中暴露回调函数和Promise\\n正如我们在前面所学到的，`Promise`可以被用作回调函数的一个很好的替代品。它们使我们的代码更具可读性和易于理解。虽然`Promise`带来了许多优点，但也要求开发人员理解许多不易于理解的概念，以便正确和熟练地使用。由于这个原因和其他原因，在某些情况下，比起`Promise`来说，很多开发者更偏向于回调函数。\\n\\n现在让我们想象一下，我们想要构建一个执行异步操作的公共库。我们需要做什么？我们是创建了一个基于回调函数的`API`还是一个面向`Promise`的`API`？还是两者均有？\\n\\n这是许多知名的库所面临的问题，至少有两种方法值得一提，使我们能够提供一个多功能的`API`。\\n\\n像`request`，`redis`和`mysql`这样的库所使用的第一种方法是提供一个简单的基于回调函数的`API`，如果需要，开发人员可以选择公开函数。其中一些库提供工具函数来`Promise`化异步回调，但开发人员仍然需要以某种方式将暴露的`API`转换为能够使用`Promise`对象。\\n\\n第二种方法更透明。它还提供了一个面向回调的`API`，但它使回调参数可选。每当回调作为参数传递时，函数将正常运行，在完成时或失败时执行回调。当回调未被传递时，函数将立即返回一个`Promise`对象。这种方法有效地结合了回调函数和`Promise`，使得开发者可以在调用时选择采用什么接口，而不需要提前进行`Promise`化。许多库，如`mongoose`和`sequelize`，都支持这种方法。\\n\\n我们来看一个简单的例子。假设我们要实现一个异步执行除法的模块：\\n\\n```javascript\\nmodule.exports = function asyncDivision(dividend, divisor, cb) {\\n  return new Promise((resolve, reject) => { // [1]\\n    process.nextTick(() => {\\n      const result = dividend / divisor;\\n      if (isNaN(result) || !Number.isFinite(result)) {\\n        const error = new Error('Invalid operands');\\n        if (cb) {\\n          cb(error); // [2]\\n        }\\n        return reject(error);\\n      }\\n      if (cb) {\\n        cb(null, result); // [3]\\n      }\\n      resolve(result);\\n    });\\n  });\\n};\\n```\\n\\n该模块的代码非常简单，但是有一些值得强调的细节：\\n\\n* 首先，返回使用`Promise`的构造函数创建的新承诺。我们在构造函数参数函数内定义全部逻辑。\\n* 在发生错误的情况下，我们`reject`这个`Promise`，但如果回调函数在被调用时作为参数传递，我们也执行回调来进行错误传播。\\n* 在计算结果之后，我们`resolve`了这个`Promise`，但是如果有回调函数，我们也会将结果传播给回调函数。\\n\\n我们现在看如何用回调函数和`Promise`来使用这个模块：\\n\\n```javascript\\n// 回调函数的方式\\nasyncDivision(10, 2, (error, result) => {\\n  if (error) {\\n    return console.error(error);\\n  }\\n  console.log(result);\\n});\\n\\n// Promise化的调用方式\\nasyncDivision(22, 11)\\n  .then(result => console.log(result))\\n  .catch(error => console.error(error));\\n```\\n\\n应该很清楚的是，即将开始使用类似于上述的新模块的开发人员将很容易地选择最适合自己需求的风格，而无需在希望利用`Promise`时引入外部`promisification`功能。\\n\\n## Generators\\n`ES2015`规范引入了另外一种机制，除了其他新功能外，还可以用来简化`Node.js`应用程序的异步控制流程。我们正在谈论`Generator`，也被称为`semi-coroutines`。它们是子程序的一般化，可以有不同的入口点。在一个正常的函数中，实际上我们只能有一个入口点，这个入口点对应着函数本身的调用。`Generator`与一般函数类似，但是可以暂停（使用`yield`语句），然后在稍后继续执行。在实现迭代器时，`Generator`特别有用，因为我们已经讨论了如何使用迭代器来实现重要的异步控制流模式，如顺序执行和限制并行执行。\\n\\n### Generators基础\\n在我们探索使用`Generator`来实现异步控制流程之前，学习一些基本概念是很重要的。我们从语法开始吧。可以通过在函数关键字之后附加`*`（星号）运算符来声明`Generator`函数：\\n\\n```javascript\\nfunction* makeGenerator() {\\n  // body\\n}\\n```\\n\\n在`makeGenerator()`函数内部，我们可以使用关键字`yield`暂停执行并返回给调用者传递给它的值：\\n\\n```javascript\\nfunction* makeGenerator() {\\n  yield 'Hello World';\\n  console.log('Re-entered');\\n}\\n```\\n\\n在前面的代码中，`Generator`通过`yield`一个字符串`Hello World`暂停当前函数的执行。当`Generator`恢复时，执行将从下列语句开始：\\n\\n```javascript\\nconsole.log('Re-entered');\\n```\\n\\n`makeGenerator()`函数本质上是一个工厂，它在被调用时返回一个新的`Generator`对象：\\n\\n```javascript\\nconst gen = makeGenerator();\\n```\\n\\n生成器对象的最重要的方法是`next()`，它用于启动/恢复`Generator`的执行，并返回如下形式的对象：\\n\\n```\\n{\\n  value: <yielded value>\\n  done: <true if the execution reached the end>\\n}\\n```\\n\\n这个对象包含`Generator` `yield`的值和一个指示`Generator`是否已经完成执行的符号。\\n\\n### 一个简单的例子\\n为了演示`Generator`，我们来创建一个名为`fruitGenerator.js`的新模块：\\n\\n```javascript\\nfunction* fruitGenerator() {\\n  yield 'apple';\\n  yield 'orange';\\n  return 'watermelon';\\n}\\nconst newFruitGenerator = fruitGenerator();\\nconsole.log(newFruitGenerator.next()); // [1]\\nconsole.log(newFruitGenerator.next()); // [2]\\nconsole.log(newFruitGenerator.next()); // [3]\\n```\\n\\n前面的代码将打印下面的输出：\\n\\n```\\n{ value: 'apple', done: false }\\n{ value: 'orange', done: false }\\n{ value: 'watermelon', done: true }\\n```\\n\\n我们可以这么解释上述现象：\\n\\n* 第一次调用`newFruitGenerator.next()`时，`Generator`函数开始执行，直到达到第一个`yield`语句为止，该命令暂停`Generator`函数执行，并将值`apple`返回给调用者。\\n* 在第二次调用`newFruitGenerator.next()`时，`Generator`函数恢复执行，从第二个`yield`语句开始，这又使得执行暂停，同时将`orange`返回给调用者。\\n* `newFruitGenerator.next()`的最后一次调用导致`Generator`函数的执行从其最后的`yield`恢复，一个返回语句，它终止`Generator`函数，返回`watermelon`，并将结果对象中的`done`属性设置为`true`。\\n\\n### Generators作为迭代器\\n为了更好地理解为什么`Generator`函数对实现迭代器非常有用，我们来构建一个例子。在我们将调用`iteratorGenerator.js`的新模块中，我们编写下面的代码：\\n\\n```javascript\\nfunction* iteratorGenerator(arr) {\\n  for (let i = 0; i < arr.length; i++) {\\n    yield arr[i];\\n  }\\n}\\nconst iterator = iteratorGenerator(['apple', 'orange', 'watermelon']);\\nlet currentItem = iterator.next();\\nwhile (!currentItem.done) {\\n  console.log(currentItem.value);\\n  currentItem = iterator.next();\\n}\\n```\\n\\n此代码应按如下所示打印数组中的元素：\\n\\n```\\napple\\norange\\nwatermelon\\n```\\n\\n在这个例子中，每次我们调用`iterator.next()`时，我们都会恢复`Generator`函数的`for`循环，通过`yield`数组中的下一个项来运行另一个循环。这演示了如何在函数调用过程中维护`Generator`的状态。当继续执行时，循环和所有变量的值与`Generator`函数执行暂停时的状态完全相同。\\n\\n### 传值给Generators\\n现在我们继续研究`Generator`的基本功能，首先学习如何将值传递回`Generator`函数。这其实很简单，我们需要做的只是为`next()`方法提供一个参数，并且该值将作为`Generator`函数内的`yield`语句的返回值提供。\\n\\n为了展示这一点，我们来创建一个新的简单模块：\\n\\n```javascript\\nfunction* twoWayGenerator() {\\n  const what = yield null;\\n  console.log('Hello ' + what);\\n}\\nconst twoWay = twoWayGenerator();\\ntwoWay.next();\\ntwoWay.next('world');\\n```\\n\\n当执行时，前面的代码会输出`Hello world`。我们做如下的解释：\\n\\n* 第一次调用`next()`方法时，`Generator`函数到达第一个`yield`语句，然后暂停。\\n* 当`next('world')`被调用时，`Generator`函数从上次停止的位置，也就是上次的`yield`语句点恢复，但是这次我们有一个值传递到`Generator`函数。这个值将被赋值到`what`变量。生成器然后执行`console.log()`指令并终止。\\n\\n用类似的方式，我们可以强制`Generator`函数抛出异常。这可以通过使用`Generator`函数的`throw`方法来实现，如下例所示：\\n\\n```javascript\\nconst twoWay = twoWayGenerator();\\ntwoWay.next();\\ntwoWay.throw(new Error());\\n```\\n\\n在这个最后这段代码，`twoWayGenerator()`函数将在`yield`函数返回的时候抛出异常。这就好像从`Generator`函数内部抛出了一个异常一样，这意味着它可以像使用`try ... catch`块一样进行捕获和处理异常。\\n\\n### Generator实现异步控制流\\n你一定想知道`Generator`函数如何帮助我们处理异步操作。我们可以通过创建一个接受`Generator`函数作为参数的特殊函数来演示这一点，并允许我们在`Generator`函数内部使用异步代码。这个函数在异步操作完成时要注意恢复`Generator`函数的执行。我们将调用这个函数`asyncFlow()`：\\n\\n```javascript\\nfunction asyncFlow(generatorFunction) {\\n  function callback(err) {\\n    if (err) {\\n      return generator.throw(err);\\n    }\\n    const results = [].slice.call(arguments, 1);\\n    generator.next(results.length > 1 ? results : results[0]);\\n  }\\n  const generator = generatorFunction(callback);\\n  generator.next();\\n}\\n```\\n\\n前面的函数取一个`Generator`函数作为输入，然后立即调用：\\n\\n```javascript\\nconst generator = generatorFunction(callback);\\ngenerator.next();\\n```\\n\\n`generatorFunction()`接受一个特殊的回调函数作为参数，当`generator.throw()`如果接收到一个错误，便立即返回。另外，通过将在回调函数中接收的`results`传值回`Generator`函数继续`Generator`函数的执行:\\n\\n```javascript\\nif (err) {\\n  return generator.throw(err);\\n}\\nconst results = [].slice.call(arguments, 1);\\ngenerator.next(results.length > 1 ? results : results[0]);\\n```\\n\\n为了说明这个简单的辅助函数的强大，我们创建一个叫做`clone.js`的新模块，这个模块只是创建它本身的克隆。粘贴我们刚才创建的`asyncFlow()`函数，核心代码如下：\\n\\n```javascript\\nconst fs = require('fs');\\nconst path = require('path');\\nasyncFlow(function*(callback) {\\n  const fileName = path.basename(__filename);\\n  const myself = yield fs.readFile(fileName, 'utf8', callback);\\n  yield fs.writeFile(`clone_of_${filename}`, myself, callback);\\n  console.log('Clone created');\\n});\\n```\\n\\n明显地，有了`asyncFlow()`函数的帮助，我们可以像我们书写同步阻塞函数一样用同步的方式来书写异步代码了。并且这个结果背后的原理显得很清楚。一旦异步操作结束，传递给每个异步函数的回调函数将继续`Generator`函数的执行。没有什么复杂的，但是结果确实很令人意外。\\n\\n这个技术有其他两个变化，一个是`Promise`的使用，另外一个则是`thunks`。\\n\\n> 在基于Generator的控制流中使用的thunk只是一个简单的函数，它除了回调之外，部分地应用了原始函数的所有参数。返回值是另一个只接受回调作为参数的函数。例如，fs.readFile（）的thunkified版本如下所示：\\n\\n```javascript\\nfunction readFileThunk(filename, options) {\\n  return function(callback) {\\n    fs.readFile(filename, options, callback);\\n  }\\n}\\n```\\n\\n`thunk`和`Promise`都允许我们创建不需要回调的`Generator`函数作为参数传递，例如，使用`thunk`的`asyncFlow()`版本如下：\\n\\n```javascript\\nfunction asyncFlowWithThunks(generatorFunction) {\\n  function callback(err) {\\n    if (err) {\\n      return generator.throw(err);\\n    }\\n    const results = [].slice.call(arguments, 1);\\n    const thunk = generator.next(results.length > 1 ? results : results[0]).value;\\n    thunk && thunk(callback);\\n  }\\n  const generator = generatorFunction();\\n  const thunk = generator.next().value;\\n  thunk && thunk(callback);\\n}\\n```\\n\\n这个技巧是读取`generator.next()`的返回值，返回值中包含`thunk`。下一步是通过注入特殊的回调函数调用`thunk`本身。这允许我们写下面的代码：\\n\\n```javascript\\nasyncFlowWithThunk(function*() {\\n  const fileName = path.basename(__filename);\\n  const myself = yield readFileThunk(__filename, 'utf8');\\n  yield writeFileThunk(`clone_of_${fileName}`, myself);\\n  console.log(\\\"Clone created\\\")\\n});\\n```\\n\\n### 使用co的基于Gernator的控制流\\n你应该已经猜到了，`Node.js`生态系统会借助`Generator`函数来提供一些处理异步控制流的解决方案，例如，[suspend](https://npm/js.org/package/suspend)是其中一个最老的支持`Promise`、`thunks`和`Node.js`风格回调函数和正常风格的回调函数的 库。还有，大部分我们之前分析的`Promise`库都提供工具函数使得`Generator`和`Promise`可以一起使用。\\n\\n我们选择[co](https://npmjs.org/package/co)作为本章节的例子。它支持很多类型的`yieldables`，其中一些是：\\n\\n* `Thunks`\\n* `Promises`\\n* `Arrays`(并行执行)\\n* `Objects`(并行执行)\\n* `Generators`(委托)\\n* `Generator`函数(委托)\\n\\n还有很多框架或库是基于`co`生态系统的，包括以下一些：\\n\\n* `Web框架`，最流行的是[koa](https://npmjs.org/package/koa)\\n* 实现特定控制流模式的库\\n* 包装流行的`API`兼容`co`的库\\n\\n我们使用`co`重新实现我们的`Generator`版本的`Web爬虫应用程序`。\\n\\n为了将`Node.js`风格的函数转换成`thunks`，我们将会使用一个叫做[thunkify](https://npmjs.org/package/thunkify)的库。\\n\\n### 顺序执行\\n让我们通过修改`Web爬虫应用程序`的版本2开始我们对`Generator`函数和`co`的实际探索。我们要做的第一件事就是加载我们的依赖包，并生成我们要使用的函数的`thunkified`版本。这些将在`spider.js`模块的最开始进行：\\n\\n```javascript\\nconst thunkify = require('thunkify');\\nconst co = require('co');\\nconst request = thunkify(require('request'));\\nconst fs = require('fs');\\nconst mkdirp = thunkify(require('mkdirp'));\\nconst readFile = thunkify(fs.readFile);\\nconst writeFile = thunkify(fs.writeFile);\\nconst nextTick = thunkify(process.nextTick);\\n```\\n\\n看上述代码，我们可以注意到与本章前面`promisify`化的`API`的代码的一些相似之处。在这一点上，有意思的是，如果我们使用我们的`promisified`版本的函数来代替`thunkified`的版本，代码将保持完全一样，这要归功于`co`支持`thunk`和`Promise`对象作为`yieldable`对象。事实上，如果我们想，甚至可以在同一个应用程序中使用`thunk`和`Promise`，即使在同一个`Generator`函数中。就灵活性而言，这是一个巨大的优势，因为它使我们能够使用基于`Generator`函数的控制流来解决我们应用程序中的问题。\\n\\n好的，现在让我们开始将`download()`函数转换为一个`Generator`函数：\\n\\n```javascript\\nfunction* download(url, filename) {\\n  console.log(`Downloading ${url}`);\\n  const response = yield request(url);\\n  const body = response[1];\\n  yield mkdirp(path.dirname(filename));\\n  yield writeFile(filename, body);\\n  console.log(`Downloaded and saved ${url}`);\\n  return body;\\n}\\n```\\n\\n通过使用`Generator`和`co`，我们的`download()`函数变得简单多了。当我们需要做异步操作的时候，我们使用异步的`Generator`函数作为`thunk`来把之前的内容转化到`Generator`函数，并使用`yield`子句。\\n\\n然后我们开始实现我们的`spider()`函数：\\n\\n```javascript\\nfunction* spider(url, nesting) {\\n  cost filename = utilities.urlToFilename(url);\\n  let body;\\n  try {\\n    body = yield readFile(filename, 'utf8');\\n  } catch (err) {\\n    if (err.code !== 'ENOENT') {\\n      throw err;\\n    }\\n    body = yield download(url, filename);\\n  }\\n  yield spiderLinks(url, body, nesting);\\n}\\n```\\n\\n从上述代码中一个有趣的细节是我们可以使用`try...catch`语句块来处理异常。我们还可以使用`throw`来传播异常。另外一个细节是我们`yield`我们的`download()`函数，而这个函数既不是一个`thunk`，也不是一个`promisified`函数，只是另外的一个`Generator`函数。这也毫无问题，由于`co`也支持其他`Generators`作为`yieldables`。\\n\\n最后转换`spiderLinks()`，在这个函数中，我们递归下载一个网页的链接。在这个函数中使用`Generators`，显得简单多了：\\n\\n```javascript\\nfunction* spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return nextTick();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  for (let i = 0; i < links.length; i++) {\\n    yield spider(links[i], nesting - 1);\\n  }\\n}\\n```\\n\\n看上述代码。虽然顺序迭代没有什么模式可以展示。`Generator`和`co`辅助我们做了很多，方便了我们可以使用同步方式开书写异步代码。\\n\\n看最重要的部分，程序的入口：\\n\\n```javascript\\nco(function*() {\\n  try {\\n    yield spider(process.argv[2], 1);\\n    console.log(`Download complete`);\\n  } catch (err) {\\n    console.log(err);\\n  }\\n});\\n```\\n\\n这是唯一一处需要调用`co(...)`来封装的一个`Generator`。实际上，一旦我们这么做，`co`会自动封装我们传递给`yield`语句的任何`Generator`函数，并且这个过程是递归的，所以程序的剩余部分与我们是否使用`co`是完全无关的，虽然是被`co`封装在里面。\\n\\n现在应该可以运行使用`Generator`函数改写的`Web爬虫应用程序`了。\\n\\n### 并行执行\\n不幸的是，虽然`Generator`很方便地进行顺序执行，但是不能直接用来并行化执行一组任务，至少不能仅仅使用`yield`和`Generator`。之前，在种情况下我们使用的模式只是简单地依赖于一个基于回调或者`Promise`的函数，但使用了`Generator`函数后，一切会显得更简单。\\n\\n幸运的是，如果不限制并发数的并行执行，`co`已经可以通过`yield`一个`Promise`对象、`thunk`、`Generator`函数，甚至包含`Generator`函数的数组来实现。\\n\\n考虑到这一点，我们的`Web爬虫应用程序`第三版可以通过重写`spiderLinks()`函数来做如下改动：\\n\\n```javascript\\nfunction* spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return nextTick();\\n  }\\n  const links = utilities.getPageLinks(currentUrl, body);\\n  const tasks = links.map(link => spider(link, nesting - 1));\\n  yield tasks;\\n}\\n```\\n\\n但是上述函数所做的只是拿到所有的任务，这些任务本质上都是通过`Generator`函数来实现异步的，如果在`co`的`thunk`内对一个包含`Generator`函数的数组使用`yield`，这些任务都会并行执行。外层的`Generator`函数会等到`yield`子句的所有异步任务并行执行后再继续执行。\\n\\n接下来我们看怎么用一个基于回调函数的方式来解决相同的并行流。我们用这种方式重写`spiderLinks()`函数：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  if (nesting === 0) {\\n    return nextTick();\\n  }\\n  // 返回一个thunk\\n  return callback => {\\n    let completed = 0,\\n      hasErrors = false;\\n    const links = utilities.getPageLinks(currentUrl, body);\\n    if (links.length === 0) {\\n      return process.nextTick(callback);\\n    }\\n\\n    function done(err, result) {\\n      if (err && !hasErrors) {\\n        hasErrors = true;\\n        return callback(err);\\n      }\\n      if (++completed === links.length && !hasErrors) {\\n        callback();\\n      }\\n    }\\n    for (let i = 0; i < links.length; i++) {\\n      co(spider(links[i], nesting - 1)).then(done);\\n    }\\n  }\\n}\\n```\\n\\n我们使用`co`并行运行`spider()`函数，调用`Generator`函数返回了一个`Promise`对象。这样，等待`Promise`完成后调用`done()`函数。通常，基于`Generator`控制流的库都有这一功能，因此如果需要，你总是可以将一个`Generator`转换成一个基于回调或基于`Promise`的函数。\\n\\n为了并行开启多个下载任务，我们只要重用在前面定义的基于回调的并行执行的模式。我们应该也注意到我们将`spiderLinks()`转换成一个`thunk`(而不再是一个`Generator`函数)。这使得当全部并行任务完成时，我们有一个回调函数可以调用。\\n\\n> 上面讲到的是将一个Generator函数转换为一个thunk的模式，使之能够支持其他的基于回调或基于Promise的控制流算法，并可以通过同步阻塞的代码风格书写异步代码。\\n\\n### 限制并行执行\\n现在我们知道如何处理异步执行流程，应该很容易规划我们的`Web爬虫应用程序`的第四版的实现，这个版本对并发下载任务的数量施加了限制。我们有几个方案可以用来做到这一点。其中一些方案如下：\\n\\n* 使用先前实现的基于回调的`TaskQueue`类。我们只需要`thunkify`我们的`Generator`函数和其提供的回调函数即可。\\n* 使用基于`Promise`的`TaskQueue`类，并确保每个作为任务的`Generator`函数都被转换成一个返回`Promise`对象的函数。\\n* 使用`async`，`thunkify`我们打算使用的工具函数，此外还需要把我们用到的`Generator`函数转化为基于回调的模式，以便于能够被这个库较好地使用。\\n* 使用基于`co`的生态系统中的库，特别是专门为这种场景的库，如[co-limiter](https://npmjs.org/package/co-limiter)。\\n* 实现基于生产者 - 消费者模型的自定义算法，这与`co-limiter`的内部实现原理相同。\\n\\n为了学习，我们选择最后一个方案，甚至帮助我们可以更好地理解一种经常与协程(也和线程和进程)同步相关的模式。\\n\\n### 生产者 - 消费者模式\\n我们的目标是利用队列来提供固定数量的`workers`，与我们想要设置的并发级别一样多。为了实现这个算法，我们将基于本章前面定义的`TaskQueue`类改写：\\n\\n```javascript\\nclass TaskQueue {\\n  constructor(concurrency) {\\n    this.concurrency = concurrency;\\n    this.running = 0;\\n    this.taskQueue = [];\\n    this.consumerQueue = [];\\n    this.spawnWorkers(concurrency);\\n  }\\n  pushTask(task) {\\n    if (this.consumerQueue.length !== 0) {\\n      this.consumerQueue.shift()(null, task);\\n    } else {\\n      this.taskQueue.push(task);\\n    }\\n  }\\n  spawnWorkers(concurrency) {\\n    const self = this;\\n    for (let i = 0; i < concurrency; i++) {\\n      co(function*() {\\n        while (true) {\\n          const task = yield self.nextTask();\\n          yield task;\\n        }\\n      });\\n    }\\n  }\\n  nextTask() {\\n    return callback => {\\n      if (this.taskQueue.length !== 0) {\\n        return callback(null, this.taskQueue.shift());\\n      }\\n      this.consumerQueue.push(callback);\\n    }\\n  }\\n}\\n```\\n\\n让我们分析这个`TaskQueue`类的新实现。首先是在构造函数中。需要调用一次`this.spawnWorkers()`，因为这是启动`worker`的方法。\\n\\n我们的`worker`很简单，它们只是用`co()`包装的立即执行的`Generator`函数，所以每个`Generator`函数可以并行执行。在内部，每个`worker`正在运行在一个死循环（`while(true){}`）中，一直阻塞（`yield`）到新任务在队列中可用时（`yield self.nextTask()`），一旦可以执行新任务，`yield`这个异步任务直到其完成。您可能想知道我们如何能够限制并行执行，并让下一个任务在队列中处于等待状态。答案是在`nextTask()`方法中。我们来详细地看看在这个方法的原理：\\n\\n```javascript\\nnextTask() {\\n  return callback => {\\n    if (this.taskQueue.length !== 0) {\\n      return callback(null, this.taskQueue.shift());\\n    }\\n    this.consumerQueue.push(callback);\\n  }\\n}\\n```\\n\\n我们看这个函数内部发生了什么，这才是这个模式的核心：\\n\\n1. 这个方法返回一个对于`co`而言是一个合法的`yieldable`的`thunk`。\\n2. 只要`taskQueue`类生成的实例中还有下一个任务，`thunk`的回调函数会被立即调用。回调函数调用时，立马解锁一个`worker`的阻塞状态，`yield`这一个任务。\\n3. 如果队列中没有任务了，回调函数本身会被放入`consumerQueue`中。通过这种做法，我们将一个`worker`置于空闲（`idle`）的模式。一旦我们有一个新的任务来要处理，在`consumerQueue`队列中的回调函数会被调用，立马唤醒我们这一`worker`进行异步处理。\\n\\n现在，为了理解`consumerQueue`队列中的空闲`worker`是如何恢复工作的，我们需要分析`pushTask()`方法。如果当前有回调函数可用的话，`pushTask()`方法将调用`consumerQueue`队列中的第一个回调函数，从而将取消对`worker`的锁定。如果没有可用的回调函数，这意味着所有的`worker`都是工作状态，只需要添加一个新的任务到`taskQueue`任务队列中。\\n\\n在`TaskQueue`类中，`worker`充当消费者的角色，而调用`pushTask()`函数的角色可以被认为是生产者。这个模式向我们展示了一个`Generator`函数实际上可以跟一个线程或进程类似。实际上，生产者 - 消费者之间问题是研究进程间通信和同步时最常见的问题，但正如我们已经提到的那样，它对于进程和线程来说，也是一个常见的例子。\\n\\n### 限制下载任务的并发量\\n既然我们已经使用`Generator`函数和生产者 - 消费者模型实现一个限制并行算法，并且已经在`Web爬虫应用程序`第四版应用它来限制中下载任务的并发数。 首先，我们加载和初始化一个`TaskQueue`对象：\\n\\n```javascript\\nconst TaskQueue = require('./taskQueue');\\nconst downloadQueue = new TaskQueue(2);\\n```\\n\\n然后，修改`spiderLinks()`函数。和之前不限制并发的版本类似，所以这里我们只展示修改的部分，主要是通过调用新版本的`TaskQueue`类生成的实例的`pushTask()`方法来限制并行执行：\\n\\n```javascript\\nfunction spiderLinks(currentUrl, body, nesting) {\\n  //...\\n  return (callback) => {\\n    //...\\n    function done(err, result) {\\n      //...\\n    }\\n    links.forEach(function(link) {\\n      downloadQueue.pushTask(function*() {\\n        yield spider(link, nesting - 1);\\n        done();\\n      });\\n    });\\n  }\\n}\\n```\\n\\n在每个任务中，我们在下载完成后立即调用`done()`函数，因此我们可以计算下载了多少个链接，然后在完成下载时通知`thunk`的回调函数执行。\\n\\n## 配合Babel使用Async await新语法\\n回调函数、`Promise`和`Generator`函数都是用于处理`JavaScript`和`Node.js`异步问题的方式。正如我们所看到的，`Generator`的真正意义在于它提供了一种方式来暂停一个函数的执行，然后等待前面的任务完成后再继续执行。我们可以使用这样的特性来书写异步代码，并且让开发者用同步阻塞的代码风格来书写异步代码。等到异步操作的结果返回后才恢复当前函数的执行。\\n\\n但`Generator`函数是更多的是用来处理迭代器，然而迭代器在异步代码的使用显得有点笨重。代码可能难以理解，导致代码易读性和可维护性差。\\n\\n但在不远的将来会有一种更加简洁的语法。实际上，这个提议即将引入到`ESMASCript 2017`的规范中，这项规范定义了`async`函数语法。\\n\\n`async`函数规范引入两个关键字(`async`和`await`)到原生的`JavaScript`语言中，改进我们书写异步代码的方式。\\n\\n为了理解这项语法的用法和优势为，我们看一个简单的例子：\\n\\n```javascript\\nconst request = require('request');\\n\\nfunction getPageHtml(url) {\\n  return new Promise(function(resolve, reject) {\\n    request(url, function(error, response, body) {\\n      resolve(body);\\n    });\\n  });\\n}\\nasync function main() {\\n  const html = await getPageHtml('http://google.com');\\n  console.log(html);\\n}\\n\\nmain();\\nconsole.log('Loading...');\\n```\\n\\n在上述代码中，有两个函数：`getPageHtml`和`main`。第一个函数的作用是提取给定`URL`的一个远程网页的`HTML`文档代码。值得注意的是，这个函数返回一个`Promise`对象。\\n\\n重点在于`main`函数，因为在这里使用了`async`和`await`关键字。首先要注意的是函数要以`async`关键字为前缀。意思是这个函数执行的是异步代码并且允许它在函数体内使用`await`关键字。`await`关键字在`getPageHtml`调用之前，告诉`JavaScript`解释器在继续执行下一条指令之前，等待`getPageHtml`返回的`Promise`对象的结果。这样，`main`函数内部哪部分代码是异步的，它会等待异步代码的完成再继续执行后续操作，并且不会阻塞这段程序其余部分的正常执行。实际上，控制台会打印字符串`Loading...`，随后是Google主页的`HTML`代码。\\n\\n是不是这种方法的可读性更好并且更容易理解呢? 不幸地是，这个提议尚未定案，即使通过这个提议，我们需要等下一个版本\\n的`ECMAScript`规范出来并把它集成到`Node.js`后，才能使用这个新语法。 所以我们今天做了什么?只是漫无目的地等待?不是，当然不是！我们已经可以在我们的代码中使用`async await`语法，只要我们使用`Babel`。\\n\\n### 安装与运行Babel\\n`Babel`是一个`JavaScript`编译器(或翻译器)，能够使用语法转换器将高版本的`JavaScript`代码转换成其他`JavaScript`代码。语法转换器允许例如我们书写并使用`ES2015`，`ES2016`，`JSX`和其它的新语法，来翻译成往后兼容的代码，在`JavaScript`运行环境如浏览器或`Node.js`中都可以使用`Babel`。\\n\\n在项目中使用`npm`安装`Babel`，命令如下：\\n\\n```\\nnpm install --save-dev babel-cli\\n```\\n\\n我们还需要安装插件以支持`async await`语法的解释或翻译：\\n\\n```\\nnpm install --save-dev babel-plugin-syntax-async-functions babel-plugin-tranform-async-to-generator\\n```\\n\\n现在假设我们想运行我们之前的例子（称为`index.js`）。我们需要通过以下命令启动：\\n\\n```\\nnode_modules/.bin/babel-node --plugins \\\"syntax-async-functions,transform-async-to-generator\\\" index.js\\n```\\n\\n这样，我们使用支持`async await`的转换器动态地转换源代码。`Node.js`运行的实际是保存在内存中的往后兼容的代码。\\n\\n`Babel`也能被配置为一个代码构建工具，保存翻译或解释后的代码到本地文件系统中，便于我们部署和运行生成的代码。\\n\\n> 关于如何安装和配置Babel，可以到官方网站 https://babeljs.io 查阅相关文档。\\n\\n## 几种方式的比较\\n现在，我们应该对于怎么处理`JavaScript`的异步问题有了一个更好的认识和总结。在下面的表格中总结几大机制的优势和劣势：\\n\\n![](http://oczira72b.bkt.clouddn.com/17-11-7/55293366.jpg)\\n\\n> 值得一提的是，我们选择在本章中仅介绍处理异步控制流程的最受欢迎的解决方案，或者是广泛使用的解决方案，但是例如Fibers（ https://npmjs.org/package/fibers ）和Streamline（ https://npmjs.org/p ackage/streamline ）也是值得一看的。\\n\\n## 总结\\n在本章中，我们分析了一些处理异步控制流的方法，分析了`Promise`、`Generator`函数和即将到来的`async await`语法。\\n\\n我们学习了如何使用这些方法编写更简洁，更具有可读性的异步代码。我们讨论了这些方法的一些最重要的优点和缺点，并认识到即使它们非常有用，也需要一些时间来掌握。这就是这几种方式也没有完全取代在许多情况下仍然非常有用的回调的原因。作为一名开发人员，应该按照实际情况分析决定使用哪种解决方案。如果您正在构建执行异步操作的公共库，则应该提供易于使用的`API`，即使对于只想使用回调的开发人员也是如此。\\n\\n在下一章中，我们将探讨另一个与异步代码执行相关的机制，这也是整个`Node.js`生态系统中的另一个基本构建块：`streams`。\"\n}"
*************** response log end ***************

[2017-12-01 12:19:23.709] [INFO] resLogger - 
*************** response log start ***************
request method: POST
request originalUrl:  /api/upload/getMdFileContent
request client ip:  ::1
request body: 
{}
response time: 2
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"解析成功\",\n  \"data\": \"# Welcom to the Node.js Platform\\n## Node.js 的发展\\n* 技术本身的发展\\n* 庞大的`Node.js`生态圈的发展\\n* 官方组织的维护\\n\\n## Node.js的特点\\n\\n### 小模块\\n以`package`的形式尽可能多的复用模块，原则上每个模块的容量尽量小而精。\\n\\n原则：\\n\\n* \\\"Small is beautiful\\\" ---小而精\\n* \\\"Make each program do one thing well\\\" ---单一职责原则\\n\\n因此，一个`Node.js`应用由多个包搭建而成，包管理器（`npm`）的管理使得他们相互依赖而不起冲突。\\n\\n如果设计一个`Node.js`的模块，尽可能做到以下三点：\\n\\n* 易于理解和使用\\n* 易于测试和维护\\n* 考虑到对客户端（浏览器）的支持更友好\\n\\n以及，`Don't Repeat Yourself(DRY)`复用性原则。\\n\\n### 以接口形式提供\\n每个`Node.js`模块都是一个函数（类也是以构造函数的形式呈现），我们只需要调用相关`API`即可，而不需要知道其它模块的实现。`Node.js`模块是为了使用它们而创建，不仅仅是在拓展性上，更要考虑到维护性和可用性。\\n\\n### 简单且实用\\n> “简单就是终极的复杂”  ————达尔文\\n\\n遵循`KISS(Keep It Simple, Stupid)原则`，即优秀的简洁的设计，能够更有效地传递信息。\\n\\n设计必须很简单，无论在实现还是接口上，更重要的是实现比接口更简单，简单是重要的设计原则。\\n\\n我们做一个设计简单，功能完备，而不是完美的软件：\\n* 实现起来需要更少的努力\\n* 允许用更少的速度进行更快的运输资源\\n* 具有伸缩性，更易于维护和理解\\n* 促进社区贡献，允许软件本身的成长和改进\\n\\n而对于`Node.js`而言，因为其支持`JavaScript`，简单和函数、闭包、对象等特性，可取代复杂的面向对象的类语法。如单例模式和装饰者模式，它们在面向对象的语言都需要很复杂的实现，而对于`JavaScript`则较为简单。\\n\\n## 介绍Node.js 6 和 ES2015的新语法\\n### let和const关键字\\n`ES5`之前，只有函数和全局作用域。\\n\\n```javascript\\nif (false) {\\n  var x = \\\"hello\\\";\\n}\\n\\nconsole.log(x); // undefined\\n```\\n\\n现在用`let`，创建词法作用域，则会报出一个错误`Uncaught ReferenceError: x is not defined`\\n\\n```javascript\\nif (false) {\\n  let x = \\\"hello\\\";\\n}\\n\\nconsole.log(x);\\n```\\n\\n在循环语句中使用`let`，也会报错`Uncaught ReferenceError: i is not defined`：\\n\\n```javascript\\nfor (let i = 0; i < 10; i++) {\\n  // do something here\\n}\\n\\nconsole.log(i);\\n```\\n\\n使用`let`和`const`关键字，可以让代码更安全，如果意外的访问另一个作用域的变量，更容易发现错误。\\n\\n使用`const`关键字声明变量，变量不会被意外更改。\\n\\n```javascript\\nconst x = 'This will never change';\\nx = '...';\\n```\\n\\n这里会报出一个错误`Uncaught TypeError: Assignment to constant variable.`\\n\\n但是对于对象属性的更改，`const`显得毫无办法：\\n\\n```javascript\\nconst x = {};\\nx.name = 'John';\\n```\\n上述代码并不会报错\\n\\n但是如果直接更改对象，还是会抛出一个错误。\\n\\n```javascript\\nconst x = {};\\nx = null;\\n```\\n\\n实际运用中，我们使用`const`引入模块，防止意外被更改：\\n\\n```javascript\\nconst path = require('path');\\nlet path = './some/path';\\n```\\n\\n上述代码会报错，提醒我们意外更改了模块。\\n\\n如果需要创建不可变对象，只是简单的使用`const`是不够的，需要使用`Object.freeze()`或[deep-freeze](https://github.com/substack/deep-freeze)\\n\\n我看了一下源码，其实很少，就是递归使用`Object.freeze()`\\n\\n```javascript\\nmodule.exports = function deepFreeze (o) {\\n  Object.freeze(o);\\n\\n  Object.getOwnPropertyNames(o).forEach(function (prop) {\\n    if (o.hasOwnProperty(prop)\\n    && o[prop] !== null\\n    && (typeof o[prop] === \\\"object\\\" || typeof o[prop] === \\\"function\\\")\\n    && !Object.isFrozen(o[prop])) {\\n      deepFreeze(o[prop]);\\n    }\\n  });\\n  \\n  return o;\\n};\\n```\\n\\n### 箭头函数\\n箭头函数更易于理解，特别是在我们定义回调的时候：\\n```javascript\\nconst numbers = [2, 6, 7, 8, 1];\\nconst even = numbers.filter(function(x) {\\n  return x % 2 === 0;\\n});\\n```\\n\\n使用箭头函数语法，更简洁：\\n\\n```javascript\\nconst numbers = [2, 6, 7, 8, 1];\\nconst even = numbers.filter(x => x % 2 === 0);\\n```\\n\\n如果不止一个`return`语句则使用`=> {}`\\n\\n```javascript\\nconst numbers = [2, 6, 7, 8, 1];\\nconst even = numbers.filter((x) => {\\n  if (x % 2 === 0) {\\n    console.log(x + ' is even');\\n    return true;\\n  }\\n});\\n```\\n\\n最重要是，箭头函数绑定了它的词法作用域，其`this`与父级代码块的`this`相同。\\n\\n```javascript\\nfunction DelayedGreeter(name) {\\n  this.name = name;\\n}\\n\\nDelayedGreeter.prototype.greet = function() {\\n  setTimeout(function cb() {\\n    console.log('Hello' + this.name);\\n  }, 500);\\n}\\n\\nconst greeter = new DelayedGreeter('World');\\ngreeter.greet(); // 'Hello'\\n```\\n\\n要解决这个问题，使用箭头函数或`bind`\\n\\n```javascript\\nfunction DelayedGreeter(name) {\\n  this.name = name;\\n}\\n\\nDelayedGreeter.prototype.greet = function() {\\n  setTimeout(function cb() {\\n    console.log('Hello' + this.name);\\n  }.bind(this), 500);\\n}\\n\\nconst greeter = new DelayedGreeter('World');\\ngreeter.greet(); // 'HelloWorld'\\n```\\n\\n或者箭头函数，与父级代码块作用域相同：\\n\\n```javascript\\nfunction DelayedGreeter(name) {\\n  this.name = name;\\n}\\n\\nDelayedGreeter.prototype.greet = function() {\\n  setTimeout(() => console.log('Hello' + this.name), 500);\\n}\\n\\nconst greeter = new DelayedGreeter('World');\\ngreeter.greet(); // 'HelloWorld'\\n```\\n\\n### 类语法糖\\n\\n`class`是原型继承的语法糖，对于来自传统的面向对象语言的所有开发人员（如`Java`和`C#`）来说更熟悉，新语法并没有改变`JavaScript`的运行特征，通过原型来完成更加方便和易读。\\n\\n传统的通过`构造器 + 原型`的写法：\\n\\n```javascript\\nfunction Person(name, surname, age) {\\n  this.name = name;\\n  this.surname = surname;\\n  this.age = age;\\n}\\n\\nPerson.prototype.getFullName = function() {\\n  return this.name + '' + this.surname;\\n}\\n\\nPerson.older = function(person1, person2) {\\n  return (person1.age >= person2.age) ? person1 : person2;\\n}\\n```\\n\\n使用`class`语法显得更加简洁、方便、易懂：\\n\\n```javascript\\nclass Person {\\n  constructor(name, surname, age) {\\n    this.name = name;\\n    this.surname = surname;\\n    this.age = age;\\n  }\\n\\n  getFullName() {\\n    return this.name + '' + this.surname;\\n  }\\n\\n  static older(person1, person2) {\\n    return (person1.age >= person2.age) ? person1 : person2;\\n  }\\n}\\n```\\n\\n但是上面的实现是可以互换的，但是，对于`class`语法来说，最有意义的是`extends`和`super`关键字。\\n\\n```javascript\\nclass PersonWithMiddlename extends Person {\\n  constructor(name, middlename, surname, age) {\\n    super(name, surname, age);\\n    this.middlename = middlename;\\n  }\\n\\n  getFullName() {\\n    return this.name + '' + this.middlename + '' + this.surname;\\n  }\\n}\\n```\\n\\n这个例子是真正的面向对象的方式，我们声明了一个希望被继承的类，定义新的构造器，并可以使用`super`关键字调用父构造器，并重写`getFullName`方法，使得其支持`middlename`。\\n\\n### 对象字面量的新语法\\n#### 允许缺省值：\\n\\n```javascript\\nconst x = 22;\\nconst y = 17;\\nconst obj = { x, y };\\n```\\n\\n#### 允许省略方法名\\n\\n```javascript\\nmodule.exports = {\\n  square(x) {\\n    return x * x;\\n  },\\n  cube(x) {\\n    return x * x * x;\\n  },\\n};\\n```\\n\\n#### key的计算属性\\n\\n```javascript\\nconst namespace = '-webkit-';\\nconst style = {\\n  [namespace + 'box-sizing']: 'border-box',\\n  [namespace + 'box-shadow']: '10px 10px 5px #888',\\n};\\n```\\n\\n#### 新的定义getter和setter方式\\n\\n```javascript\\nconst person = {\\n  name: 'George',\\n  surname: 'Boole',\\n\\n  get fullname() {\\n    return this.name + ' ' + this.surname;\\n  },\\n\\n  set fullname(fullname) {\\n    let parts = fullname.split(' ');\\n    this.name = parts[0];\\n    this.surname = parts[1];\\n  }\\n};\\n\\nconsole.log(person.fullname); // \\\"George Boole\\\"\\nconsole.log(person.fullname = 'Alan Turing'); // \\\"Alan Turing\\\"\\nconsole.log(person.name); // \\\"Alan\\\"\\n```\\n\\n这里，第二个`console.log`触发了`set`方法。\\n\\n### 模板字符串\\n\\n### 其它ES2015语法\\n* [函数默认参数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Default_parameters)\\n* [剩余参数语法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Rest_parameters)\\n* [拓展运算符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_operator)\\n* [解构赋值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)\\n* [new.target](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new.target)\\n* [代理](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy)\\n* [反射](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect)\\n* [Symbol](https://developer.mozilla.org/zh-CN/docs/Glossary/Symbol)\\n\\n## reactor模式\\n`reactor模式`是`Node.js`异步编程的核心模块，其核心概念是：`单线程`、`非阻塞I/O`，通过下列例子可以看到`reactor模式`在`Node.js`平台的体现。\\n\\n### I/O是缓慢的\\n在计算机的基本操作中，输入输出肯定是最慢的。访问内存的速度是纳秒级(`10e-9 s`)，同时访问磁盘上的数据或访问网络上的数据则更慢，是毫秒级(`10e-3 s`)。内存的传输速度一般认为是`GB/s`来计算，然而磁盘或网络的访问速度则比较慢，一般是`MB/s`。虽然对于`CPU`而言，`I/O`操作的资源消耗并不算大，但是在发送`I/O`请求和操作完成之间总会存在时间延迟。除此之外，我们还必须考虑人为因素，通常情况下，应用程序的输入是人为产生的，例如：按钮的点击、即时聊天工具的信息发送。因此，输入输出的速度并不因网络和磁盘访问速率慢造成的，还有多方面的因素。\\n\\n### 阻塞I/O\\n在一个`阻塞I/O`模型的进程中，`I/O`请求会阻塞之后代码块的运行。在`I/O`请求操作完成之前，线程会有一段不定长的时间浪费。（它可能是毫秒级的，但甚至有可能是分钟级的，如用户按着一个按键不放的情况）。以下例子就是一个`阻塞I/O`模型。\\n\\n```javascript\\n// 直到请求完成，数据可用，线程都是阻塞的\\ndata = socket.read();\\n// 请求完成，数据可用\\nprint(data);\\n```\\n\\n我们知道，`阻塞I/O`的服务器模型并不能在一个线程中处理多个连接，每次`I/O`都会阻塞其它连接的处理。出于这个原因，对于每个需要处理的并发连接，传统的web服务器的处理方式是新开一个新的进程或线程（或者从线程池中重用一个进程）。这样，当一个线程因 `I/O`操作被阻塞时，它并不会影响另一个线程的可用性，因为他们是在彼此独立的线程中处理的。\\n\\n通过下面这张图：\\n\\n![](http://oczira72b.bkt.clouddn.com/17-9-14/68827012.jpg)\\n\\n通过上面的图片我们可以看到每个线程都有一段时间处于空闲等待状态，等待从关联连接接收新数据。如果所有种类的`I/O`操作都会阻塞后续请求。例如，连接数据库和访问文件系统，现在我们能很快知晓一个线程需要因等待`I/O`操作的结果等待许多时间。不幸的是，一个线程所持有的`CPU`资源并不廉价，它需要消耗内存、造成`CPU`上下文切换，因此，长期占有`CPU`而大部分时间并没有使用的线程，在资源利用率上考虑，并不是高效的选择。\\n\\n### 非阻塞I/O\\n除`阻塞I/O`之外，大部分现代的操作系统支持另外一种访问资源的机制，即`非阻塞I/O`。在这种机制下，后续代码块不会等到`I/O`请求数据的返回之后再执行。如果当前时刻所有数据都不可用，函数会先返回预先定义的常量值(如`undefined`)，表明当前时刻暂无数据可用。\\n\\n例如，在`Unix`操作系统中，`fcntl()`函数操作一个已存在的文件描述符，改变其操作模式为`非阻塞I/O`(通过`O_NONBLOCK`状态字)。一旦资源是非阻塞模式，如果读取文件操作没有可读取的数据,或者如果写文件操作被阻塞,读操作或写操作返回`-1`和`EAGAIN`错误。\\n\\n`非阻塞I/O`最基本的模式是通过轮询获取数据，这也叫做**忙-等模型**。看下面这个例子，通过`非阻塞I/O`和轮询机制获取`I/O`的结果。\\n\\n```javascript\\nresources = [socketA, socketB, pipeA];\\nwhile(!resources.isEmpty()) {\\n  for (i = 0; i < resources.length; i++) {\\n    resource = resources[i];\\n    // 进行读操作\\n    let data = resource.read();\\n    if (data === NO_DATA_AVAILABLE) {\\n      // 此时还没有数据\\n      continue;\\n    }\\n    if (data === RESOURCE_CLOSED) {\\n      // 资源被释放，从队列中移除该链接\\n      resources.remove(i);\\n    } else {\\n      consumeData(data);\\n    }\\n  }\\n}\\n```\\n\\n我们可以看到，通过这个简单的技术，已经可以在一个线程中处理不同的资源了，但依然不是高效的。事实上，在前面的例子中，用于迭代资源的循环只会消耗宝贵的`CPU`，而这些资源的浪费比起`阻塞I/O`反而更不可接受，轮询算法通常浪费大量`CPU`时间。\\n\\n### 事件多路复用\\n对于获取非阻塞的资源而言，`忙-等模型`不是一个理想的技术。但是幸运的是，大多数现代的操作系统提供了一个原生的机制来处理并发，非阻塞资源（同步事件多路复用器）是一个有效的方法。这种机制被称作事件循环机制，这种事件收集和`I/O队列`源于`发布-订阅模式`。事件多路复用器收集资源的`I/O`事件并且把这些事件放入队列中，直到事件被处理时都是阻塞状态。看下面这个伪代码：\\n\\n```javascript\\nsocketA, pipeB;\\nwachedList.add(socketA, FOR_READ);\\nwachedList.add(pipeB, FOR_READ);\\nwhile(events = demultiplexer.watch(wachedList)) {\\n  // 事件循环\\n  foreach(event in events) {\\n    // 这里并不会阻塞，并且总会有返回值（不管是不是确切的值）\\n    data = event.resource.read();\\n    if (data === RESOURCE_CLOSED) {\\n      // 资源已经被释放，从观察者队列移除\\n      demultiplexer.unwatch(event.resource);\\n    } else {\\n      // 成功拿到资源，放入缓冲池\\n      consumeData(data);\\n    }\\n  }\\n}\\n```\\n\\n事件多路复用的三个步骤：\\n\\n* 资源被添加到一个数据结构中，为每个资源关联一个特定的操作，在这个例子中是`read`。\\n* 事件通知器由一组被观察的资源组成，一旦事件即将触发，会调用同步的`watch`函数，并返回这个可被处理的事件。\\n* 最后，处理事件多路复用器返回的每个事件，此时，与系统资源相关联的事件将被读并且在整个操作中都是非阻塞的。直到所有事件都被处理完时，事件多路复用器会再次阻塞，然后重复这个步骤，以上就是`event loop`。\\n\\n![](http://oczira72b.bkt.clouddn.com/17-9-21/40680479.jpg)\\n\\n上图可以很好的帮助我们理解在一个单线程的应用程序中使用同步的时间多路复用器和非阻塞`I/O`实现并发。我们能够看到，只使用一个线程并不会影响我们处理多个`I/O`任务的性能。同时，我们看到任务是在单个线程中随着时间的推移而展开的，而不是分散在多个线程中。我们看到，在单线程中传播的任务相对于多线程中传播的任务反而节约了线程的总体空闲时间，并且更利于程序员编写代码。在这本书中，你可以看到我们可以用更简单的并发策略，因为不需要考虑多线程的互斥和同步问题。\\n\\n在下一章中，我们有更多机会讨论`Node.js`的并发模型。\\n\\n### 介绍reactor模式\\n现在来说`reactor模式`，它通过一种特殊的算法设计的处理程序（在`Node.js`中是使用一个回调函数表示），一旦事件产生并在事件循环中被处理，那么相关`handler`将会被调用。\\n\\n它的结构如图所示：\\n\\n![](http://oczira72b.bkt.clouddn.com/17-9-21/38778114.jpg)\\n\\n`reactor模式`的步骤为：\\n\\n* 应用程序通过提交请求到时间多路复用器产生一个新的`I/O`操作。应用程序指定`handler`，`handler` 在操作完成后被调用。提交请求到事件多路复用器是非阻塞的，其调用所以会立马返回，将执行权返回给应用程序。\\n* 当一组`I/O`操作完成，事件多路复用器会将这些新事件添加到事件循环队列中。\\n* 此时，事件循环会迭代事件循环队列中的每个事件。\\n* 对于每个事件，对应的`handler`被处理。\\n* `handler`，是应用程序代码的一部分，`handler`执行结束后执行权会交回事件循环。但是，在`handler` 执行时可能请求新的异步操作，从而新的操作被添加到事件多路复用器。\\n* 当事件循环队列的全部事件被处理完后，循环会在事件多路复用器再次阻塞直到有一个新的事件可处理触发下一次循环。\\n\\n\\n我们现在可以定义`Node.js`的核心模式：\\n\\n模式(反应器)阻塞处理`I/O`到在一组观察的资源有新的事件可处理，然后以分派每个事件对应`handler`的方式反应。\\n\\n### OS的非阻塞I/O引擎\\n每个操作系统对于事件多路复用器有其自身的接口，`Linux`是`epoll`，`Mac OSX`是`kqueue`，`Windows`的`IOCP API`。除外，即使在相同的操作系统中，每个`I/O`操作对于不同的资源表现不一样。例如，在`Unix`下，普通文件系统不支持非阻塞操作，所以，为了模拟非阻塞行为，需要使用在事件循环外用一个独立的线程。所有这些平台内和跨平台的不一致性需要在事件多路复用器的上层做抽象。这就是为什么`Node.js`为了兼容所有主流平台而\\n编写C语言库`libuv`，目的就是为了使得`Node.js`兼容所有主流平台和规范化不同类型资源的非阻塞行为。`libuv`今天作为`Node.js`的`I/O`引擎的底层。\\n\"\n}"
*************** response log end ***************

[2017-12-01 12:19:30.340] [INFO] resLogger - 
*************** response log start ***************
request method: GET
request originalUrl:  /api/users/getUserInfo?userName=admin
request client ip:  ::1
request query:  {"userName":"admin"}
response time: 1
response status: 200
response body: 
"{\n  \"code\": 1,\n  \"message\": \"回复成功\",\n  \"data\": {\n    \"userName\": \"admin\",\n    \"registerTime\": \"2017-11-23T07:36:51.931Z\",\n    \"message\": []\n  }\n}"
*************** response log end ***************

